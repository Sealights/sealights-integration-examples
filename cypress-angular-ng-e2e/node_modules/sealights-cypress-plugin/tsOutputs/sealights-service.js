"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SealightsTestSessionService = void 0;
const request = require("sl-request");
const util_1 = require("util");
const jwt_decode_1 = require("jwt-decode");
const const_1 = require("./const");
const utils_1 = require("./utils");
const logger = require("./logger");
const requestPromise = (0, util_1.promisify)(request);
class TestSessionService {
    constructor() {
        this.baseUrl = null;
        this.testSessionId = null;
        this.requestV1InstanceConfig = null;
        this.requestV2InstanceConfig = null;
        this.excludedTests = null;
        this.configurationError = false;
        this.skippedTests = {};
        this.testEventsMap = {};
    }
    static getInstance() {
        if (!TestSessionService.instance) {
            TestSessionService.instance = new TestSessionService();
        }
        return TestSessionService.instance;
    }
    setConfig(slConfig) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this.SLConfig = slConfig;
            if (!((_a = slConfig.buildSessionId) === null || _a === void 0 ? void 0 : _a.length) && !((_b = slConfig.labId) === null || _b === void 0 ? void 0 : _b.length)) {
                this.configurationError = true;
                throw new Error('At least one of buildSessionId/labId must be provided for Sealights integration. Test suite will resume with disabled integration.');
            }
            if (!((_c = slConfig.testStage) === null || _c === void 0 ? void 0 : _c.length)) {
                this.configurationError = true;
                throw new Error('A valid Test Stage parameter must be provided for Sealights integration. Test suite will resume with disabled integration.');
            }
            let decodedToken = null;
            try {
                decodedToken = (0, jwt_decode_1.default)(slConfig.token);
            }
            catch (e) {
                this.configurationError = true;
                throw new Error(`${(0, utils_1.sanitizeError)(e)}. Test suite will resume with disabled integration.`);
            }
            this.baseUrl = decodedToken[const_1.X_SL_SERVER];
            this.createInstanceV1();
            this.createInstanceV2();
        });
    }
    addProxyToConfig(requestConfig) {
        var _a;
        if (!((_a = this.SLConfig.proxy) === null || _a === void 0 ? void 0 : _a.length)) {
            return;
        }
        try {
            new URL(this.SLConfig.proxy);
            requestConfig.proxy = this.SLConfig.proxy;
        }
        catch (e) {
            logger.error('Invalid proxy provided, skipping proxy configuration.');
            return null;
        }
    }
    createInstanceV1() {
        var _a;
        const requestConfig = {
            baseUrl: (_a = this.baseUrl) === null || _a === void 0 ? void 0 : _a.replace('/api', '/sl-api/v1/test-sessions'),
            headers: {
                Authorization: `Bearer ${this.SLConfig.token}`,
            },
        };
        this.addProxyToConfig(requestConfig);
        this.requestV1InstanceConfig = requestConfig;
    }
    createInstanceV2() {
        var _a;
        const requestConfig = {
            baseUrl: (_a = this.baseUrl) === null || _a === void 0 ? void 0 : _a.replace('/api', '/sl-api/v2/test-sessions'),
            headers: {
                Authorization: `Bearer ${this.SLConfig.token}`,
            },
        };
        this.addProxyToConfig(requestConfig);
        this.requestV2InstanceConfig = requestConfig;
    }
    resolveTestSession() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('Initiating test session resolve using remote-agent...');
            if (this.testSessionId) {
                logger.debug('Test session already resolved, skipping.');
                return;
            }
            yield this.remoteAgent.loadExecution();
            this.testSessionId = (_a = this.remoteAgent.getExecutionData()) === null || _a === void 0 ? void 0 : _a.executionId;
            if (!this.testSessionId) {
                logger.info('No active execution found. Verify execution was started using slnodejs start command.');
                return;
            }
            logger.info('Test session successfully resolved.');
        });
    }
    createTestSession(testStage = this.SLConfig.testStage) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('Initiating test session creation with parameters: ', {
                testStage,
                bsid: this.SLConfig.buildSessionId,
                labid: this.SLConfig.labId,
            });
            if (this.testSessionId) {
                logger.debug('Test session already exists, skipping creation.');
                return;
            }
            if (this.remoteAgent) {
                logger.debug('Using remote agent for test session creation.');
                yield this.remoteAgent.startExecution();
                this.testSessionId = this.remoteAgent.getExecutionData().executionId;
            }
            else {
                logger.debug('Using API for test session creation.');
                const response = yield requestPromise(Object.assign(Object.assign({}, this.requestV1InstanceConfig), { url: '/', method: 'POST', body: {
                        testStage,
                        bsid: this.SLConfig.buildSessionId,
                        labid: this.SLConfig.labId,
                    }, json: true }));
                this.testSessionId = response.body.data.testSessionId;
            }
            logger.info('Test session successfully created.');
        });
    }
    endTestSession() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('Initiating test session end...');
            if (this.remoteAgent) {
                logger.debug('Using remote agent for test session end.');
                yield this.remoteAgent.stop();
            }
            else {
                logger.debug('Using API for test session end.');
                yield requestPromise(Object.assign(Object.assign({}, this.requestV1InstanceConfig), { url: `/${this.testSessionId}`, method: 'DELETE' }));
            }
            this.testSessionId = null;
            logger.info('Test session successfully ended.');
        });
    }
    getTestRecommendations() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.SLConfig.tiaDisabled) {
                logger.info('TIA is disabled, skipping test recommendation retrieval.');
                this.excludedTests = {};
                return this.excludedTests;
            }
            if (this.SLConfig.perFileReporting) {
                logger.info('Per file reporting is enabled, skipping test recommendation retrieval. Test recommendations should be managed using Sealights Public API.');
                this.excludedTests = {};
            }
            if (this.excludedTests) {
                return this.excludedTests;
            }
            logger.debug('Initiating test recommendation retrieval...');
            if (!this.testSessionId) {
                logger.info('No active execution found. Test recommendations will not be retrieved.');
                return this.excludedTests;
            }
            try {
                const response = yield requestPromise(Object.assign(Object.assign({}, this.requestV1InstanceConfig), { url: `/${this.testSessionId}/exclude-tests`, method: 'GET' }));
                this.excludedTests = (((_b = (_a = response.body) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.length) ? (_c = response.body) === null || _c === void 0 ? void 0 : _c.data : []).reduce((acc, testName) => (Object.assign(Object.assign({}, acc), { [testName]: testName })), {});
                logger.info(`Test recommendation successfully retrieved. ${Object.keys(this.excludedTests).length} tests will be marked for exclusion.`);
                return this.excludedTests;
            }
            catch (e) {
                logger.error('Failed to retrieve test recommendation.', (0, utils_1.sanitizeError)(e));
                this.excludedTests = {};
                return this.excludedTests;
            }
        });
    }
    resolveBuildSessionData() {
        return __awaiter(this, void 0, void 0, function* () {
            const labId = this.SLConfig.labId;
            logger.debug(`Initiating build session data resolve for lab id ${labId}...`);
            const requestConfig = {
                url: this.baseUrl + `/v1/lab-ids/${labId}/build-sessions/active/`,
                headers: {
                    Authorization: `Bearer ${this.SLConfig.token}`,
                },
            };
            this.addProxyToConfig(requestConfig);
            const response = yield requestPromise(requestConfig);
            logger.debug('Build session data successfully resolved.');
            return response.body;
        });
    }
    sendTestEvent(name, start, end, status, spec) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug(`Initiating test event send for test ${name}...`);
            if (status === const_1.TEST_STATUS.SKIPPED) {
                if (this.skippedTests[`${spec.relative}_${name}`]) {
                    return;
                }
                this.skippedTests[`${spec.relative}_${name}`] = true;
            }
            this.markTestReported(spec.name, name, status);
            if (this.SLConfig.perFileReporting) {
                logger.debug('Per file reporting is enabled, skipping single test event send.');
                return;
            }
            if (this.remoteAgent) {
                yield this.remoteAgent.testStart(name, spec.name, start);
                yield this.remoteAgent.testEnd(name, spec.name, end - start, status, undefined);
                logger.debug(`Test event successfully sent for test ${name} using remote agent.`);
                return;
            }
            yield requestPromise(Object.assign(Object.assign({}, this.requestV2InstanceConfig), { url: `/${this.testSessionId}`, method: 'POST', json: true, body: [
                    {
                        name,
                        start,
                        end,
                        status,
                    },
                ] }));
            logger.debug(`Test event successfully sent for test ${name} using API.`);
        });
    }
    sendCoverage(testName, componentCoverageData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.SLConfig.dropFootprints) {
                logger.debug('Coverage drop is enabled, skipping coverage send.');
                return;
            }
            logger.debug(`Initiating coverage send for test: ${testName}`);
            yield this.remoteAgent.sendComponentsTestCoverage(testName, componentCoverageData);
            logger.debug(`Footprints successfully sent for test ${testName}.`);
        });
    }
    sendTestEventPerSpec(spec) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug(`Initiating test event send for spec ${spec.name}...`);
            const specHasFailedTest = Object.values(this.testEventsMap[spec.name].tests).some((testStatus) => testStatus === const_1.TEST_STATUS.FAILED);
            const status = specHasFailedTest ? const_1.TEST_STATUS.FAILED : const_1.TEST_STATUS.PASSED;
            const end = Date.now();
            if (this.SLConfig.enableRemoteAgent) {
                yield this.remoteAgent.testStart(spec.name, spec.name, this.testEventsMap[spec.name].start);
                yield this.remoteAgent.testEnd(spec.name, spec.name, end - this.testEventsMap[spec.name].start, status, undefined);
            }
            else {
                yield requestPromise(Object.assign(Object.assign({}, this.requestV2InstanceConfig), { url: `/${this.testSessionId}`, method: 'POST', json: true, body: [
                        {
                            name: spec.name,
                            start: this.testEventsMap[spec.name].start,
                            end,
                            status,
                        },
                    ] }));
            }
            logger.info(`Test event successfully sent for spec ${spec.name}.`);
        });
    }
    markTestReported(spec, testName, status) {
        if (!this.testEventsMap[spec]) {
            this.testEventsMap[spec] = {
                start: Date.now(),
                tests: {},
            };
        }
        this.testEventsMap[spec].tests[testName] = status;
    }
    get _testSessionId() {
        return this.testSessionId;
    }
    set _configurationError(hasError) {
        this.configurationError = hasError;
    }
    get _configurationError() {
        return this.configurationError;
    }
    set _remoteAgent(remoteAgent) {
        this.remoteAgent = remoteAgent;
    }
    set _buildSessionId(buildSessionId) {
        this.SLConfig.buildSessionId = buildSessionId;
    }
    static runServiceMethodSafe(_, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = function (...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    if (this.configurationError) {
                        return null;
                    }
                    return yield originalMethod.apply(this, args);
                }
                catch (error) {
                    const sanitizedError = (0, utils_1.sanitizeError)(error);
                    logger.error(`An error occurred in method ${propertyKey}:`, sanitizedError);
                }
            });
        };
        return descriptor;
    }
}
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "setConfig", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "resolveTestSession", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "createTestSession", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "endTestSession", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "getTestRecommendations", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "resolveBuildSessionData", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "sendTestEvent", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "sendCoverage", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "sendTestEventPerSpec", null);
exports.SealightsTestSessionService = TestSessionService.getInstance();
//# sourceMappingURL=sealights-service.js.map