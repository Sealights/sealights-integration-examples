"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTrue = exports.getConfigValue = exports.collectCoverageFromWindow = exports.mapIstanbulCoverage = exports.filterAndRemoveKeys = exports.sanitizeError = exports.checkAgentLoaded = exports.constructTestName = void 0;
const const_1 = require("./const");
const logger = require("./logger");
function constructTestName(specRelativePath, suiteName, testName) {
    return `${specRelativePath} - ${suiteName} - ${testName}`;
}
exports.constructTestName = constructTestName;
function checkAgentLoaded(win, intervalMs = 100, timeoutSeconds = 5) {
    return new Promise((resolve) => {
        const start = Date.now();
        const intervalId = setInterval(() => {
            if (win['$SealightsAgent'] !== undefined) {
                clearInterval(intervalId);
                resolve(true);
            }
            else {
                const elapsed = Date.now() - start;
                if (elapsed >= timeoutSeconds * 1000) {
                    clearInterval(intervalId);
                    resolve(false);
                }
            }
        }, intervalMs);
    });
}
exports.checkAgentLoaded = checkAgentLoaded;
function sanitizeError(error) {
    var _a, _b, _c, _d, _e, _f, _g;
    const sanitizedError = new Error('An error occurred');
    sanitizedError.stack = undefined;
    sanitizedError.name = error.name;
    sanitizedError.message = error.message;
    const response = {};
    response.statusText = (_a = error.response) === null || _a === void 0 ? void 0 : _a.statusText;
    response.status = (_b = error.response) === null || _b === void 0 ? void 0 : _b.status;
    response.data = (_c = error.response) === null || _c === void 0 ? void 0 : _c.data;
    response.url = (_e = (_d = error.response) === null || _d === void 0 ? void 0 : _d.config) === null || _e === void 0 ? void 0 : _e.url;
    response.baseURL = (_g = (_f = error.response) === null || _f === void 0 ? void 0 : _f.config) === null || _g === void 0 ? void 0 : _g.baseURL;
    const filteredResponse = removeEmpty(response);
    if (Object.keys(filteredResponse).length) {
        sanitizedError.response = filteredResponse;
    }
    return sanitizedError;
}
exports.sanitizeError = sanitizeError;
function removeEmpty(obj) {
    const newObj = {};
    Object.keys(obj).forEach((key) => {
        if (obj[key] === Object(obj[key]))
            newObj[key] = removeEmpty(obj[key]);
        else if (obj[key] !== undefined)
            newObj[key] = obj[key];
    });
    return newObj;
}
function filterAndRemoveKeys(functionMapAndCoverage) {
    let { fnMap } = functionMapAndCoverage;
    const { f } = functionMapAndCoverage;
    if (!fnMap) {
        fnMap = {};
    }
    const filteredKeys = Object.keys(f).filter((key) => f[key] !== 0);
    const filteredObj = {
        f: filteredKeys.reduce((acc, key) => {
            acc[key] = f[key];
            return acc;
        }, {}),
        fnMap: Object.keys(fnMap)
            .filter((key) => filteredKeys.includes(key))
            .reduce((acc, key) => {
            acc[key] = fnMap[key];
            return acc;
        }, {}),
    };
    return filteredObj;
}
exports.filterAndRemoveKeys = filterAndRemoveKeys;
function mapIstanbulCoverage(allCoverageObjects) {
    const mappedFileCoverage = Object.keys(allCoverageObjects).reduce((acc, coveragePath) => {
        const functionsCoverage = filterAndRemoveKeys(allCoverageObjects[coveragePath]);
        acc[coveragePath] = {
            b: allCoverageObjects[coveragePath].b,
            branchMap: allCoverageObjects[coveragePath].branchMap,
            f: functionsCoverage.f,
            fnMap: functionsCoverage.fnMap,
            hash: allCoverageObjects[coveragePath].hash,
            path: allCoverageObjects[coveragePath].path,
            s: allCoverageObjects[coveragePath].s,
            statementMap: allCoverageObjects[coveragePath].statementMap,
            _coverageSchema: allCoverageObjects[coveragePath]._coverageSchema,
        };
        return acc;
    }, {});
    return mappedFileCoverage;
}
exports.mapIstanbulCoverage = mapIstanbulCoverage;
function collectCoverageFromWindow(win) {
    const coverageObjectPrefix = '$SealightsCoverage_';
    const componentCoverageData = [];
    try {
        cy.task(const_1.SL_DEBUG_LOG, `collectCoverageFromWindow: ${Object.keys(win).length} keys in the window object.`);
        const keys = Object.keys(win).filter((key) => key.includes(coverageObjectPrefix));
        cy.task(const_1.SL_DEBUG_LOG, `collectCoverageFromWindow: ${keys.length} coverage keys in the window object.`);
        keys.forEach((sealightsCoverageKey) => {
            const componentBsid = sealightsCoverageKey.replace(coverageObjectPrefix, '');
            const mappedIstanbulCoverage = mapIstanbulCoverage(win[sealightsCoverageKey]);
            componentCoverageData.push({ buildSessionId: componentBsid, coverage: mappedIstanbulCoverage });
        });
        cy.task(const_1.SL_DEBUG_LOG, 'collectCoverageFromWindow: coverage array created');
        cy.task(const_1.SL_DEBUG_LOG, 'collectCoverageFromWindow: coverage mapped');
        return componentCoverageData;
    }
    catch (e) {
        cy.task(const_1.SL_ERROR_LOG, sanitizeError(e));
    }
}
exports.collectCoverageFromWindow = collectCoverageFromWindow;
function getConfigValue(config, configKey) {
    var _a, _b, _c, _d;
    const value = ((_a = config.env) === null || _a === void 0 ? void 0 : _a[configKey]) || ((_d = (_c = (_b = config.resolved) === null || _b === void 0 ? void 0 : _b.env) === null || _c === void 0 ? void 0 : _c[configKey]) === null || _d === void 0 ? void 0 : _d.value);
    if (value === null || value === undefined) {
        logger.debug(`The env key: ${configKey} could not be found`);
    }
    return value;
}
exports.getConfigValue = getConfigValue;
function isTrue(value) {
    return value === 'true' || value === 1 || value === true;
}
exports.isTrue = isTrue;
//# sourceMappingURL=utils.js.map