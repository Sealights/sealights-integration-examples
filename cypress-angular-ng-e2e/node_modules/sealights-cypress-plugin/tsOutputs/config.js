"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerSealightsTasks = void 0;
const const_1 = require("./const");
const sealights_service_1 = require("./sealights-service");
const utils_1 = require("./utils");
const slnodejs_1 = require("slnodejs");
const logger = require("./logger");
const fs = require("fs");
const version_1 = require("./version");
let coverageCounter = 0;
const registerSealightsTasks = (on, config) => __awaiter(void 0, void 0, void 0, function* () {
    logger.debug(`Using Sealights Cypress Plugin version ${version_1.version}.`);
    logger.debug(`Sealights received Cypress configuration: ${JSON.stringify(config)}`);
    logger.debug(`Sealights received Cypress environment: ${JSON.stringify(config.env)}`);
    const slConfig = {
        buildSessionId: (0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.BUILD_SESSION_ID),
        token: (0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.TOKEN),
        testStage: (0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.TEST_STAGE),
        labId: (0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.LAB_ID),
        enableRemoteAgent: (0, utils_1.isTrue)((0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.ENABLE_REMOTE_AGENT)),
        perFileReporting: (0, utils_1.isTrue)((0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.PER_FILE_REPORTING)),
        proxy: (0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.PROXY),
        collectorUrl: (0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.COLLECTOR_URL),
        dropFootprints: (0, utils_1.isTrue)((0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.DROP_FOOTPRINTS)),
        enablePluginsAPI: (0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.ENABLE_PLUGINS_API),
        liteMode: (0, utils_1.isTrue)((0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.LITE_MODE)),
        liteModeManageExecutions: (0, utils_1.isTrue)((0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.LITE_MODE_MANAGE_EXECUTIONS)),
        tiaDisabled: (0, utils_1.isTrue)((0, utils_1.getConfigValue)(config, const_1.SL_CYPRESS_ENVIRONMENT.TIA_DISABLED)),
    };
    logger.debug(`Sealights configuration: ${JSON.stringify(slConfig)}`);
    if (slConfig.liteMode && !config.testIsolation) {
        logger.error('Test isolation is turned off. This is not recommended and might cause issues with the Sealights plugin. Please refer to the documentation: https://docs.cypress.io/guides/core-concepts/test-isolation#What-is-Test-Isolation');
        sealights_service_1.SealightsTestSessionService._configurationError = true;
    }
    else {
        logger.info('Cypress can run with testIsolation turned off, we discourage this usage as it is not best practice and as well as it might cause issues with the plugin (https://docs.cypress.io/guides/core-concepts/test-isolation#What-is-Test-Isolation)');
    }
    if (slConfig.enablePluginsAPI) {
        logger.info(`The SL_ENABLE_PLUGINS_API flag is enabled. Exercise caution as this may lead to conflicts with other plugins. For more information, refer to: 
      https://github.com/cypress-io/cypress/issues/19809`);
    }
    sealights_service_1.SealightsTestSessionService.setConfig(slConfig);
    let remoteAgent;
    if (slConfig.enableRemoteAgent && !sealights_service_1.SealightsTestSessionService._configurationError) {
        try {
            if (slConfig.labId && !slConfig.buildSessionId) {
                const { buildSessionId } = yield sealights_service_1.SealightsTestSessionService.resolveBuildSessionData();
                sealights_service_1.SealightsTestSessionService._buildSessionId = buildSessionId;
                slConfig.buildSessionId = buildSessionId;
            }
            const remoteAgentConfig = {
                buildsessionid: slConfig.buildSessionId,
                labid: slConfig.labId,
                token: slConfig.token,
                teststage: slConfig.testStage,
                proxy: slConfig.proxy,
                collectorUrl: slConfig.collectorUrl,
            };
            logger.debug('Creating remote agent with config:', remoteAgentConfig);
            remoteAgent = yield (0, slnodejs_1.createRemoteAgent)(remoteAgentConfig);
            yield remoteAgent.start({
                tags: [
                    {
                        name: 'cypress-plugin-remote-agent',
                        version: version_1.version,
                    },
                ],
            });
            remoteAgent.isStartingExecution = true;
            logger.info('Remote Agent created successfully.');
            sealights_service_1.SealightsTestSessionService._remoteAgent = remoteAgent;
        }
        catch (e) {
            logger.error((0, utils_1.sanitizeError)(e));
            sealights_service_1.SealightsTestSessionService._configurationError = true;
        }
    }
    on('task', {
        [const_1.SL_REPORT_TEST_END_TASK]({ suiteName, testName, duration, state, spec }) {
            return __awaiter(this, void 0, void 0, function* () {
                const name = (0, utils_1.constructTestName)(spec.relative, suiteName, testName);
                const start = Date.now() - (isNaN(duration) ? 0 : duration);
                const end = Date.now();
                yield sealights_service_1.SealightsTestSessionService.sendTestEvent(name, start, end, state, spec);
                return null;
            });
        },
        [const_1.SL_REPORT_SPEC_END_TASK]({ spec }) {
            return __awaiter(this, void 0, void 0, function* () {
                yield sealights_service_1.SealightsTestSessionService.sendTestEventPerSpec(spec);
                return null;
            });
        },
        [const_1.SL_GET_TEST_SESSION_ID]() {
            return sealights_service_1.SealightsTestSessionService._testSessionId;
        },
        [const_1.SL_SEND_COVERAGE]({ suiteName, testName, spec, coverage }) {
            return __awaiter(this, void 0, void 0, function* () {
                let constructedTestName = spec.name;
                if (!slConfig.perFileReporting && (suiteName === null || suiteName === void 0 ? void 0 : suiteName.length) && (testName === null || testName === void 0 ? void 0 : testName.length)) {
                    constructedTestName = (0, utils_1.constructTestName)(spec.relative, suiteName, testName);
                }
                if (slConfig.liteMode) {
                    exportCoverageToFile(slConfig, spec, constructedTestName, coverage);
                    return null;
                }
                yield sealights_service_1.SealightsTestSessionService.sendCoverage(constructedTestName, coverage);
                return null;
            });
        },
        [const_1.SL_START_TEST_SESSION]() {
            return __awaiter(this, void 0, void 0, function* () {
                if (slConfig.liteMode && !slConfig.liteModeManageExecutions) {
                    logger.info('Lite mode is enabled. Resolving test session data using Remote Agent.');
                    yield sealights_service_1.SealightsTestSessionService.resolveTestSession();
                }
                else {
                    yield sealights_service_1.SealightsTestSessionService.createTestSession();
                }
                return yield sealights_service_1.SealightsTestSessionService.getTestRecommendations();
            });
        },
        [const_1.SL_END_TEST_SESSION]() {
            return __awaiter(this, void 0, void 0, function* () {
                if (slConfig.liteMode && !slConfig.liteModeManageExecutions) {
                    logger.info('Lite mode is enabled. Skipping test session end.');
                }
                else {
                    yield sealights_service_1.SealightsTestSessionService.endTestSession();
                }
                return null;
            });
        },
        [const_1.SL_DEBUG_LOG](...args) {
            return __awaiter(this, void 0, void 0, function* () {
                logger.debug(...args);
                return null;
            });
        },
        [const_1.SL_ERROR_LOG](...args) {
            return __awaiter(this, void 0, void 0, function* () {
                logger.error(...args);
                return null;
            });
        },
    });
    if (slConfig.enablePluginsAPI) {
        on('before:run', () => __awaiter(void 0, void 0, void 0, function* () {
            if (slConfig.liteMode && !slConfig.liteModeManageExecutions) {
                logger.info('before:run Lite mode is enabled. Resolving test session data using Remote Agent.');
                yield sealights_service_1.SealightsTestSessionService.resolveTestSession();
            }
            else {
                logger.info('before:run Running Sealights tasks before:run. Test session creation will be initiated.');
                yield sealights_service_1.SealightsTestSessionService.createTestSession();
            }
            yield sealights_service_1.SealightsTestSessionService.getTestRecommendations();
        }));
        on('after:run', () => __awaiter(void 0, void 0, void 0, function* () {
            if (slConfig.liteMode && !slConfig.liteModeManageExecutions) {
                logger.info('after:run Lite mode is enabled. Skipping test session end.');
                return;
            }
            logger.info('after:run Running Sealights tasks. Test session will be ended.');
            yield sealights_service_1.SealightsTestSessionService.endTestSession();
        }));
    }
    config.env[const_1.SL_TASKS_REGISTERED] = true;
    return config;
});
exports.registerSealightsTasks = registerSealightsTasks;
function exportCoverageToFile(slConfig, spec, testName, coverage) {
    const coverageExportDirectory = `${process.cwd()}/sl-coverage-files`;
    createConfigFile(slConfig, coverageExportDirectory);
    logger.debug(`Initiating coverage export to file for spec ${spec.name} - test ${testName}...`);
    const jsonString = JSON.stringify({
        coverage,
        meta: {
            colorName: testName,
            timestamp: new Date().getTime(),
        },
    });
    fs.writeFileSync(`${coverageExportDirectory}/coverage-${coverageCounter}.json`, jsonString);
    coverageCounter++;
    logger.debug(`Coverage successfully exported to file for spec ${spec.name} - test ${testName}.`);
}
function createConfigFile(slConfig, coverageExportDirectory) {
    if (!fs.existsSync(coverageExportDirectory)) {
        fs.mkdirSync(coverageExportDirectory);
        logger.debug(`Coverage directory created at ${coverageExportDirectory}`);
    }
    if (!fs.existsSync(`${coverageExportDirectory}/sl-config.json`)) {
        logger.debug(`Lite mode is enabled. Sealights config will be stored in a file: ${coverageExportDirectory}/sl-config.json`);
        fs.writeFileSync(`${coverageExportDirectory}/sl-config.json`, JSON.stringify({
            buildSessionId: slConfig.buildSessionId,
            token: slConfig.token,
            testStage: slConfig.testStage,
            labId: slConfig.labId,
            proxy: slConfig.proxy,
            collectorUrl: slConfig.collectorUrl,
        }));
        logger.debug(`Sealights config successfully stored in a file: ${coverageExportDirectory}/sl-config.json`);
    }
    else {
        logger.debug(`Lite mode is enabled. Sealights config already exists in a file: ${coverageExportDirectory}/sl-config.json`);
    }
}
//# sourceMappingURL=config.js.map