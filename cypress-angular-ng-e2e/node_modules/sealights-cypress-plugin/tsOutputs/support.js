"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const const_1 = require("./const");
const utils_1 = require("./utils");
const config = {
    enableRemoteAgent: (0, utils_1.isTrue)(Cypress.env(const_1.SL_CYPRESS_ENVIRONMENT.ENABLE_REMOTE_AGENT)),
    perFileReporting: (0, utils_1.isTrue)(Cypress.env(const_1.SL_CYPRESS_ENVIRONMENT.PER_FILE_REPORTING)),
    enablePluginsAPI: (0, utils_1.isTrue)(Cypress.env(const_1.SL_CYPRESS_ENVIRONMENT.ENABLE_PLUGINS_API)),
};
if (config.enableRemoteAgent) {
    Cypress.on('window:before:load', (win) => {
        win['$Sealights'] = win['$Sealights'] || {};
        win['$Sealights']['skipSlAgent'] = true;
    });
    if (!config.enablePluginsAPI) {
        Cypress.Commands.overwrite('reload', (originalReload, ...args) => {
            cy.window().then((win) => {
                const coverage = (0, utils_1.collectCoverageFromWindow)(win);
                cy.task(const_1.SL_SEND_COVERAGE, {
                    spec: Cypress.spec,
                    coverage,
                });
                originalReload(...args);
            });
        });
    }
}
function registerHooks() {
    before(function () {
        if (config.enablePluginsAPI) {
            cy.task(const_1.SL_DEBUG_LOG, 'SL_ENABLE_PLUGINS_API is enabled. Before hook will not be executed.');
            return;
        }
        cy.task(const_1.SL_START_TEST_SESSION).then((excludedTests) => {
            markExcludedTests(this.test.parent, excludedTests, Cypress.spec);
        });
    });
    after(function () {
        if (!config.perFileReporting) {
            return;
        }
        cy.window().then(() => __awaiter(this, void 0, void 0, function* () {
            cy.task(const_1.SL_REPORT_SPEC_END_TASK, {
                spec: Cypress.spec,
            });
        }));
    });
    after(function () {
        if (config.enablePluginsAPI) {
            cy.task(const_1.SL_DEBUG_LOG, 'SL_ENABLE_PLUGINS_API is enabled. After hook will not be executed.');
            return;
        }
        cy.task(const_1.SL_END_TEST_SESSION);
    });
    beforeEach(function () {
        if (config.enableRemoteAgent) {
            return;
        }
        const testSessionId = cy.task(const_1.SL_GET_TEST_SESSION_ID);
        cy.window().then((win) => __awaiter(this, void 0, void 0, function* () {
            const agentLoaded = yield (0, utils_1.checkAgentLoaded)(win, 100, 1);
            if (!agentLoaded) {
                return;
            }
            const testName = Cypress.currentTest.title;
            const customEvent = new CustomEvent(const_1.SL_COLORING_EVENTS.SET_CONTEXT, {
                detail: {
                    baggage: {
                        [const_1.SL_COLORING_HEADERS.TEST_NAME]: testName,
                        [const_1.SL_COLORING_HEADERS.TEST_SESSION_ID]: testSessionId,
                    },
                },
            });
            win.dispatchEvent(customEvent);
        }));
    });
    afterEach(function () {
        const currentTest = this.currentTest;
        const testName = currentTest.title;
        const suiteName = currentTest.parent.title;
        cy.window().then((win) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (config.enableRemoteAgent) {
                const coverage = (0, utils_1.collectCoverageFromWindow)(win);
                cy.task(const_1.SL_SEND_COVERAGE, {
                    testName: !config.perFileReporting ? testName : undefined,
                    suiteName: !config.perFileReporting ? suiteName : undefined,
                    spec: Cypress.spec,
                    coverage,
                });
                return;
            }
            if (typeof ((_a = win === null || win === void 0 ? void 0 : win.$SealightsAgent) === null || _a === void 0 ? void 0 : _a.sendAllFootprints) !== 'function') {
                return;
            }
            yield ((_c = (_b = win === null || win === void 0 ? void 0 : win.$SealightsAgent) === null || _b === void 0 ? void 0 : _b.sendAllFootprints) === null || _c === void 0 ? void 0 : _c.call(_b));
        }));
    });
    afterEach(function () {
        const currentTest = this.currentTest;
        const duration = currentTest.duration;
        const testName = currentTest.title;
        const suiteName = currentTest.parent.title;
        const state = currentTest.state;
        cy.window().then(() => __awaiter(this, void 0, void 0, function* () {
            cy.task(const_1.SL_REPORT_TEST_END_TASK, {
                testName,
                suiteName,
                duration,
                state,
                spec: Cypress.spec,
            });
        }));
    });
    function markExcludedTests(suite, excludedTests, spec) {
        if (!excludedTests) {
            return;
        }
        suite.suites.forEach((suite) => markExcludedTests(suite, excludedTests, spec));
        suite.tests.forEach((test) => {
            test.pending = excludedTests[(0, utils_1.constructTestName)(spec.relative, suite.title, test.title)] ? true : test.pending;
            if (test.pending) {
                cy.task(const_1.SL_REPORT_TEST_END_TASK, {
                    testName: test.title,
                    suiteName: suite.title,
                    duration: 0,
                    state: const_1.TEST_STATUS.SKIPPED,
                    spec,
                });
            }
        });
    }
}
registerHooks();
//# sourceMappingURL=support.js.map