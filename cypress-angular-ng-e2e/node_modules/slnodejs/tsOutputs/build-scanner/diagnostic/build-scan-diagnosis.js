"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DryRunDiagnosis = exports.BuildScanDiagnosis = void 0;
const helper_methods_1 = require("../../cli-parse/executors/dry-run/helper-methods");
const cockpit_notifier_1 = require("../../common/agent-events/cockpit-notifier");
const url_1 = require("url");
const contracts_1 = require("./contracts");
function stringIsAValidUrl(srt) {
    try {
        new url_1.URL(srt);
        return true;
    }
    catch (err) {
        return false;
    }
}
function getSourceMapType(fileContent) {
    var _a;
    const regex = new RegExp('\/\/# sourceMappingURL=(.*)$');
    const sourceMapUrl = (_a = regex.exec(fileContent)) === null || _a === void 0 ? void 0 : _a[1];
    if (!sourceMapUrl) {
        return {
            type: contracts_1.SourceMapType.NONE,
        };
    }
    if (sourceMapUrl.startsWith('data:application/json;')) {
        return {
            type: contracts_1.SourceMapType.EMBEDDED,
        };
    }
    return {
        type: stringIsAValidUrl(sourceMapUrl) ? contracts_1.SourceMapType.URL : contracts_1.SourceMapType.LOCAL,
        value: sourceMapUrl
    };
}
class BuildScanDiagnosis {
    constructor(buildSessionId, backendProxy, threshold = 10000) {
        this.buildSessionId = buildSessionId;
        this.backendProxy = backendProxy;
        this.threshold = threshold;
        this.diagnosticEvents = [];
        this.chunkNumber = 1;
        this.blobSubmitPromise = Promise.resolve();
    }
    pushEvent(identifier, type, payload) {
        this.diagnosticEvents.push({
            identifier,
            type,
            data: payload,
        });
        if (this.diagnosticEvents.length > this.threshold) {
            this.submitDiagnostic();
        }
    }
    fileIgnored(absolutePath) {
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.FILE_IGNORED);
    }
    fileScanned(absolutePath) {
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.FILE_SCANNED);
    }
    fileSignatureCreated(absolutePath, fileSignature) {
        const payload = {
            relativePath: fileSignature.relativePath,
            sourceMap: getSourceMapType(fileSignature.content),
        };
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.FILE_SIGNATURE_CREATED, payload);
        fileSignature.methods.forEach(m => {
            const payload = {
                techSpecificInfo: m.techSpecificInfo,
                generatedData: {
                    start: m.generatedData.position,
                    end: m.generatedData.endPosition,
                    name: m.generatedData.displayName,
                    identifierPos: m.generatedData.identifierPosition,
                },
                uniqueId: m.uniqueId,
                uniqueIdKey: m.uniqueIdKey,
            };
            this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.METHOD_ADDED_TO_SIGNATURE, payload);
        });
    }
    fileSignatureCreatedWithError(absolutePath) {
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.FILE_SIGNATURE_CREATED_WITH_ERROR);
    }
    fileWithoutSourceMap(absolutePath) {
        // TODO: currently we already get this info from FileSignature but this is not a trusted source according to ronis
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.FILE_SOURCEMAP_IS_FOUND);
    }
    fileWithSourceMap(absolutePath) {
        // TODO: currently we already get this info from FileSignature but this is not a trusted source according to ronis
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.FILE_SOURCEMAP_NOT_FOUND);
    }
    methodWasMapped(uniqueIdKey, position, endPosition, displayName) {
        const [absolutePath, methodKey] = uniqueIdKey.split('@');
        const payload = {
            start: position,
            end: endPosition,
            name: displayName,
            methodKey,
        };
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.METHOD_WAS_MAPPED, payload);
    }
    addMappedMethod(absolutePath, srcPath, method) {
        const payload = {
            techSpecificInfo: method.techSpecificInfo,
            start: method.position,
            end: method.endPosition,
            name: method.displayName,
            identifierPos: method.identifierPosition,
            uniqueId: method.uniqueId,
            uniqueIdKey: method.uniqueIdKey,
            srcPath
        };
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.ADD_MAPPED_METHOD, payload);
    }
    filePathFixed(absolutePath, logicalPath) {
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.FILE_PATH_FIXED, {
            logicalPath
        });
    }
    methodUniqueIdFixed(absolutePath, methodUniqueIdKey, methodUniqueId) {
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.METHOD_UNIQUE_ID_FIXED, {
            methodUniqueIdKey,
            methodUniqueId,
        });
    }
    fileWithSourceMapConsumer(absolutePath, sourceMapConsumer) {
        sourceMapConsumer.eachMapping(m => {
            this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.SOURCEMAP_CONSUMER, m);
        });
    }
    projectRootResolved(projectRoot, source) {
        const payload = {
            value: projectRoot,
            source
        };
        this.pushEvent(null, contracts_1.DiagnosticEventType.PROJECT_ROOT_RESOLVED, payload);
    }
    usedPlugins(absolutePath, plugins) {
        const payload = {
            plugins,
        };
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.USED_PLUGINS, payload);
    }
    missedPlugin(absolutePath, missedPlugin) {
        const payload = {
            missedPlugin,
        };
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.MISSED_PLUGIN, payload);
    }
    pluginAdded(absolutePath, addedPlugin) {
        const payload = {
            addedPlugin,
        };
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.ADDED_PLUGIN, payload);
    }
    skipEnrichment(absolutePath, reason) {
        const payload = {
            reason,
        };
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.ENRICHMENT_SKIPPED, payload);
    }
    generatedFileIgnored(absolutePath) {
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.GENERETED_FILE_IGNORED);
    }
    autoGeneratedMethod(absolutePath, uniqueId) {
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.AUTOGENERATED_METHOD, uniqueId);
    }
    methodEnriched(absolutePath, uniqueId) {
        this.pushEvent(absolutePath, contracts_1.DiagnosticEventType.METHOD_ENRICHED, uniqueId);
    }
    submitDiagnostic() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const blobId = 'build_scan_diagnostic_chunk_' + this.chunkNumber;
                const dataToSend = this.diagnosticEvents;
                this.diagnosticEvents = [];
                this.chunkNumber += 1;
                this.blobSubmitPromise = this.blobSubmitPromise.then(() => {
                    return this.backendProxy.submitBlobAsync(dataToSend, this.buildSessionId, blobId, 'diagnostics');
                });
                return this.blobSubmitPromise;
            }
            catch (error) {
                cockpit_notifier_1.CockpitNotifier.sendGenericMessage('Failed to send diagnostic events');
            }
        });
    }
}
exports.BuildScanDiagnosis = BuildScanDiagnosis;
class DryRunDiagnosis extends BuildScanDiagnosis {
    constructor() {
        super(...arguments);
        this.threshold = Infinity;
    }
    submitDiagnostic() {
        return __awaiter(this, void 0, void 0, function* () {
            const filenameInDryOutput = 'build-scan-diagnostic.json';
            (0, helper_methods_1.saveDataToFile)(filenameInDryOutput, this.diagnosticEvents);
        });
    }
}
exports.DryRunDiagnosis = DryRunDiagnosis;
//# sourceMappingURL=build-scan-diagnosis.js.map