var utils = require("../utils");
/**
 * Enrich generated data from signatures of source files (if found).
 * Currently enriching only method meta object and hasshes if method is async.
 * @param generatedSignature
 * @param sourceSignatures
 * @param logger
 * @constructor
 */
var CODE_ELEMENT_TYPES = {
    BRANCH: "branch",
    METHOD: "method"
};
function SourceDataEnricher(generatedSignature, sourceSignatures, logger) {
    this.generatedSignature = generatedSignature;
    this.sourceSignatures = sourceSignatures;
    this.logger = logger;
}
/**
 * Iterate over generated and source methods, find match by source position and enrich method data.
 */
SourceDataEnricher.prototype.enrichData = function () {
    var context = this;
    this.sourceSignatures.forEach(function (sourceSig) {
        if (!sourceSig) {
            context.logger.error("Source signature is undefined, skipping enrichment");
            return;
        }
        var sourcePositionMap = context.generatedSignature.sourcePositionMappers[sourceSig.absolutePath];
        context.enrichMethods(sourcePositionMap, sourceSig);
        context.enrichBranches(sourcePositionMap, sourceSig);
    });
};
SourceDataEnricher.prototype.enrichMethods = function (sourcePositionMap, sourceSig) {
    var context = this;
    var generatedMethodsArray = context.generatedSignature.methods;
    var sourceMethodsArray = sourceSig.methods;
    this.enrichProcedure(sourcePositionMap.getMethodsPosition(), sourceSig, generatedMethodsArray, sourceMethodsArray, sourcePositionMap, sourceSig.positionToMethod, CODE_ELEMENT_TYPES.METHOD);
};
SourceDataEnricher.prototype.enrichBranches = function (sourcePositionMap, sourceSig) {
    var context = this;
    var generatedBranchArray = context.generatedSignature.branches;
    var sourceBranchesArray = sourceSig.branches;
    this.enrichProcedure(sourcePositionMap.getBranchesPosition(), sourceSig, generatedBranchArray, sourceBranchesArray, sourcePositionMap, sourceSig.positionToBranchMap, CODE_ELEMENT_TYPES.BRANCH);
};
SourceDataEnricher.prototype.handleAutoGeneratedElement = function (elementType, position, sourceSig, generatedElement) {
    this.logger.info(`Couldn't find ${elementType} at position '${position}' in file '${sourceSig.absolutePath}', but it got generate as '${elementType}'.
        marked as auto generate code`);
    generatedElement.techSpecificInfo["autoGenerated"] = true;
};
SourceDataEnricher.prototype.enrichProcedure = function (srcPositionsArr, sourceSig, genElementsArr, srcElementsArr, srcPositionToGenElementIdx, srcPositionToSrcElementIdx, codeElementType) {
    var context = this;
    srcPositionsArr.forEach(function (srcPosition) {
        var generatedElement = getGeneratedElement(codeElementType, srcPositionToGenElementIdx, srcPosition, genElementsArr);
        var sourceElement = getSourceElement(srcPositionToSrcElementIdx, srcPosition, generatedElement, srcElementsArr);
        if (generatedElement == null) {
            context.logger.warn(`${codeElementType} with source position '${srcPosition}' in file '${ontext.generatedSignature.absolutePath}', is null`);
        }
        else if (sourceElement == null) {
            context.handleAutoGeneratedElement(codeElementType, srcPosition, sourceSig, generatedElement);
        }
        else if (codeElementType == CODE_ELEMENT_TYPES.METHOD) {
            updateMethodInfo(generatedElement, sourceElement);
        }
    });
};
function updateMethodInfo(generatedMethod, sourceMethod) {
    generatedMethod.meta = utils.cloneObject(sourceMethod.meta);
    generatedMethod.techSpecificInfo = utils.cloneObject(sourceMethod.techSpecificInfo);
    if (sourceMethod.techSpecificInfo.isAsync) {
        generatedMethod.srcData.hash = sourceMethod.generatedData.hash;
        generatedMethod.srcData.sigHash = sourceMethod.generatedData.sigHash;
    }
}
function getGeneratedElement(codeElementType, srcPositionToGenElementIdx, srcPosition, genElementsArr) {
    var getGenIdxMethod = codeElementType === CODE_ELEMENT_TYPES.METHOD ? srcPositionToGenElementIdx.getMethodIndex : srcPositionToGenElementIdx.getBranchIndex;
    var generatedElementIndex = getGenIdxMethod.call(srcPositionToGenElementIdx, srcPosition);
    var generatedElement = genElementsArr[generatedElementIndex];
    return generatedElement;
}
function getSourceElementIdx(srcPositionToSrcElementIdx, srcPosition, generatedElement) {
    return srcPositionToSrcElementIdx[srcPosition] != null ? srcPositionToSrcElementIdx[srcPosition] :
        srcPositionToSrcElementIdx[generatedElement.srcData.identifierPosition];
}
function getSourceElement(srcPositionToSrcElementIdx, srcPosition, generatedElement, srcElementsArr) {
    var sourceElementIndex = getSourceElementIdx(srcPositionToSrcElementIdx, srcPosition, generatedElement);
    return srcElementsArr[sourceElementIndex];
}
module.exports = SourceDataEnricher;
//# sourceMappingURL=source-data-enricher.js.map