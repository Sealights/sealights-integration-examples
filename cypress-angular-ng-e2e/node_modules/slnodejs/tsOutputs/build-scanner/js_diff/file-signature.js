// @ts-ignore
var traverse = require('ast-traverse');
var astUtils = require('sl-esprima-ast-utils');
var createNodeKey = require('./create-node-key').createNodeKey;
var AstNodeTypes = require("./ast-node-types");
var MethodSignature = require("./method-signature");
var BranchSignature = require("./branch-signature");
var globalMethodIndexer = require("./globalMethodIndexer");
var parseContentToAST = require("../ast-utils").parseContentToAST;
var toRelativePath = require("../utils").toRelativePath;
/**
 * Traverse the AST and handle specific node types.
 * Information about the Node Types can be found in: https://github.com/babel/babylon/blob/master/ast/spec.md
 * @param absolutePtah
 * @param relativePath
 * @param content
 * @param {*} sourceMaps
 * @param opts
 * @param scmFilesContainer
 * @param logger
 */
var FileSignature = function (absolutePtah, relativePath, content, sourceMaps, opts, scmFilesContainer, logger, diagnostic) {
    this.absolutePath = absolutePtah;
    this.relativePath = relativePath;
    this.methods = [];
    this.branches = [];
    this.content = content;
    this.sourceMaps = sourceMaps;
    this.opts = opts;
    this.scmFilesContainer = scmFilesContainer;
    this.hasSourceMaps = !!sourceMaps;
    this.logger = logger;
    this.diagnostic = diagnostic;
    this.positionToMethod = {};
    this.endPositionToMethod = {};
    this.positionToBranchMap = {};
    this.methodIndex = 0;
    this.branchIndex = 0;
};
FileSignature.prototype._createSignature = function () {
    this.prepareContent();
    var ast = parseContentToAST(this.content, this.opts, this.absolutePath, this.diagnostic);
    this.traverseAST(ast);
};
FileSignature.prototype.createDTO = function () {
    return {
        methods: this.methods,
        branches: this.branches,
        filename: this.relativePath,
        hasSourceMaps: this.hasSourceMaps
    };
};
FileSignature.prototype.traverseAST = function (ast) {
    var context = this;
    var nodeToParent = {};
    var activeMethodKey = null;
    var activeMethodIndex = null;
    traverse(ast, {
        pre: function (node, parentNode) {
            var key = createNodeKey(node);
            nodeToParent[key] = parentNode;
            if (AstNodeTypes.isMethodNode(node)) {
                // If there is no active method it means we are in global context.
                if (activeMethodKey == null) {
                    activeMethodKey = createNodeKey(node);
                }
                globalMethodIndexer.incrementIndex();
                /*
                    We set the active method index to point the current method index index.
                    This value sets the 'enclosingMethodIdx' in branches.
                 */
                activeMethodIndex = globalMethodIndexer.getCurrentIndex();
                context.addMethod(node, parentNode, nodeToParent);
                context.addDefaultParameterBranch(node.params, parentNode, activeMethodIndex);
            }
            else if (context.opts.isBranchCoverage && AstNodeTypes.isBranchNode(node)) {
                context.addBranch(node, parentNode, activeMethodKey == null, activeMethodIndex);
            }
        },
        post: function (node) {
            if (AstNodeTypes.isMethodNode(node)) {
                // If we are quiting method which is active, its mean we are in global context.
                if (activeMethodKey === createNodeKey(node)) {
                    activeMethodKey = null;
                }
                /*
                    If a function contains branch after method, then the 'activeMethodIndex' will contains the index of
                    the inner method while the branch belongs to the parent method.
                    Here we decreasing the index after each method so the 'enclosingMethodIdx' of the branch will point to parent.
                 */
                activeMethodIndex--;
            }
        }
    });
};
FileSignature.prototype.addMethod = function (node, parentNode, nodeToParent) {
    var method = MethodSignature.create(node, parentNode, nodeToParent, this.absolutePath, this.relativePath, this.logger, this.opts.allowAccessibilityAdjustment);
    method.srcData = method.generatedData; // seems useless due to same action in build-scanner\js_diff\method-signature.js:43
    let dto = method.createDTO();
    dto.uniqueIdKey = toRelativePath(dto.uniqueIdKey, this.opts.useRelativeSlMapping, this.opts.workspacepath);
    this.methods.push(dto);
    this.endPositionToMethod[method.generatedData.endPosition] = this.methodIndex;
    method.generatedData.possiblePos.forEach(x => {
        const startPosition = x.position.join(',');
        this.positionToMethod[startPosition] = this.methodIndex;
    });
    if (method.generatedData.identifierPosition) {
        this.positionToMethod[method.generatedData.identifierPosition] = this.methodIndex;
    }
    this.methodIndex++;
};
FileSignature.prototype.addBranch = function (node, parentNode, isGlobalBranch, activeMethodIndex) {
    var context = this;
    var branches = [];
    if (node.type !== AstNodeTypes.LogicalExpression) {
        branches = branches.concat(this.getBranchesToAdd(node, isGlobalBranch, activeMethodIndex));
    }
    // If this node its not logical exp inside logical exp.
    if (node.type == AstNodeTypes.LogicalExpression && (parentNode == undefined || parentNode.type !== AstNodeTypes.LogicalExpression)) {
        branches = branches.concat(this.getBranchesToAdd(node, isGlobalBranch, activeMethodIndex));
    }
    branches.forEach(function (branch) {
        branch.srcData = branch.generatedData;
        let dto = branch.createDTO();
        dto.uniqueIdKey = toRelativePath(dto.uniqueIdKey, context.opts.useRelativeSlMapping, context.opts.workspacepath);
        context.branches.push(dto);
        context.positionToBranchMap[branch.generatedData.position + '|' + branch.index] = context.branchIndex;
        context.positionToBranchMap[branch.generatedData.parentPosition + '|' + branch.index] = context.branchIndex;
        context.branchIndex++;
    });
};
FileSignature.prototype.prepareContent = function () {
    this.content = trimShebang(this.content);
};
FileSignature.prototype.getBranchesToAdd = function (node, isGlobalBranch, activeMethodIndex) {
    var branchesToAdd = [];
    var context = this;
    var nodeKey = createNodeKey(node);
    switch (node.type) {
        // Those types contains some kind of "if else" structure.
        case AstNodeTypes.IfStatement:
        case AstNodeTypes.ConditionalExpression:
            var branchIndex = 0;
            // consequent mean when condition equals true.
            if (node.consequent !== null) {
                var branch = BranchSignature.create(node.consequent, node, node.type, branchIndex++, this.absolutePath, this.relativePath, isGlobalBranch, activeMethodIndex, this.logger);
                branchesToAdd.push(branch);
            }
            // altrnate equivalent to "else".
            var clonedNode = null;
            if (node.alternate == null) {
                clonedNode = createEmptyAlternate(node);
            }
            var nodeToAdd = clonedNode || node;
            var branch = BranchSignature.create(nodeToAdd.alternate, nodeToAdd, node.type, branchIndex++, this.absolutePath, this.relativePath, isGlobalBranch, activeMethodIndex, this.logger);
            branchesToAdd.push(branch);
            break;
        case AstNodeTypes.SwitchStatement:
            var branchIndex = 0;
            // Create branch from each case statement.
            node.cases.forEach(function (caseNode) {
                if (caseNode !== null) {
                    var branch = BranchSignature.create(caseNode, node, node.type, branchIndex++, context.absolutePath, context.relativePath, isGlobalBranch, activeMethodIndex, context.logger);
                    branchesToAdd.push(branch);
                }
            });
            break;
        case AstNodeTypes.LogicalExpression:
            var branchIndex = 0;
            var leaves = [];
            findLogicalExpressionLeaves(node, leaves);
            leaves.forEach(function (leafNode) {
                if (leafNode !== null) {
                    var branch = BranchSignature.create(leafNode, node, node.type, branchIndex++, context.absolutePath, context.relativePath, isGlobalBranch, activeMethodIndex, context.logger);
                    branchesToAdd.push(branch);
                }
            });
            break;
        case AstNodeTypes.AssignmentPattern:
            /*
                In babel es6 default arg is resolves with type 'AssignmentPattern' anf istanbul reports
                a branch with the location of the default value.
                For example: (a=2) => {console.log(a)} will be reported with branch on location of '2'
             */
            var branchIndex = 0;
            var branch = BranchSignature.create(node.right, node, AstNodeTypes.DefaultArgument, branchIndex++, this.absolutePath, this.relativePath, isGlobalBranch, activeMethodIndex, this.logger);
            branchesToAdd.push(branch);
            break;
    }
    return branchesToAdd;
};
FileSignature.prototype.addDefaultParameterBranch = function (functionParams, parentNode, activeMethodIndex) {
    var context = this;
    functionParams = functionParams || [];
    functionParams.forEach(function (param) {
        if (param.type === AstNodeTypes.AssignmentPattern) {
            context.addBranch(param, parentNode, true, activeMethodIndex);
        }
    });
};
FileSignature.create = function (absolutePtah, relativePath, content, sourceMaps, opts, scmFilesContainer, logger, diagnosticCollector) {
    var signature = new this(absolutePtah, relativePath, content, sourceMaps, opts, scmFilesContainer, logger, diagnosticCollector);
    signature._createSignature();
    return signature;
};
// Brake the expression to pieces (every "or" will be different branch).
function findLogicalExpressionLeaves(node, leaves) {
    if (node.type === AstNodeTypes.LogicalExpression) {
        findLogicalExpressionLeaves(node.left, leaves);
        findLogicalExpressionLeaves(node.right, leaves);
    }
    else {
        leaves.push(node);
    }
}
/**
 * Taken from eslint - https://github.com/eslint/eslint/blob/183def6115cad6f17c82ef1c1a245eb22d0bee83/lib/eslint.js#L800
 */
function trimShebang(text) {
    return text.replace(/^#!([^\r\n]+)/, function (match, captured) {
        return "//" + captured;
    });
}
/**
 * When we have inner method we set it to empty block statement, because we want to calculate the hash and diff
 * for outer method only.
 * @param {*} methodNode
 */
function _createEmptyBlock() {
    return {
        type: AstNodeTypes.BlockStatement,
        body: []
    };
}
function createEmptyAlternate(node) {
    // Istanbul counts empty alternates and takes the consequent's location
    var clonedNode = astUtils.clone(node);
    clonedNode.alternate = _createEmptyBlock();
    // Set alternate location to consequent location (same as istanbul).
    clonedNode.alternate.loc = node.consequent !== null ? node.consequent.loc : node.loc;
    return clonedNode;
}
module.exports = FileSignature;
//# sourceMappingURL=file-signature.js.map