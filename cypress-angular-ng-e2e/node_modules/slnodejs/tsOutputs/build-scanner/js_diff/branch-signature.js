var astUtils = require('sl-esprima-ast-utils');
var md5 = require('md5');
var babelGenerator = require("@babel/generator");
var traverse = require('ast-traverse');
var AstNodeTypes = require("./ast-node-types");
var utils = require("../utils");
/**
 * Creates branch object from node received from ast
 * @param node
 * @param parentNode
 * @param type
 * @param index
 * @param absolutePath
 * @param relativePath
 * @param logger
 * @constructor
 */
var METHOD_INDEX_FOR_GLOBAL_BRANCHES = -1;
function BranchSignature(node, parentNode, type, index, absolutePath, relativePath, isGlobalBranch, activeMethodIndex, logger) {
    this.node = node;
    this.parentNode = parentNode;
    this.index = index;
    this.isGlobalBranch = isGlobalBranch;
    this.activeMethodIndex = activeMethodIndex;
    this.logger = logger;
    this.generatedData = new BranchData(absolutePath, relativePath);
    this.srcData = new BranchData();
    this.type = type;
    this.shouldSkip = false;
    this.techSpecificInfo = {};
    this.hasSourceData = false;
}
BranchSignature.prototype._createSignature = function () {
    this.generatedData.position = formatLocationToArray(this.node.loc.start);
    this.generatedData.endPosition = formatLocationToArray(this.node.loc.end);
    this.generatedData.hash = this.calculateHash();
    var parentPosition = this.resolveParentPosition();
    this.generatedData.parentPosition = formatLocationToArray(parentPosition);
    this.srcData = utils.cloneObject(this.generatedData, this.logger);
    this.enclosingMethodIdx = this.getEnclosingMethodIdx();
};
BranchSignature.prototype.calculateHash = function () {
    var clonedNode = astUtils.clone(this.node);
    // Visit node in pre order and calculate body hash.
    traverse(clonedNode, {
        pre: function (node) {
            // If current node is the root node given return (we want to calculate the body hash only).
            if (node == clonedNode)
                return;
            if (AstNodeTypes.isMethodNode(node)) {
                emptyMethodNode(node);
            }
            emptyBranchNode(node);
        }
    });
    var generatedCode = this.generateCodeFromAST(clonedNode);
    return md5(generatedCode);
};
BranchSignature.prototype.generateCodeFromAST = function (node) {
    return babelGenerator.default(node, {
        comments: false
    }, '').code;
};
//In case of AstNodeTypes.IfStatement Istanbul reports in runtime on the location of the parent node.
BranchSignature.prototype.resolveParentPosition = function () {
    if (this.type === AstNodeTypes.IfStatement) {
        return this.parentNode.loc.start;
    }
    else {
        return this.node.loc.start;
    }
};
BranchSignature.prototype.createUniqueId = function () {
    var relevantData = this.hasSourceData ? this.srcData : this.generatedData;
    return [relevantData.relativeFilename, relevantData.parentPosition.join(','), this.index].join('|');
};
BranchSignature.prototype.createUniqueIdKeyForSlMapping = function () {
    return [this.generatedData.absoluteFilename, this.generatedData.parentPosition.join(","), this.index].join('|');
};
// Returns the global index of containing folder, its a global branch returns -1
BranchSignature.prototype.getEnclosingMethodIdx = function () {
    if (!this.isGlobalBranch) {
        return this.activeMethodIndex;
    }
    return METHOD_INDEX_FOR_GLOBAL_BRANCHES;
};
BranchSignature.prototype.createDTO = function () {
    return {
        index: this.index,
        type: this.type,
        srcData: this.srcData,
        generatedData: this.generatedData,
        uniqueId: this.createUniqueId(),
        enclosingMethodIdx: this.enclosingMethodIdx,
        techSpecificInfo: this.techSpecificInfo,
        uniqueIdKey: this.createUniqueIdKeyForSlMapping()
    };
};
BranchSignature.create = function (node, parentNode, type, index, absolutePath, relativePath, isGlobalBranch, activeMethodIndex, logger) {
    var signature = new this(node, parentNode, type, index, absolutePath, relativePath, isGlobalBranch, activeMethodIndex, logger);
    signature._createSignature();
    return signature;
};
function formatLocationToArray(loc) {
    return [loc.line, loc.column];
}
function BranchData(absolutePath, relativePath) {
    this.position = null;
    this.endPosition = null;
    this.hash = null;
    this.parentPosition = null;
    this.relativeFilename = relativePath;
    this.absoluteFilename = absolutePath;
}
function emptyMethodNode(node) {
    node.body = {
        type: AstNodeTypes.BlockStatement,
        body: []
    };
    node.params = [];
    node.id = {
        name: '_',
        type: AstNodeTypes.Identifier
    };
}
;
function emptyBranchNode(node) {
    switch (node.type) {
        case AstNodeTypes.IfStatement:
        case AstNodeTypes.ConditionalExpression:
            node.consequent = createEmptyBlock();
            node.alternate = createEmptyBlock();
            break;
        case AstNodeTypes.SwitchStatement:
            node.cases = [];
            break;
        case AstNodeTypes.LogicalExpression:
            node.operator = "";
            node.left = {
                type: AstNodeTypes.StringLiteral,
                value: null
            };
            node.right = {
                type: AstNodeTypes.StringLiteral,
                value: null
            };
            break;
    }
}
function createEmptyBlock() {
    return {
        type: AstNodeTypes.BlockStatement,
        body: []
    };
}
module.exports = BranchSignature;
//# sourceMappingURL=branch-signature.js.map