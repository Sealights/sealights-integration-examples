"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPossibleMethodLocations = void 0;
const create_node_key_1 = require("./create-node-key");
const AstNodeTypes = require("./ast-node-types.js");
const sl_env_vars_1 = require("../../common/constants/sl-env-vars");
/**
 * When working in React, components are being generated by the "_createClass" method of the framework.
 * As a result, we have an issue when we try to map it back to source maps.
 * The method make sure to verify if a component is a React component by going through the parent nodes
 * fpr a specific node, and verifying that they have the same pattern as the expected code.
 *
 * React Code
 * ================== START CODE ============
 *  import React, { Component } from 'react';
 *  import logo from './logo.svg';
 *  import './App.css';
 *
 *  class App extends Component {
 *     someFunc(){
 *         console.log("hezi func")
 *     }
 *  }
 *
 *  export default App;
 *  ================== END CODE ============
 *
 * This code generates the following code
 *  ================== START CODE ============
 *  _createClass(App, [{
 *     key: 'someFunc',
 *     value: function someFunc() {
 *         console.log("Some func is invoked");
 *     }
 * }]);
 *  ================== END CODE ============
 *
 * So basically  we are searching for the "value" node, the array which contains it and the "_createClass" method.
 *
 * @deprecated - this logic acceptable only to specific usage of react in class style and don't cover functional style.
 */
function isReact(node, nodeToParent) {
    if (node.type != 'FunctionExpression')
        return false;
    let key = (0, create_node_key_1.createNodeKey)(node);
    const valueNode = nodeToParent[key];
    if (valueNode == null)
        return false;
    if (valueNode.key == null || (valueNode.key != null && valueNode.key.name != 'value'))
        return false; //That's note the 'value' node. Return.
    key = (0, create_node_key_1.createNodeKey)(valueNode);
    const parent = nodeToParent[key];
    if (parent == null)
        return false;
    key = (0, create_node_key_1.createNodeKey)(parent);
    const arrayNode = nodeToParent[key];
    if (arrayNode == null || arrayNode.type != 'ArrayExpression')
        return false;
    key = (0, create_node_key_1.createNodeKey)(arrayNode);
    const createClassNode = nodeToParent[key];
    if (createClassNode == null || createClassNode.callee == null) {
        return false;
    }
    const result = createClassNode.callee.name == '_createClass';
    return result;
}
var PositionSourceType;
(function (PositionSourceType) {
    PositionSourceType[PositionSourceType["REACT_COMPONENT"] = 50] = "REACT_COMPONENT";
    PositionSourceType[PositionSourceType["ID_LOCATION"] = 40] = "ID_LOCATION";
    PositionSourceType[PositionSourceType["EXPORTED_FUNCTION"] = 30] = "EXPORTED_FUNCTION";
    PositionSourceType[PositionSourceType["ACCESSIBILITY_ADJUSTMENT"] = 31] = "ACCESSIBILITY_ADJUSTMENT";
    PositionSourceType[PositionSourceType["REGULAR_LOCATION"] = 20] = "REGULAR_LOCATION";
})(PositionSourceType || (PositionSourceType = {}));
class PossibleLocation {
    constructor(position, source) {
        this.position = position;
        this.source = source;
    }
    static fromAstLocation(astLocation, source) {
        const position = [
            astLocation.start.line,
            astLocation.start.column,
        ];
        return new PossibleLocation(position, source);
    }
}
/**
 * Get a list of possible method locations with priority for each item
 */
function getPossibleMethodLocations(node, nodeToParent, allowAccessibilityAdjustment = false) {
    var _a;
    const possibleLocations = [];
    if (node.type == AstNodeTypes.FunctionExpression && isReact(node, nodeToParent)) {
        const possibleLocation = PossibleLocation.fromAstLocation(node.body.loc, PositionSourceType.REACT_COMPONENT);
        possibleLocations.push(possibleLocation);
    }
    /**
     * According to this link, Istanbul uses the "node.id.loc" for FunctionDeclaration and FunctionExpression.
     * https://github.com/istanbuljs/istanbuljs/blob/cbd1c1473da0dc34051c332170544529d59eda03/packages/istanbul-lib-instrument/src/visitor.js#L216
     */
    if (!sl_env_vars_1.SlEnvVars.isUseIstanbul() && shouldUseLocFromID(node) && ((_a = node.id) === null || _a === void 0 ? void 0 : _a.loc)) {
        const location = node.id.loc;
        const possibleLocation = PossibleLocation.fromAstLocation(location, PositionSourceType.ID_LOCATION);
        possibleLocations.push(possibleLocation);
    }
    /**
     * In typescript, in case of below code, diferrent location recieved from source maps and babel parser.
     * export function foo(){
     *
     * }
     * Source maps: column 0
     * Babel parser: cloumn 7 (the 'function' woord.
     * Here we fix the location to be column 0 (export statement location)
     */
    if (node.type === AstNodeTypes.FunctionDeclaration) {
        const key = (0, create_node_key_1.createNodeKey)(node);
        const parentNode = nodeToParent[key];
        if (parentNode.type == AstNodeTypes.ExportDefaultDeclaration || parentNode.type == AstNodeTypes.ExportNamedDeclaration) {
            const possibleLocation = PossibleLocation.fromAstLocation(parentNode.loc, PositionSourceType.EXPORTED_FUNCTION);
            possibleLocations.push(possibleLocation);
        }
    }
    /**
     * In typescript, in case of below code, diferrent location recieved from source maps and babel parser for method reportMetric.
     * class DoNothing {
     *   reportSomething() {
     *     this.reportMetric('something');
     *   }
     *   private reportMetric(metric: string): void {
     *     console.log(metric);
     *   }
     * }
     * Source maps: column 2
     * Babel parser: column 10 (the 'private ' word)
     * Here we take location adjusted to accessibility keyword
     */
    if (allowAccessibilityAdjustment && node.type === AstNodeTypes.ClassMethod && node.accessibility) {
        const possibleLocation = PossibleLocation.fromAstLocation(node.loc, PositionSourceType.ACCESSIBILITY_ADJUSTMENT);
        possibleLocation.position[1] += node.accessibility.length + 1;
        possibleLocations.push(possibleLocation);
    }
    const possibleLocation = PossibleLocation.fromAstLocation(node.loc, PositionSourceType.REGULAR_LOCATION);
    possibleLocations.push(possibleLocation);
    possibleLocations.sort((a, b) => b.source - a.source);
    return possibleLocations;
}
exports.getPossibleMethodLocations = getPossibleMethodLocations;
function shouldUseLocFromID(node) {
    return node.type === AstNodeTypes.FunctionDeclaration || node.type === AstNodeTypes.FunctionExpression;
}
//# sourceMappingURL=guess-method-location.js.map