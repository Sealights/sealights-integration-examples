var getPossibleMethodLocations = require('./guess-method-location').getPossibleMethodLocations;
var guessMethodName = require('./guess-method-name').guessMethodName;
var astUtils = require('sl-esprima-ast-utils');
var md5 = require('md5');
var babelGenerator = require("@babel/generator");
var traverse = require('ast-traverse');
var AstNodeTypes = require("./ast-node-types");
var utils = require("../utils");
var globalMethodIndexer = require("./globalMethodIndexer");
function MethodData(absolutePath, relativePath) {
    this.possiblePos = [];
    this.position = null;
    this.endPosition = null;
    this.displayName = null;
    this.hash = null;
    this.sigHash = null;
    this.relativeFilename = relativePath;
    this.absoluteFilename = absolutePath;
    this.identifierPosition = null;
}
Object.defineProperty(MethodData.prototype, 'position', {
    enumerable: true,
    get: function position() {
        if (this.possiblePos.length) {
            return this.possiblePos[0].position;
        }
        return null;
    }
});
/**
 * Crates method object from node recived from ast
 * @constructor
 */
function MethodSignature(node, parentNode, nodeToParent, absolutePath, relativePath, logger, allowAccessibilityAdjustment) {
    this.node = node;
    this.parentNode = parentNode;
    this.nodeToParent = nodeToParent;
    this.logger = logger;
    this.allowAccessibilityAdjustment = allowAccessibilityAdjustment;
    this.generatedData = new MethodData(absolutePath, relativePath);
    this.srcData = new MethodData();
    this.meta = {};
    this.type = null;
    this.shouldSkip = false;
    this.hasSourceData = false;
    this.techSpecificInfo = this.createTechSpecificInfoInterface();
    this.idxInMapping = globalMethodIndexer.getCurrentIndex();
}
MethodSignature.prototype._createSignature = function () {
    const nameObject = guessMethodName(this.node, this.parentNode);
    this.type = nameObject.type;
    this.generatedData.possiblePos = getPossibleMethodLocations(this.node, this.nodeToParent, this.allowAccessibilityAdjustment);
    this.generatedData.endPosition = MethodSignature.formatLocationToArray(this.node.loc.end);
    this.generatedData.identifierPosition = this.getIdentifierPosition();
    this.generatedData.hash = this.calculateHash();
    this.generatedData.sigHash = this.calculateSigHash();
    this.generatedData.displayName = nameObject.name;
    this.generatedData.accessibility = this.node.accessibility || null;
    this.meta.anonymous = nameObject.isAnonymous;
    this.meta.identifierPosition = this.getIdentifierPosition();
    this.techSpecificInfo.isAnonymous = nameObject.isAnonymous;
    this.srcData = utils.cloneObject(this.generatedData, this.logger);
};
MethodSignature.prototype.calculateHash = function () {
    var context = this;
    var clonedNode = astUtils.clone(this.node);
    // Visit node in pre order and calculate body hash.
    traverse(clonedNode, {
        pre: function (node) {
            // If current node is the root node given return (we want to calculate the body hash only).
            if (node == clonedNode)
                return;
            if (AstNodeTypes.isMethodNode(node)) {
                context.emptyNode(node);
            }
        }
    });
    var generatedCode = this.generateCodeFromAST(clonedNode);
    return md5(generatedCode);
};
MethodSignature.prototype.calculateSigHash = function () {
    var context = this;
    if (!this.node.params || this.node.params.length == 0) {
        return "";
    }
    var paramsStr = this.node.params.map(function (param) {
        return context.generateCodeFromAST(param);
    }).join(',');
    return md5(paramsStr);
};
MethodSignature.prototype.emptyNode = function (node) {
    node.body = {
        type: AstNodeTypes.BlockStatement,
        body: []
    };
    node.params = [];
    node.id = {
        name: '_',
        type: AstNodeTypes.Identifier
    };
};
MethodSignature.prototype.generateCodeFromAST = function (node) {
    return babelGenerator.default(node, {
        comments: false
    }, '').code;
};
MethodSignature.prototype.createTechSpecificInfoInterface = function () {
    return {
        isAsync: this.node.async || false,
        isComputed: this.node.computed || false,
        isExpression: this.node.expression || false,
        isGenerator: this.node.generator || false,
        kind: this.node.kind,
        isStatic: this.node.static || false,
        isDecorated: this.node.decorators && this.node.decorators.length > 0
    };
};
MethodSignature.prototype.createUniqueId = function () {
    const relevantData = this.hasSourceData ? this.srcData : this.generatedData;
    const position = [...relevantData.position];
    return [relevantData.relativeFilename, position.join(',')].join('@');
};
MethodSignature.prototype.getAccessibility = function () {
    const relevantData = this.hasSourceData ? this.srcData : this.generatedData;
    return (relevantData.accessibility ? { accessibility: relevantData.accessibility } : {});
};
MethodSignature.prototype.createUniqueIdKeyForSlMapping = function () {
    return [this.generatedData.absoluteFilename, this.generatedData.position.join(",")].join('@');
};
MethodSignature.prototype.createDTO = function () {
    return Object.assign({ meta: this.meta, techSpecificInfo: this.techSpecificInfo, type: this.type, srcData: this.srcData, generatedData: this.generatedData, uniqueId: this.createUniqueId(), idxInMapping: this.idxInMapping, uniqueIdKey: this.createUniqueIdKeyForSlMapping() }, this.getAccessibility());
};
MethodSignature.create = function (node, parentNode, nodeToParent, absolutePath, relativePath, logger, allowAccessibilityAdjustment) {
    var signature = new this(node, parentNode, nodeToParent, absolutePath, relativePath, logger, allowAccessibilityAdjustment);
    signature._createSignature();
    return signature;
};
MethodSignature.formatLocationToArray = function (loc) {
    return [loc.line, loc.column];
};
MethodSignature.prototype.getIdentifierPosition = function () {
    var identifier = this.node.id || this.node.key;
    var position = identifier && (identifier.position || identifier.loc);
    if (identifier && position && position.end) {
        return MethodSignature.formatLocationToArray(position.end);
    }
    return [];
};
module.exports = MethodSignature;
//# sourceMappingURL=method-signature.js.map