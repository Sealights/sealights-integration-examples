// TODO: File not in use
var util = require("util");
var FileSignature = require("./file-signature");
var AstNodeTypes = require("./ast-node-types");
var MethodSignature = require("./method-signature");
var SourceMapHandler = require("../../common/source-map-handler").SourceMapHandler;
var globalMethodIndexer = require("./globalMethodIndexer");
var SourcePositionMapper = require("./source-position-mapper");
/**
 * Create signature for generated files (if source maps exists), inherits from file-signature.
 * Adding of branches and methods is by source data.
 * @constructor
 */
function GeneratedFileSignature() {
    FileSignature.apply(this, arguments);
    this.sourcePositionMappers = {};
    this.hasColumnInfo = false;
}
util.inherits(GeneratedFileSignature, FileSignature);
GeneratedFileSignature.prototype.addMethod = function (node, parentNode, nodeToParent) {
    var method = MethodSignature.create(node, parentNode, nodeToParent, this.absolutePath, this.relativePath, this.logger);
    var sourceMapData = this.getSourceMapData(method.generatedData.position, method.generatedData.endPosition);
    if (!sourceMapData) {
        this.logger.debug(`Method in file '${this.absolutePath}' at position '${method.generatedData.position}' is auto generated and ignored`);
        globalMethodIndexer.setIgnoredMethod(method.idxInMapping);
        return;
    }
    this.setHasColumnInfo(sourceMapData.position);
    method.srcData.position = formatLocationToArray(sourceMapData.position);
    method.srcData.endPosition = formatLocationToArray(sourceMapData.endPosition);
    method.srcData.absoluteFilename = sourceMapData.absolutePath;
    method.srcData.relativeFilename = sourceMapData.relativePath;
    method.srcData.displayName = sourceMapData.displayName || method.generatedData.displayName;
    var identifierSourcePosition;
    if (method.generatedData.identifierPosition) {
        identifierSourcePosition = this.sourceMaps.originalPositionFor(formatArrayToLocation(method.generatedData.identifierPosition));
        method.srcData.identifierPosition = formatLocationToArray(identifierSourcePosition);
    }
    method.hasSourceData = true;
    var absoluteSourcePath = method.srcData.absoluteFilename;
    var sourcePosition = method.srcData.position;
    this.mapToSourceElement(absoluteSourcePath, sourcePosition, this.methodIndex, false);
    this.methods.push(method.createDTO());
    this.methodIndex++;
};
GeneratedFileSignature.prototype.addBranch = function (node, parentNode, isGlobalBranch, activeMethodIndex) {
    var context = this;
    var branches = [];
    if (node.type !== AstNodeTypes.LogicalExpression) {
        branches = branches.concat(this.getBranchesToAdd(node, isGlobalBranch, activeMethodIndex));
    }
    // If this node its not logical exp inside logical exp.
    if (node.type == AstNodeTypes.LogicalExpression && (parentNode == undefined || parentNode.type !== AstNodeTypes.LogicalExpression)) {
        branches = branches.concat(this.getBranchesToAdd(node, isGlobalBranch, activeMethodIndex));
    }
    branches.forEach(function (branch) {
        var sourceMapData = context.getSourceMapData(branch.generatedData.position, branch.generatedData.endPosition);
        if (!sourceMapData) {
            context.logger.debug(`Branch in file '${context.absolutePath}' at position '${branch.generatedData.position}' is auto generated and ignored`);
            return;
        }
        context.setHasColumnInfo(sourceMapData.position);
        var parentPosition = context.sourceMaps.originalPositionFor(branch.resolveParentPosition());
        branch.srcData.position = formatLocationToArray(sourceMapData.position);
        branch.srcData.endPosition = formatLocationToArray(sourceMapData.endPosition);
        branch.srcData.parentPosition = formatLocationToArray(parentPosition);
        branch.srcData.absoluteFilename = sourceMapData.absolutePath;
        branch.srcData.relativeFilename = sourceMapData.relativePath;
        if (context.isBranchInsideGeneratedMethod(branch.srcData)) {
            return;
        }
        var absoluteSourcePath = branch.srcData.absoluteFilename;
        var sourcePosition = branch.srcData.position;
        context.mapToSourceElement(absoluteSourcePath, sourcePosition, context.branchIndex, true);
        branch.hasSourceData = true;
        context.branches.push(branch.createDTO());
        context.branchIndex++;
    });
};
GeneratedFileSignature.prototype.mapToSourceElement = function (absoluteSourcePath, sourcePosition, index, isBranch) {
    this.sourcePositionMappers[absoluteSourcePath] = this.sourcePositionMappers[absoluteSourcePath] || new SourcePositionMapper(absoluteSourcePath);
    if (isBranch) {
        this.sourcePositionMappers[absoluteSourcePath].addBranch(sourcePosition, index);
    }
    else {
        this.sourcePositionMappers[absoluteSourcePath].addMethod(sourcePosition, index);
    }
};
GeneratedFileSignature.prototype.getSourceMapData = function (position, endPosition) {
    try {
        var handler = new SourceMapHandler(this.sourceMaps, this.absolutePath, position, endPosition, this.opts.projectRoot, this.logger);
        handler.setScmParams(this.scmFilesContainer, this.opts.scmRootDir);
        handler.resolvePaths();
        if (!handler.shouldSkipped) {
            return {
                position: handler.start,
                endPosition: handler.end,
                absolutePath: handler.absolutePath,
                relativePath: handler.relativePath,
                displayName: handler.originalName
            };
        }
        else {
            return null;
        }
    }
    catch (e) {
        this.logger.error('Error calculating source maps:' + e);
        return null;
    }
};
GeneratedFileSignature.prototype.isBranchInsideGeneratedMethod = function (srcData) {
    if (srcData && srcData.parentPosition && srcData.parentPosition[0] == null && srcData.parentPosition[1] == null) {
        this.logger.info(`Branch in file '${srcData.absoluteFilename}' at position '${srcData.position}', has no parent position. seems to be inside generator or async method, skipped`);
        return true;
    }
    return false;
};
GeneratedFileSignature.prototype.getSourceFilesPath = function () {
    return Object.keys(this.sourcePositionMappers);
};
GeneratedFileSignature.prototype.setHasColumnInfo = function (position) {
    /*
    * In case of source-maps without column info column value can be either o or null
    * See https://www.npmjs.com/package/source-map#sourcemapconsumerprototypeoriginalpositionforgeneratedposition
    */
    if (!(this.hasColumnInfo) && position.column) {
        this.hasColumnInfo = true;
    }
};
GeneratedFileSignature.create = function (absolutePtah, relativePath, content, sourceMaps, opts, scmFilesContainer, logger) {
    var signature = new this(absolutePtah, relativePath, content, sourceMaps, opts, scmFilesContainer, logger);
    signature._createSignature();
    return signature;
};
function formatLocationToArray(loc) {
    return [loc.line, loc.column];
}
function formatArrayToLocation(arr) {
    return { line: arr[0], column: arr[1] };
}
module.exports = GeneratedFileSignature;
//# sourceMappingURL=generated-file-signature.js.map