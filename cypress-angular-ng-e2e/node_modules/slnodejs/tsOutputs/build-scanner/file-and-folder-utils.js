var path = require('path');
var fs = require('fs');
var fileset = require('fileset');
var READ_FILE_CHUNK_SIZE = 64 * 1024;
var RELATIVE_PATH_SIGN = "../";
var seq = 0;
function filesFor(options, callback) {
    if (!callback && typeof options === 'function') {
        callback = options;
        options = null;
    }
    options = options || {};
    var root = options.root, includes = options.includes, excludes = options.excludes, realpath = options.realpath, relative = options.relative, opts;
    root = root || process.cwd();
    includes = includes && Array.isArray(includes) ? includes : ['**/*.js'];
    excludes = excludes && Array.isArray(excludes) ? excludes : ['**/node_modules/**'];
    opts = { cwd: root, nodir: true };
    seq += 1;
    opts['x' + seq + new Date().getTime()] = true; //cache buster for minimatch cache bug
    fileset(includes.join(' '), excludes.join(' '), opts, function (err, files) {
        if (err) {
            return callback(err);
        }
        if (relative) {
            return callback(err, files);
        }
        if (!realpath) {
            files = files.map(function (file) { return path.resolve(root, file); });
            return callback(err, files);
        }
        var realPathCache = module.constructor._realpathCache || {};
        async.map(files, function (file, done) {
            fs.realpath(path.resolve(root, file), realPathCache, done);
        }, callback);
    });
}
module.exports = {
    //This method search for file recursively from given folder and up.
    findFileRecursively: function (filename, workspacePath, lookInParentFolders, logger) {
        var searchedPaths = {};
        do {
            var filePath = path.resolve(workspacePath, filename);
            // Already searched at
            if (searchedPaths[filePath])
                return null;
            logger.debug(`Looking for '${filename}' at '${path.normalize(workspacePath)}'`);
            // Mark current path as visited.
            searchedPaths[filePath] = true;
            try {
                // Check if file exist and not directory
                var f = fs.statSync(filePath);
                if (f.isFile()) {
                    logger.debug(`found file: '${filename}' in:${path.normalize(workspacePath)}'`);
                    return filePath;
                }
                else {
                    workspacePath = levelUp(workspacePath, filename, logger);
                }
            }
            catch (e) {
                workspacePath = levelUp(workspacePath, filename, logger);
            }
            if (!lookInParentFolders) {
                logger.debug("should not search in parent directories, breaking out.");
                break;
            }
        } while (workspacePath.length > 1);
        logger.info(filename + ' not found');
        return null;
    },
    copyFileAsIs: function (inputFile, outputFile, name, logger, callback) {
        logger.info("Copying file '" + name + "' as is.");
        // non JavaScript file, copy it as is
        var readStream = fs.createReadStream(inputFile, {
            'bufferSize': READ_FILE_CHUNK_SIZE
        });
        var writeStream = fs.createWriteStream(outputFile);
        readStream.on('error', callback);
        writeStream.on('error', callback);
        readStream.pipe(writeStream);
        var _this = this;
        readStream.on('end', function () {
            logger.debug("Finished copying '" + name + "'.");
            callback(null, name);
        });
    },
    copyDir: function (from, to, ignoredRelFiles, callback, onFileCopied, onFileError) {
        var _this = this;
        var processedFilesLookup = {};
        ignoredRelFiles.forEach(function (f) {
            processedFilesLookup[f] = true;
        });
        var existingDirsLookup = {};
        filesFor({
            root: from,
            includes: ['**/*'],
            excludes: [],
            relative: true
        }, function (err, files) {
            if (err) {
                return callback(err);
            }
            var copyErrors = [];
            files.forEach(function (relFile) {
                if (processedFilesLookup[relFile])
                    return; //already processed/instrumented this earlier
                try {
                    inputFile = path.resolve(from, relFile);
                    outputFile = path.resolve(to, relFile);
                    var dir = path.dirname(outputFile);
                    if (!existingDirsLookup[dir]) {
                        mkdirp.sync(dir); //has no effect if dir already exists
                        existingDirsLookup[dir] = true;
                    }
                    var stat = fs.statSync(inputFile);
                    if (stat.isDirectory()) {
                        mkdirp.sync(outputFile); //outputFile is a directory -- create it
                        existingDirsLookup[outputFile] = true;
                    }
                    else if (stat.isFile()) {
                        fs.writeFileSync(outputFile, fs.readFileSync(inputFile));
                        if (onFileCopied != null) {
                            onFileCopied(inputFile);
                        }
                    }
                }
                catch (e) {
                    var msg = "Error copying file " + inputFile + " to " + outputFile + ": " + e.toString();
                    if (onFileError != null) {
                        onFileError(inputFile, msg);
                    }
                }
            });
            if (copyErrors.length)
                err = new Error("Some files could not be copied:\n" + copyErrors.join('\n'));
            return callback(err);
        });
    },
    scanDirRecursively: function (directoryName, logger) {
        var fileNames = [];
        try {
            walk(directoryName, fileNames, "");
            return fileNames;
        }
        catch (err) {
            logger.error(`Error while trying to get all files under '${directoryName}'. ${err}`);
            return [];
        }
    },
    removeRelativeSigns: function (filePath) {
        if (filePath.indexOf(RELATIVE_PATH_SIGN) == -1) {
            return filePath;
        }
        var trimmed = filePath.substring(filePath.lastIndexOf(RELATIVE_PATH_SIGN) + RELATIVE_PATH_SIGN.length);
        return trimmed;
    }
};
function levelUp(workspacePath, filename, logger) {
    logger.debug("file: '" + filename + "' not found in: '" + path.normalize(workspacePath) + "'. searching in parent directory");
    workspacePath = workspacePath + '/..';
    return workspacePath;
}
function walk(directoryName, fileNames, baseFolder) {
    var files = fs.readdirSync(directoryName);
    files.forEach(function (file) {
        var fullPath = path.join(directoryName, file);
        var relativePath = path.join(baseFolder, file);
        var stat = fs.statSync(fullPath);
        if (stat.isDirectory()) {
            walk(fullPath, fileNames, relativePath);
        }
        else {
            fileNames.push(relativePath.replace(/\\/g, '/'));
        }
    });
}
//# sourceMappingURL=file-and-folder-utils.js.map