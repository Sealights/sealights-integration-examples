var jwtDecode = require('jwt-decode');
var JWTPrefix = "eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.";
var readJsonSync = require('read-json-sync');
const fileAndFolderUtils = require('./file-and-folder-utils');
const { IgnoredFilesHandler } = require('../common/ignored-files-handler');
const { CockpitNotifier } = require('../common/agent-events/cockpit-notifier');
const path = require('path');
module.exports = {
    parseToken: function parseToken(parsedToken, parsedArgs) {
        try {
            if (parsedArgs.customerid && parsedArgs.customerid.indexOf(JWTPrefix) == 0) {
                parsedToken = parsedArgs.customerid;
                parsedArgs.token = parsedToken;
            }
            if (!parsedToken) {
                throw new Error("Token Must Be Given");
            }
            var tokenData = jwtDecode(parsedToken);
            if (!tokenData["x-sl-server"]) {
                throw new Error("Doesn't Contain Server");
            }
            if (!tokenData["subject"]) {
                throw new Error("Doesn't Contain Subject");
            }
            var customerId = tokenData["subject"];
            var subjectParts = tokenData["subject"].split("@");
            if (subjectParts.length >= 1) {
                customerId = subjectParts[0];
            }
            parsedArgs.server = tokenData["x-sl-server"];
            parsedArgs.customerid = customerId;
            parsedArgs.isValidToken = true;
        }
        catch (err) {
            console.error("Token Is Invalid. " + err.stack);
            parsedArgs.isValidToken = false;
        }
    },
    adjustPathSlashes: function adjustPathSlashes(path) {
        path = (path || "").replace(/\\/g, '/');
        return path;
    },
    isAbsolutePath: function isAbsolutePath(pathStr) {
        // Win absolute path can't be resolved on linux so we should try to use win specific implementation by purpose via path.win32 
        return path.posix.isAbsolute(pathStr) || path.win32.isAbsolute(pathStr);
    },
    expandCommaSeparatedValues: function expandCommaSeparatedValues(arr, delim) {
        delim = delim || ',';
        arr = arr || [];
        var ret = [];
        arr.forEach(function (item) {
            var parts = item.split(delim);
            ret = ret.concat(parts);
        });
        return ret;
    },
    getMissingProperties: function getMissingFields(fieldsMap) {
        var missingFields = [];
        Object.keys(fieldsMap).forEach(function (key) {
            if (fieldsMap[key]) {
                missingFields.push(key);
            }
        });
        return missingFields.toString();
    },
    isMarkupFile: function (extension) {
        return this.isArrayContainsMarkupFile([extension]);
    },
    isArrayContainsMarkupFile: function (extensionsArr) {
        var MARKUP_FILES_EXTENSIONS_MAP = { '.ftl': true, '.html': true };
        if (!Array.isArray(extensionsArr)) {
            return false;
        }
        for (var i = 0; i < extensionsArr.length; i++) {
            var ext = extensionsArr[i].toLowerCase();
            if (MARKUP_FILES_EXTENSIONS_MAP[ext] === true) {
                return true;
            }
        }
        return false;
    },
    distinctArray: function (value, index, array) {
        return array.indexOf(value) === index;
    },
    cloneObject: function (source, logger) {
        try {
            return JSON.parse(JSON.stringify(source));
        }
        catch (e) {
            logger.error("Failed to clone, returning shallow ");
            return null;
        }
    },
    readJsonSync: function (path, options) {
        return readJsonSync(path, options);
    },
    createSlIgnore(filename, opts, logger) {
        var workspacePath = opts.workspacepath;
        var lookInParentFolders = !!opts.instrumentForBrowsers;
        var slIgnoreScanFilePath = fileAndFolderUtils.findFileRecursively(filename, workspacePath, lookInParentFolders, logger);
        var slIgnoreScan = new IgnoredFilesHandler(slIgnoreScanFilePath, opts.outputpath, opts.excludedpaths, filename, logger);
        submitIgnorePatternToCockpit(slIgnoreScan, filename);
        return slIgnoreScan;
    },
    toRelativePath(key, useRelativeMapping, workspacepath) {
        var relativeKey = key;
        if (useRelativeMapping) {
            relativeKey = key.substring(workspacepath.length);
            if (relativeKey.indexOf('/') === 0) {
                relativeKey = relativeKey.substring(1);
            }
        }
        return relativeKey;
    }
};
function submitIgnorePatternToCockpit(ignoredFilesHandler, filename) {
    var formattedPattern = ignoredFilesHandler.getFormattedPattern();
    if (!formattedPattern) {
        return;
    }
    var ignoreFile = ignoredFilesHandler.isUsingNycConfig ? "NYC configuration" : filename;
    var message = "Using the following ignore pattern from " + ignoreFile + ": " + ignoredFilesHandler.getFormattedPattern();
    CockpitNotifier.sendGenericMessage(message);
}
//# sourceMappingURL=utils.js.map