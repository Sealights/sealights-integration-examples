"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnsureFilesHandlerService = void 0;
const files_data_container_1 = require("./files-data-container");
const path_1 = require("path");
const ActualFile = require("../file-system/actual-file");
const file_element_utils_1 = require("./file-element-utils");
const file_enricher_1 = require("./file-enricher");
const SourceFileNotifier = require("../js_diff/source-files-notifier");
const utils = require("../utils");
const ignored_files_handler_1 = require("../../common/ignored-files-handler");
const data_cleansing_utils_1 = require("../../common/utils/data-cleansing-utils");
class EnsureFilesHandlerService {
    constructor(logger, opts, filesContainer, filePathFixer, scmRootDir, config, fileToCommitsMap, diagnostic) {
        this.logger = logger;
        this.opts = opts;
        this.filesContainer = filesContainer;
        this.filePathFixer = filePathFixer;
        this.scmRootDir = scmRootDir;
        this.config = config;
        this.fileToCommitsMap = fileToCommitsMap;
        this.diagnostic = diagnostic;
        this.WEBPACK_PREFIX = 'webpack:///';
        this.WEBPACK_BOOTSTRAP_FILE = 'webpack/bootstrap';
        this.WEBPACK_LAZY_FILE = '$_lazy';
        this.WEBPACK_SRC_ASYNC = 'src async';
        this.WEBPACK_SRC_LAZY = 'src lazy';
        this.WEBPACK_RESOURCE_SIGN = '~'; // Webpack replace 'node_modules' with '~'
        this.NODE_MODULES = 'node_modules';
        this.THIRD_PARTIES_FOLDERS = [
            this.WEBPACK_BOOTSTRAP_FILE,
            this.WEBPACK_LAZY_FILE,
            this.WEBPACK_RESOURCE_SIGN,
            this.NODE_MODULES,
            this.WEBPACK_SRC_ASYNC,
            this.WEBPACK_SRC_LAZY
        ];
        this.filesDataContainer = new files_data_container_1.FilesDataContainer();
        this.sourceFilesNotifier = new SourceFileNotifier(logger);
    }
    ensureProcess(req) {
        const result = Object.assign(Object.assign({}, req), { files: [] });
        if (this.config.removeSensitiveData) {
            result.meta = data_cleansing_utils_1.DataCleansingUtils.removeSensitiveData(req.meta);
        }
        for (const scannedFile of req.files) {
            const actualScannedFileObject = new ActualFile(scannedFile.logicalPath, scannedFile.absolutePath);
            this.handleMappingOneFile(scannedFile, actualScannedFileObject);
        }
        result.files = this.filesDataContainer.files;
        result.files = this.filePathFixer.fixFilePathes(result.files);
        this.setCommitIndexes(result.files);
        this.filterIgnoredSourceFiles(result);
        const enricher = file_enricher_1.FileEnricherFactory.initByConfig(this.logger, this.diagnostic, this.opts, this.scmRootDir, this.filesContainer, this.config);
        const resultAfterEnrich = enricher.enrichFiles(result);
        this.deleteRedundantFields(resultAfterEnrich);
        return { output: resultAfterEnrich };
    }
    filterIgnoredSourceFiles(result) {
        const ignoredFilesHandler = utils.createSlIgnore(ignored_files_handler_1.IgnoredFilesHandler.GENERATED_IGNORE_FILE_NAME, this.opts, this.logger);
        result.files = result.files.filter(file => {
            if (ignoredFilesHandler.denies(file.physicalPath)) {
                this.logger.info(`File ${file.absolutePath} is ignored`);
                this.diagnostic.generatedFileIgnored(file.absolutePath);
                return false;
            }
            return true;
        });
    }
    deleteRedundantFields(output) {
        output.files.forEach(f => {
            f.methods.forEach(m => { var _a; return (_a = m === null || m === void 0 ? void 0 : m.meta) === null || _a === void 0 ? true : delete _a.identifierPosition; });
        });
    }
    setCommitIndexes(files) {
        files.forEach((file) => { var _a; return file.commitIndexes = ((_a = this.fileToCommitsMap) === null || _a === void 0 ? void 0 : _a[file.physicalPath]) || []; });
    }
    // generatedFile - bundle/result of transpilation
    handleMappingOneFile(scannedFileData, scannedFileObject) {
        var _a;
        const sourceMaps = scannedFileObject.readSourceMapsWithRaw(this.logger);
        if (!sourceMaps.consumer) {
            this.diagnostic.fileWithoutSourceMap(scannedFileData.absolutePath);
            this.filesDataContainer.addFile(scannedFileData);
        }
        else {
            this.diagnostic.fileWithSourceMap(scannedFileData.absolutePath);
            this.diagnostic.fileWithSourceMapConsumer(scannedFileData.absolutePath, sourceMaps.consumer);
            const codeElementMetrics = { hasColumnInfo: false };
            this.addMethods(scannedFileData, sourceMaps.consumer, codeElementMetrics);
            this.addBranches(scannedFileData, sourceMaps.consumer, codeElementMetrics);
            this.sourceFilesNotifier.notifySources((_a = sourceMaps.rawSourceMaps) === null || _a === void 0 ? void 0 : _a.sources, scannedFileData.absolutePath, codeElementMetrics.hasColumnInfo);
        }
    }
    trimWebpackPrefix(source) {
        if (source.indexOf(this.WEBPACK_PREFIX) === 0) {
            source = source.substring(this.WEBPACK_PREFIX.length);
        }
        return source;
    }
    cleanPath(source) {
        source = this.trimWebpackPrefix(source);
        if (source.indexOf('/') === 0) {
            source = source.substring(1);
        }
        return (0, path_1.normalize)(source);
    }
    getMappingPositionForMethod(sourceMaps, method) {
        var _a, _b;
        const startMap = sourceMaps.originalPositionFor({
            line: method.position[0],
            column: method.position[1]
        });
        const endMap = sourceMaps.originalPositionFor({
            line: method.endPosition[0],
            column: method.endPosition[1]
        });
        const identifierPosition = sourceMaps.originalPositionFor({
            line: (_a = method === null || method === void 0 ? void 0 : method.meta) === null || _a === void 0 ? void 0 : _a.identifierPosition[0],
            column: (_b = method === null || method === void 0 ? void 0 : method.meta) === null || _b === void 0 ? void 0 : _b.identifierPosition[1]
        });
        return { startMap, endMap, identifierPosition };
    }
    getMappingPositionForBranch(sourceMaps, branch) {
        const startMap = sourceMaps.originalPositionFor({
            line: branch.position[0],
            column: branch.position[1]
        });
        const parentStartMap = sourceMaps.originalPositionFor({
            line: branch.parentPosition[0],
            column: branch.parentPosition[1]
        });
        const endMap = sourceMaps.originalPositionFor({
            line: branch.endPosition[0],
            column: branch.endPosition[1]
        });
        return { startMap, endMap, parentStartMap };
    }
    addMethods(scannedFileData, sourceMaps, codeElementMetrics) {
        for (const method of scannedFileData.methods) {
            const { startMap, endMap, identifierPosition } = this.getMappingPositionForMethod(sourceMaps, method);
            if (identifierPosition) {
                method.meta.identifierPosition = [identifierPosition.line, identifierPosition.column];
            }
            if (this.isMapValid(startMap)) {
                if (+startMap.column !== 0) {
                    codeElementMetrics.hasColumnInfo = true;
                }
                const cleanPath = this.cleanPath(startMap.source);
                const mappedMethod = (0, file_element_utils_1.createMethod)(startMap, endMap, method, method.uniqueIdKey, this.diagnostic);
                this.filesDataContainer.addMethod(cleanPath, mappedMethod);
                this.diagnostic.addMappedMethod(scannedFileData.absolutePath, cleanPath, mappedMethod);
            }
        }
    }
    addBranches(generatedFile, sourceMaps, codeElementMetrics) {
        for (const branch of generatedFile.branches) {
            const branchInfo = branch;
            const { startMap, endMap, parentStartMap } = this.getMappingPositionForBranch(sourceMaps, branch);
            if (this.isMapValid(startMap)) {
                if (+startMap.column !== 0) {
                    codeElementMetrics.hasColumnInfo = true;
                }
                const cleanPath = this.cleanPath(startMap.source);
                this.filesDataContainer.addBranch(cleanPath, (0, file_element_utils_1.createBranch)(startMap, endMap, parentStartMap, branchInfo, cleanPath, branch.uniqueIdKey));
            }
        }
    }
    isMapValid(map) {
        if (!map.source) {
            return false;
        }
        const mapFix = this.trimWebpackPrefix(map.source);
        return mapFix && !this.THIRD_PARTIES_FOLDERS.some(str => mapFix.includes(str));
    }
}
exports.EnsureFilesHandlerService = EnsureFilesHandlerService;
//# sourceMappingURL=ensure-files-handler.service.js.map