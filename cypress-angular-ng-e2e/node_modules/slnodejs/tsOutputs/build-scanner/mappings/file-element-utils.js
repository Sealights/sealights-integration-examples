"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBranchPosition = exports.createBranch = exports.createMethod = void 0;
const logger_1 = require("../../common/logger");
const logger = logger_1.LoggerFactory.getCreateApplicationLogger();
function createMethod(startMap, endMap, method, uniqueIdKey, diagnostic) {
    const position = [startMap.line, startMap.column];
    const endPosition = [endMap.line, endMap.column];
    let displayName = '(Anonymous)';
    let displayNameSource = 'Anonymous';
    if (startMap.name) {
        displayName = startMap.name;
        displayNameSource = 'startMap';
    }
    else if (method.displayName) {
        displayName = method.displayName;
        displayNameSource = 'method.displayName';
    }
    else {
        displayName = '(Anonymous)';
        displayNameSource = 'Anonymous';
    }
    diagnostic.methodWasMapped(uniqueIdKey, position, endPosition, { value: displayName, source: displayNameSource });
    return {
        position,
        endPosition,
        meta: method.meta,
        techSpecificInfo: method.techSpecificInfo,
        displayName: displayName,
        hash: method.hash,
        idxInMapping: method.idxInMapping,
        sigHash: method.sigHash,
        uniqueIdKey: uniqueIdKey,
    };
}
exports.createMethod = createMethod;
function createBranch(startPosition, endPosition, parentPosition, branchInfo, logicalPath, uniqueIdKey) {
    return {
        filename: logicalPath,
        type: branchInfo.type,
        endPosition: [endPosition.line, endPosition.column],
        position: [startPosition.line, startPosition.column],
        hash: branchInfo.hash,
        index: branchInfo.index,
        parentPosition: [parentPosition.line, parentPosition.column],
        enclosingMethodIdx: branchInfo.enclosingMethodIdx,
        techSpecificInfo: branchInfo.techSpecificInfo || {},
        uniqueIdKey: uniqueIdKey
    };
}
exports.createBranch = createBranch;
function getBranchPosition(branch) {
    if (branch.type !== 'IfStatement') {
        return branch.position;
    }
    if (!isNaN(branch.parentPosition[0]) && !isNaN(branch.parentPosition[1])) {
        return branch.parentPosition;
    }
    logger.info(`Branch at position '${branch.position}' in file '${branch.filename}' is an if statement inside async methods using branch position instead of parent`);
    return branch.position;
}
exports.getBranchPosition = getBranchPosition;
//# sourceMappingURL=file-element-utils.js.map