"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilePathFixer = void 0;
const path_1 = require("path");
const files_utils_1 = require("../../common/utils/files-utils");
const file_element_utils_1 = require("./file-element-utils");
const sl_mapper_1 = require("../js_diff/sl-mapper");
const cockpit_notifier_1 = require("../../common/agent-events/cockpit-notifier");
const validation_utils_1 = require("../../common/utils/validation-utils");
class FilePathFixer {
    constructor(filesContainer, slMapper, logger, projectRoot, useModulePrefix, uniqueModuleId) {
        this.filesContainer = filesContainer;
        this.slMapper = slMapper;
        this.logger = logger;
        this.prefix = '';
        this.projectRoot = '';
        this.removeAutoGeneratedFiles = false;
        validation_utils_1.ValidationUtils.verifyNotNullOrEmptyMultiParams([
            { value: filesContainer, paramName: 'filesContainer' },
            { value: slMapper, paramName: 'slMapper' },
            { value: logger, paramName: 'logger' },
        ]);
        if (useModulePrefix) {
            this.setPrefix(uniqueModuleId);
        }
        this.projectRoot = (0, path_1.normalize)(projectRoot);
    }
    setPrefix(uniqueModuleId) {
        if (uniqueModuleId) {
            this.prefix = `${uniqueModuleId}/`;
        }
        if (this.prefix) {
            cockpit_notifier_1.CockpitNotifier.sendGenericMessage(`Using '${this.prefix}' as prefix to files path and uniqueIds, moduleName: '${uniqueModuleId}'`);
        }
    }
    fixFilePathes(files) {
        const duplicatesMatchFiles = [];
        let prefixToAdd = '';
        const uniqueFiles = [...files];
        for (const file of files) {
            const filesFromFileContainer = this.findPathInFilesContainer(file.logicalPath);
            // will be processed later
            if (filesFromFileContainer.length > 1) {
                duplicatesMatchFiles.push(file);
                continue;
            }
            // perfect case - processing
            if (filesFromFileContainer.length === 1) {
                const fullFilePath = filesFromFileContainer[0];
                prefixToAdd = fullFilePath.replace(file.logicalPath, '');
                this.fixOneFile(file, fullFilePath);
                continue;
            }
            // remove file from build map if flag allow that
            if (this.removeAutoGeneratedFiles) {
                this.logger.info(`Cannot find file ${file.logicalPath} in source files. File is auto generated.`);
                const indexToRemove = uniqueFiles.indexOf(file);
                uniqueFiles.splice(indexToRemove, 1);
                continue;
            }
            // fallback - source file was not found, trying to resolve path only by references from build map
            const fixedPath = file.logicalPath.replace(this.projectRoot, '');
            this.fixOneFile(file, fixedPath);
        }
        for (const fileToFix of duplicatesMatchFiles) {
            this.fixOneFile(fileToFix, `${prefixToAdd}${fileToFix.logicalPath}`);
        }
        return uniqueFiles;
    }
    fixOneFile(file, filePath) {
        const fixedFilePath = files_utils_1.FilesUtils.adjustPathSlashes(filePath);
        if ((this.slMapper instanceof sl_mapper_1.SlMapper) && !(this.slMapper instanceof sl_mapper_1.BrowserSlMapper)) {
            this.slMapper.addMapping(file.logicalPath, fixedFilePath);
        }
        file.logicalPath = this.getLogicalPath(fixedFilePath);
        file.physicalPath = fixedFilePath;
        file.absolutePath = this.getAbsolutePath(fixedFilePath);
        file.methods.forEach(method => {
            method.uniqueId = `${file.logicalPath}@${method.position.join(',')}`;
            if (this.slMapper instanceof sl_mapper_1.BrowserSlMapper) {
                this.slMapper.addMapping(method.uniqueIdKey, method.uniqueId);
            }
            delete method.uniqueIdKey;
        });
        file.branches.forEach(branch => {
            const position = (0, file_element_utils_1.getBranchPosition)(branch);
            branch.uniqueId = `${file.logicalPath}|${position.join(',')}|${branch.index}`;
            if (this.slMapper instanceof sl_mapper_1.BrowserSlMapper) {
                this.slMapper.addMapping(branch.uniqueIdKey, branch.uniqueId);
            }
            delete branch.uniqueIdKey;
        });
    }
    getLogicalPath(fixedPath) {
        let pathWithPrefix = `${this.prefix}${fixedPath}`;
        if (pathWithPrefix.indexOf('/') === 0) {
            pathWithPrefix = pathWithPrefix.substring(1);
        }
        return files_utils_1.FilesUtils.adjustPathSlashes(pathWithPrefix);
    }
    getAbsolutePath(fixedPath) {
        const absolutePath = (0, path_1.join)(this.projectRoot, fixedPath);
        return files_utils_1.FilesUtils.adjustPathSlashes(absolutePath);
    }
    findPathInFilesContainer(sourceFilePath) {
        const files = this.filesContainer.getFilePath(sourceFilePath);
        return files !== null ? files : [];
    }
}
exports.FilePathFixer = FilePathFixer;
//# sourceMappingURL=file-path-fixer.js.map