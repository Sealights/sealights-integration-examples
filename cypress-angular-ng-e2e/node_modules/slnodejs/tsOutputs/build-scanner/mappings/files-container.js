"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilesContainer = void 0;
const glob_1 = require("glob");
const utils = require("../utils");
/**
 * Contains the mapping between partial file path to git path.
 */
class FilesContainer {
    constructor(logger) {
        this.logger = logger;
        this.partialToFullPathMap = {};
    }
    static create(logger, projectRoot = process.cwd(), ignore = 'node_modules/**') {
        return __awaiter(this, void 0, void 0, function* () {
            const filesContainer = new FilesContainer(logger);
            const files = glob_1.glob.sync('**/*', {
                cwd: projectRoot,
                ignore,
                nodir: true,
            });
            files.forEach(filePath => {
                filesContainer.addFilePath(filePath);
            });
            return filesContainer;
        });
    }
    static createWithFiles(logger, files) {
        return __awaiter(this, void 0, void 0, function* () {
            const filesContainer = new FilesContainer(logger);
            files.forEach(filePath => {
                filesContainer.addFilePath(filePath);
            });
            return filesContainer;
        });
    }
    /**
     * Add file to files map, each file has keys per each optional sub path.
     * For example: given file 'foo/src/index.js', it gets the following keys:
     * 1. 'foo/src/index.js'
     * 2. 'src/index.js'
     * 3. 'index.js'
     */
    addFilePath(filePath) {
        for (const subPath of iterateSubPathes(filePath)) {
            this.partialToFullPathMap[subPath] = this.partialToFullPathMap[subPath] || [];
            this.partialToFullPathMap[subPath].push(filePath);
        }
    }
    /**
     * Return files that contain partial file path
     */
    getFilePath(partialPath) {
        let filePathes = null;
        for (const subPath of iterateSubPathes(partialPath)) {
            filePathes = this.partialToFullPathMap[subPath] || null;
            if ((filePathes === null || filePathes === void 0 ? void 0 : filePathes.length) === 1) {
                break;
            }
        }
        if (filePathes === null) {
            this.logger.warn(this.getWarningText(partialPath));
        }
        return filePathes;
    }
    getWarningText(partialPath) {
        return `${partialPath} has no match to any source file`;
    }
}
exports.FilesContainer = FilesContainer;
function* iterateSubPathes(filePath) {
    const normalizedFilePath = utils.adjustPathSlashes(filePath);
    const parts = normalizedFilePath.split('/');
    for (let i = parts.length; i > 0; i--) {
        const partsToSlice = parts.length - i;
        const key = parts.slice(partsToSlice).join('/');
        yield key;
    }
}
//# sourceMappingURL=files-container.js.map