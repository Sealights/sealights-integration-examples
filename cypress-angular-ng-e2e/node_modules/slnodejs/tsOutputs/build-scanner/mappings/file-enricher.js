"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileEnricherByLineMatch = exports.FileEnricher = exports.FileEnricherFactory = void 0;
const fs = require("fs");
const path = require("path");
const FileSignature = require("../js_diff/file-signature");
const cockpit_notifier_1 = require("../../common/agent-events/cockpit-notifier");
class FileEnricherFactory {
    static initByConfig(logger, diagnosticCollector, opts, scmRootDir, scmFilesContainer, config) {
        if (config.enrichByLinesMatch) {
            return new FileEnricherByLineMatch(logger, diagnosticCollector, opts, scmRootDir, scmFilesContainer, config);
        }
        return new FileEnricher(logger, diagnosticCollector, opts, scmRootDir, scmFilesContainer, config);
    }
}
exports.FileEnricherFactory = FileEnricherFactory;
class FileEnricher {
    constructor(logger, diagnosticCollector, opts, scmRootDir, scmFilesContainer, config) {
        this.logger = logger;
        this.diagnosticCollector = diagnosticCollector;
        this.opts = opts;
        this.scmRootDir = scmRootDir;
        this.scmFilesContainer = scmFilesContainer;
        this.config = config;
    }
    enrichFiles(res) {
        const result = Object.assign(Object.assign({}, res), { files: [...res.files] });
        for (const file of result.files) {
            if (file.absolutePath && file.fromSourceMaps) {
                if (this.isFileSupported(file.absolutePath)) {
                    try {
                        const currentFileSource = this.getFileSignature(file.absolutePath, file.logicalPath);
                        file.methods = this.enrichItems(currentFileSource, file.methods, CodeElementsType.METHOD, file.positionToMethod, file.endPositionToMethod);
                        file.branches = this.enrichItems(currentFileSource, file.branches, CodeElementsType.BRANCH, file.positionToBranch, {});
                    }
                    catch (e) {
                        this.logger.error(`Error while enriching file ${file.absolutePath}`, e);
                    }
                }
            }
            else {
                this.logger.info(`File ${file.absolutePath} not resolved from source maps, skipping enrichment`);
                this.diagnosticCollector.skipEnrichment(file.absolutePath, 'not from source maps');
            }
        }
        return result;
    }
    isFileSupported(absolutePath) {
        if (!fs.existsSync(absolutePath)) {
            this.logger.warn(`Source file '${absolutePath}' does not exists, skipping enrichment`);
            return false;
        }
        const validExtensions = ['.ts', '.jsx', '.js', '.tsx'];
        const extension = path.extname(absolutePath);
        if (!validExtensions.includes(extension)) {
            this.logger.info(`Extension '${extension}' for file '${absolutePath}' is not supported, skipping enrichment`);
            this.diagnosticCollector.skipEnrichment(absolutePath, 'not valid extension');
            return false;
        }
        return true;
    }
    getItemsMap(resolvePositionToElement, currentFileSource, type, resolveEndPositionToElement) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const sourceFileStartPositionMap = type == CodeElementsType.METHOD ? currentFileSource.positionToMethod : currentFileSource.positionToBranchMap;
        const sourceFileEndPositionMap = type == CodeElementsType.METHOD ? currentFileSource.endPositionToMethod : {};
        const sourceElements = type == CodeElementsType.METHOD ? currentFileSource.methods : currentFileSource.branches;
        const sourceFileIdxToStartPosition = this.itemIndexToPosition(sourceFileStartPositionMap);
        const resolvedIdxToStartPosition = this.itemIndexToPosition(resolvePositionToElement);
        const resolvedIdxToEndPosition = type === CodeElementsType.BRANCH ? {} : this.itemIndexToPosition(resolveEndPositionToElement);
        const itemsToEnrich = [];
        const itemsToMarkAsAutoGenerate = [];
        const itemsToAdd = [];
        for (const [idx, startPositions] of Object.entries(resolvedIdxToStartPosition)) {
            const sourceIdxByStart = this.getIdxByPosition(startPositions, sourceFileStartPositionMap);
            const sourceIdxByEnd = type === CodeElementsType.BRANCH ? -1 : this.getIdxByPosition(resolvedIdxToEndPosition[+idx], sourceFileEndPositionMap);
            if (sourceIdxByStart > -1) {
                itemsToEnrich.push({ resolvedIdx: +idx, sourceIdx: sourceIdxByStart });
                this.logger.debug(`Item starts at '${(_c = (_b = (_a = sourceElements[sourceIdxByStart]) === null || _a === void 0 ? void 0 : _a.srcData) === null || _b === void 0 ? void 0 : _b.position) === null || _c === void 0 ? void 0 : _c.join(',')}' in file '${currentFileSource.absolutePath}' will be enriched`);
            }
            else if (sourceIdxByEnd > -1 && ((_e = (_d = sourceElements[sourceIdxByEnd]) === null || _d === void 0 ? void 0 : _d.techSpecificInfo) === null || _e === void 0 ? void 0 : _e.isDecorated)) {
                itemsToEnrich.push({ resolvedIdx: +idx, sourceIdx: sourceIdxByEnd });
                this.logger.debug(`Item starts at '${(_h = (_g = (_f = sourceElements[sourceIdxByEnd]) === null || _f === void 0 ? void 0 : _f.srcData) === null || _g === void 0 ? void 0 : _g.position) === null || _h === void 0 ? void 0 : _h.join(',')}' in file '${currentFileSource.absolutePath}' is a decorated method, will be enriched by end position matching`);
            }
            else {
                itemsToMarkAsAutoGenerate.push(+idx);
                this.logger.debug(`Could not find source element in any of the following positions '${startPositions.join(' || ')}' in file '${currentFileSource.absolutePath}', marking as auto generated`);
            }
        }
        if (type === CodeElementsType.METHOD) {
            for (const [idx, startPositions] of Object.entries(sourceFileIdxToStartPosition)) {
                const resolvedIdxByStart = this.getIdxByPosition(startPositions, resolvePositionToElement);
                const resolvedIdxByEnd = this.getIdxByPosition(resolvedIdxToEndPosition[+idx], resolveEndPositionToElement);
                const isDecorated = resolvedIdxByEnd > -1 && ((_k = (_j = sourceElements[+idx]) === null || _j === void 0 ? void 0 : _j.techSpecificInfo) === null || _k === void 0 ? void 0 : _k.isDecorated) == true;
                if (resolvedIdxByStart === -1 && !isDecorated) {
                    itemsToAdd.push(+idx);
                    this.logger.debug(`Element in file '${currentFileSource.absolutePath}' at position '${sourceElements[idx].position}' not exists in generated file`);
                }
            }
        }
        return { itemsToEnrich, itemsToMarkAsAutoGenerate, itemsToAdd };
    }
    getIdxByPosition(startPositions = [], sourceFilePositionMap) {
        for (const position of startPositions) {
            const sourceIdx = sourceFilePositionMap[position];
            if (sourceIdx > -1) {
                return sourceIdx;
            }
            /*
               We observed an issue in certain customer applications (typically React with arrow functions)
               where from the source-map module we might receive a miss-matched position of the column index by +1.
               We added the permutation bellow in order to shift the column by 1 index which gives us one additional
               chance to match and enrich the method from the source file.
               https://sealights.atlassian.net/wiki/spaces/DEV/pages/3307667506/Node+Agent+-+Source+File+enrichment+process+index+adjustment+impact
             */
            const [row, column] = position.split(',');
            const anotherPossiblePosition = `${row},${Number(column) - 1}`;
            const anotherSourceIdx = sourceFilePositionMap[anotherPossiblePosition];
            if (anotherSourceIdx > -1) {
                cockpit_notifier_1.CockpitNotifier.sendWarning(`Position '${position}' not matched at initial map, matched at alternate index '${anotherSourceIdx}' with position data '${anotherPossiblePosition}'`);
                return anotherSourceIdx;
            }
        }
        return -1;
    }
    enrichItems(currentFileSource, codeItems, type, positionToElement, resolveEndPositionToElement) {
        const result = [];
        if (currentFileSource) {
            const { itemsToEnrich, itemsToMarkAsAutoGenerate } = this.getItemsMap(positionToElement, currentFileSource, type, resolveEndPositionToElement);
            for (const idx of itemsToMarkAsAutoGenerate) {
                const codeItem = codeItems[idx];
                const codeItemCopy = Object.assign({}, codeItem);
                codeItemCopy.techSpecificInfo.autoGenerated = true;
                result.push(codeItemCopy);
                if (type === CodeElementsType.METHOD) {
                    this.diagnosticCollector.autoGeneratedMethod(currentFileSource.absolutePath, codeItemCopy.uniqueId);
                }
            }
            for (const item of itemsToEnrich) {
                const codeItem = codeItems[item.resolvedIdx];
                const codeItemCopy = Object.assign({}, codeItem);
                if (type === CodeElementsType.METHOD) {
                    this.enrichMethod(codeItemCopy, currentFileSource.methods[item.sourceIdx]);
                }
                result.push(codeItemCopy);
                if (type === CodeElementsType.METHOD) {
                    this.diagnosticCollector.methodEnriched(currentFileSource.absolutePath, codeItemCopy.uniqueId);
                }
            }
        }
        return result;
    }
    itemIndexToPosition(positionMap) {
        const itemToPosition = {};
        for (const [position, idx] of Object.entries(positionMap)) {
            itemToPosition[idx] = itemToPosition[idx] || [];
            itemToPosition[idx].push(position);
        }
        return itemToPosition;
    }
    enrichMethod(generatedMethod, sourceMethod) {
        generatedMethod.displayName = sourceMethod.srcData.displayName;
        generatedMethod.meta = Object.assign({}, sourceMethod.meta);
        generatedMethod.techSpecificInfo = Object.assign({}, sourceMethod.techSpecificInfo);
        if (this.config.es6Classes && sourceMethod.accessibility) {
            generatedMethod.uniqueId = sourceMethod.uniqueId;
            generatedMethod.position = sourceMethod.srcData.position;
        }
        if (generatedMethod.techSpecificInfo.isAsync) {
            generatedMethod.hash = sourceMethod.srcData.hash;
            generatedMethod.sigHash = sourceMethod.srcData.sigHash;
        }
        if (this.config.sourceHash) {
            generatedMethod.oldHash = generatedMethod.hash;
            generatedMethod.oldSigHash = generatedMethod.sigHash;
            generatedMethod.hash = sourceMethod.srcData.hash;
            generatedMethod.sigHash = sourceMethod.srcData.sigHash;
        }
    }
    // TODO: method not directly related to purpose of this class
    getFileSignature(absolutePath, logicalPath) {
        const babylonPlugins = Array.isArray(this.opts.babylonPlugins) ? [...this.opts.babylonPlugins] : [];
        babylonPlugins.push('classProperties');
        const extension = path.extname(absolutePath);
        if (extension === '.jsx' || extension === '.tsx') {
            if (babylonPlugins.indexOf('jsx') === -1) {
                this.diagnosticCollector.pluginAdded(absolutePath, 'jsx');
                babylonPlugins.push('jsx');
            }
        }
        if (extension === '.ts' || extension === '.tsx') {
            this.diagnosticCollector.pluginAdded(absolutePath, 'typescript');
            babylonPlugins.push('typescript');
        }
        const opts = {
            es6Modules: true,
            babylonPlugins,
            allowAccessibilityAdjustment: this.config.es6Classes || this.config.enrichPrivateMethods,
            projectRoot: this.opts.projectRoot,
            scmRootDir: this.scmRootDir,
            isBranchCoverage: this.config.useBranchCoverage || this.opts.usebranchcoverage,
            isForEnrichment: true,
        };
        const fileContent = fs.readFileSync(absolutePath, 'utf-8');
        do {
            try {
                return FileSignature.create(absolutePath, logicalPath, fileContent, null, opts, this.scmFilesContainer, this.logger, this.diagnosticCollector);
            }
            catch (error) {
                if (error.missingPlugin) {
                    this.diagnosticCollector.missedPlugin(absolutePath, error.missingPlugin[0]);
                    opts.babylonPlugins.push(error.missingPlugin[0]);
                }
                else {
                    throw error;
                }
            }
        } while (true);
    }
}
exports.FileEnricher = FileEnricher;
class FileEnricherByLineMatch extends FileEnricher {
    getIdxByPosition(startPositions = [], sourceFilePositionMap) {
        for (const position of startPositions) {
            const [line] = position.split(',');
            const sourceIdx = this.findPositionByLine(parseInt(line), sourceFilePositionMap);
            return sourceIdx;
        }
    }
    findPositionByLine(line, sourceFilePositionMap) {
        const [_, value] = Object.entries(sourceFilePositionMap).find(([key]) => {
            const [row] = key.split(',');
            return line === parseInt(row);
        });
        return value;
    }
}
exports.FileEnricherByLineMatch = FileEnricherByLineMatch;
var CodeElementsType;
(function (CodeElementsType) {
    CodeElementsType["BRANCH"] = "branch";
    CodeElementsType["METHOD"] = "method";
})(CodeElementsType || (CodeElementsType = {}));
//# sourceMappingURL=file-enricher.js.map