var Promise = require('promise');
var FilesMapping = require("./js_diff/files-mapping");
var EnsureFilesHandlerService = require("./mappings/ensure-files-handler.service").EnsureFilesHandlerService;
var DryRunFilesMapping = require("./js_diff/dry-run-files-mapping");
// TODO: Find a way to get version number without relative path
// var version = require("../package.json").version;
var version = "1.0.0";
var utils = require('./utils.js');
var os = require("os");
var path = require("path");
var DefaultValuesResolver = require('./default-values-resolver');
var fileAndFolderUtils = require("./file-and-folder-utils");
var BrowserInstrumenter = require('./instrumentation/browser-instrumenter');
var dvr = new DefaultValuesResolver();
var { ScmFilesContainer } = require("./scm/scm-files-container");
var { FilesContainer } = require("./mappings/files-container");
var CiaEnvVars = require("../common/constants/sl-env-vars").SlEnvVars.CIA;
const { BrowserSlMapper, SlMapper } = require('./js_diff/sl-mapper');
const { FilePathFixer } = require('./mappings/file-path-fixer');
const { ScmFileFixer } = require('./scm/scm-file-fixer');
const { CockpitNotifier } = require('../common/agent-events/cockpit-notifier');
const { SourceMapEraserFactory } = require('./source-map-eraser/factory');
const fs = require('fs');
function shouldSubmitSlMapping(buildArguments) {
    if (!buildArguments.instrumentationOnly) {
        return true;
    }
    return !buildArguments.useRelativeSlMapping;
}
function getSlMapperInstance(buildArguments) {
    if (buildArguments.useRelativeSlMapping || buildArguments.instrumentForBrowsers) {
        return BrowserSlMapper;
    }
    return SlMapper;
}
function resolveFilePathFixer(handlerParams, buildArguments, slMapper, logger) {
    if (buildArguments.scm === 'git') {
        return new ScmFileFixer(handlerParams.filesContainer, slMapper, logger, handlerParams.projectRoot, handlerParams.scmRootDir, buildArguments.useModulePrefix, buildArguments.uniqueModuleId);
    }
    else {
        return new FilePathFixer(handlerParams.filesContainer, slMapper, logger, handlerParams.projectRoot, buildArguments.useModulePrefix, buildArguments.uniqueModuleId);
    }
}
// TODO: should be moved to ConfigLoader when it will exist in context of scan
function checkDeprecatedEnvVar(logger) {
    const deprecatedEnvVars = [
        {
            key: 'SL_scmPrefix',
            message: 'Support of `SL_scmPrefix` param was removed in v6.1.515. Please contact customer.success@sealights.io if you have any scan issue. You might have an issue with how you use `--projectRoot`.'
        },
        {
            key: 'SL_HttpMaxAttempts',
            message: 'Please use `SL_httpMaxAttempts` instead'
        },
        {
            key: 'SL_HttpAttemptInterval',
            message: 'Please use `SL_httpAttemptInterval` instead'
        },
    ];
    for (const deprecatedEnvVar of deprecatedEnvVars) {
        if (process.env[deprecatedEnvVar.key]) {
            logger.warn(`Deprecated env_var \`${deprecatedEnvVar.key}\` was provided. ${deprecatedEnvVar.message}`);
            CockpitNotifier.sendWarning(`Deprecated env_var \`${deprecatedEnvVar.key}\` was provided with value - '${process.env[deprecatedEnvVar.key]}'. ${deprecatedEnvVar.message}`);
        }
    }
}
function BuildDiffProcess(buildArgs, backendProxy, scmFactory, parsedDependencies, logger, diagnostic) {
    var log = logger.child({
        className: "BuildDiffProcess"
    });
    function createBuildDiffPromiseChain(buildArguments) {
        parsedDependencies = parsedDependencies || [];
        var handlerParams = {
            buildArguments: buildArguments,
            cfg: buildArguments,
            finalOutput: {
                meta: createMetaTag(buildArguments),
                version: "2.0",
                files: [],
                dependencies: parsedDependencies
            }
        };
        var promiseChain = Promise.resolve();
        // TODO: should be moved to ConfigLoader when it will exist
        checkDeprecatedEnvVar(log);
        if (parsedDependencies.length == 0) { //If there are dependencies, no need to require workspacepath, scm, commit, and no need to perform actual scanning
            var scmInstance;
            if (buildArguments.workspacepath) {
                scmInstance = scmFactory.createScmByType(buildArguments.scm, buildArguments, buildArguments.workspacepath);
                if (scmInstance) {
                    handlerParams.finalOutput.meta.scm = buildArguments.scm;
                    log.info("Created an scmInstance of type '" + buildArguments.scm + "'. Searching for a local repository at '" + buildArguments.workspacepath + "'.");
                    if (!buildArguments.commit && !scmInstance.detectCommitVersion) {
                        return Promise.reject("'commit' command-line argument is required, since automatic detection by the " + buildArguments.scm + " SCM is not supported");
                    }
                }
                else {
                    log.warn("Unsupported scm type: '" + buildArguments.scm + "'.");
                }
                //2. If there is a mapping, get the diffs
                if (scmInstance) {
                    promiseChain = promiseChain.then(() => collectScmData(buildArguments, handlerParams, scmInstance));
                }
                promiseChain = promiseChain.then(function () {
                    var fileMappingInstance = buildArguments.isDryRunMode ? DryRunFilesMapping : FilesMapping;
                    var filesMapping = new fileMappingInstance(handlerParams, diagnostic, log, handlerParams.projectRoot);
                    return filesMapping.process();
                });
            }
        }
        //4. Submit the final output to the server
        var slMapperInstance = getSlMapperInstance(buildArguments);
        var slMapper;
        promiseChain = promiseChain.then(function () {
            slMapper = new slMapperInstance(CiaEnvVars.getSlMappingPath(), backendProxy, buildArguments.buildSessionId, logger);
            handlerParams.filePathFixer = resolveFilePathFixer(handlerParams, buildArguments, slMapper, logger);
            var fixer = new EnsureFilesHandlerService(logger, handlerParams.buildArguments, handlerParams.filesContainer, handlerParams.filePathFixer, handlerParams.scmRootDir, handlerParams.cfg, handlerParams.fileToCommitsMap, diagnostic);
            const result = fixer.ensureProcess(handlerParams.finalOutput);
            handlerParams.finalOutput = result.output;
            if (buildArguments.awsConfigure) {
                // Write the files from the final output to the disk so they can be retrieved for the AWS config file, also add sl-mapping data (for TS projects)
                const filePaths = result.output.files.map(file => file.logicalPath);
                const slMapping = slMapper.toJSON();
                fs.writeFileSync(process.cwd() + '/project-files.json', JSON.stringify({
                    files: filePaths,
                    slMapping: slMapping
                }, null, 2));
            }
            // if (buildArguments.instrumentForBrowsers) {
            //     promiseChain = promiseChain.then(function () {
            //         return submitSlMapping(promiseChain, slMapper, buildArguments.uniqueModuleId, logger)
            //     })
            // }
            if (buildArguments.instrumentationOnly) {
                log.info("No need to submit the files to server as the 'instrumentationOnly' flag is on.");
                return Promise.resolve();
            }
            else {
                //TODO: [SLDEV-4708] When the call to the server fails, the agent is "silent" and not showing any error message.
                return backendProxy.submitBuildMapping(handlerParams.finalOutput);
            }
        });
        //5. Print the counters
        promiseChain = promiseChain.then(function () {
            var mapping = handlerParams.finalOutput;
            const counters = countElements(mapping.files);
            if (!buildArguments.isDryRunMode) {
                log.lifecycle("Scanned " + counters.methods + " methods and " + counters.branches + " branches in " + counters.files + " files.");
            }
        });
        if (shouldSubmitSlMapping(buildArguments)) {
            promiseChain = promiseChain.then(function () {
                return slMapper.submitMapping(buildArguments.uniqueModuleId);
            });
        }
        promiseChain = promiseChain.then(function () {
            return diagnostic.submitDiagnostic();
        });
        // delete source maps if required
        if (buildArguments.excludeSourceMapFiles) {
            const sourceMapsEraser = SourceMapEraserFactory.createSourceMapEraserByMode(buildArguments.excludeSourceMapFiles, logger, buildArguments.workspacepath);
            promiseChain = promiseChain.then(function () {
                return sourceMapsEraser.remove();
            });
        }
        //6. Create instrumented browser files.
        if (buildArguments.instrumentForBrowsers) {
            promiseChain = promiseChain.then(function () {
                if (handlerParams.finalOutput && handlerParams.finalOutput.files && !buildArguments.isDryRunMode) {
                    delete handlerParams.finalOutput.files;
                }
                var promise = new Promise(function (resolve, reject) {
                    var resolveWithoutHash = true;
                    var delayShutdownInSeconds = buildArguments.delayShutdownInSeconds || 30;
                    var downloadAgent = buildArguments.downloadAgent != null ? buildArguments.downloadAgent : true;
                    // TODO - is there any reason not to copy buildArguments as is an override specific fields which require logic?
                    var instrumentationConfig = {
                        appName: buildArguments.appname,
                        build: buildArguments.build,
                        customerId: buildArguments.customerId,
                        branch: buildArguments.branch,
                        sourceRoot: buildArguments.workspacepath,
                        files: getProcessedFiles(buildArguments, handlerParams.processedFiles, logger),
                        outputPath: buildArguments.outputpath,
                        copyAllFilesToOutput: buildArguments.copyAllFilesToOutput !== false,
                        buildSessionId: buildArguments.buildSessionId,
                        esModules: buildArguments["es6Modules"],
                        server: buildArguments.server,
                        token: buildArguments.token,
                        instrumentationType: "browser",
                        resolveWithoutHash: resolveWithoutHash,
                        delayShutdownInSeconds: delayShutdownInSeconds,
                        downloadAgent: downloadAgent,
                        workspacepath: buildArguments.workspacepath,
                        slMappingPath: CiaEnvVars.getSlMappingPath(),
                        slMappingUrl: CiaEnvVars.getSlMappingUrl() || CiaEnvVars.getSlMappingPath(),
                        labId: buildArguments.labid,
                        collectorUrl: buildArguments.collectorUrl,
                        babylonPlugins: buildArguments.babylonPlugins,
                        usebranchcoverage: buildArguments.usebranchcoverage,
                        useRelativeSlMapping: buildArguments.useRelativeSlMapping,
                        enableOpenTelemetry: buildArguments.enableOpenTelemetry,
                        allowCORS: buildArguments.allowCORS,
                        footprintsMapping: buildArguments.footprintsMapping,
                        removeSensitiveData: buildArguments.removeSensitiveData,
                        excludeSourceMapFiles: buildArguments.excludeSourceMapFiles,
                        experimentalSizeReduction: buildArguments.experimentalSizeReduction,
                        newInstrumenter: buildArguments.newInstrumenter,
                    };
                    log.info(`'instrumentForBrowsers' flag is on. Starting instrumentation. Instrumentation config: ${instrumentationConfig}`);
                    var callback = function (err, processedFiles) {
                        if (buildArguments.isDryRunMode) {
                            return resolve({ err: err, processedFiles: processedFiles });
                        }
                        else if (err) {
                            log.info(`Finished the instrumentation with an error. Error: ${err}`);
                            reject(err);
                        }
                        else {
                            log.info("Finished the instrumentation successfully");
                            return resolve();
                        }
                    };
                    runBrowserInstrumentation(log, instrumentationConfig, callback, slMapper);
                });
                return promise;
            });
        }
        return promiseChain;
    }
    function collectScmData(buildArguments, handlerParams, scmInstance) {
        var promiseChain = Promise.resolve();
        //2.1 Get repository url from the SCM
        promiseChain = promiseChain.then(function () {
            log.info("Getting repository URL.");
            return getRepositoryUrl(handlerParams, scmInstance);
        });
        //2.2 Get all contributors from the scm
        if (buildArguments.sendContributors) {
            promiseChain = promiseChain.then(function () {
                log.info("Getting contributors.");
                return getContributors(handlerParams, scmInstance);
            });
        }
        //2.3 Get branch history from the SCM
        promiseChain = promiseChain.then(function () {
            log.info("Loading branch history.");
            return loadBranchHistory(handlerParams, scmInstance);
        });
        //2.4 Get all commits effected each file
        if (buildArguments.sendContributors) {
            promiseChain = promiseChain.then(function (mapping) {
                log.info("Getting commits per file.");
                return getCommitsPerFile(handlerParams, scmInstance);
            });
        }
        //2.5 if commit was not specified, automatically detect it
        if (!buildArguments.commit) {
            promiseChain = promiseChain.then(function () {
                log.info("Couldn't find a 'commit' on the 'buildArguments'. Trying to detect the commit version.");
                return scmInstance.detectCommitVersion(handlerParams, log).then(function (commit) {
                    if (commit) {
                        handlerParams.finalOutput.meta.commit = commit;
                    }
                });
            });
        }
        //2.6 Find repository root directory
        promiseChain = promiseChain.then(function () {
            return scmInstance.getRootDirectory(handlerParams, log).then(function (rootDir) {
                handlerParams.scmRootDir = rootDir;
                handlerParams.projectRoot = resolveProjectRoot(logger, diagnostic, buildArguments.projectRoot, handlerParams.scmRootDir);
            });
        });
        //2.6 Get list of all files in git or fs
        promiseChain = promiseChain.then(function () {
            return scmInstance.getFiles(handlerParams, log).then(function (scmFiles) {
                if (scmFiles && Array.isArray(scmFiles)) {
                    return ScmFilesContainer.createWithFiles(logger, scmFiles);
                }
                else {
                    return FilesContainer.create(logger, handlerParams.projectRoot, buildArguments.excludedFiles);
                }
            })
                .then(filesContainer => {
                handlerParams.filesContainer = filesContainer;
            });
        });
        // Get additional git details, like current branch and open branches if additionalGitDetails is enabled
        if (buildArguments.additionalGitDetails) {
            handlerParams.finalOutput.meta.additionalGitDetails = {};
            promiseChain = promiseChain.then(function () {
                return scmInstance.getCurrentGitBranch(handlerParams, log).then(function (currentBranch) {
                    handlerParams.finalOutput.meta.additionalGitDetails.currentBranch = currentBranch;
                });
            });
            promiseChain = promiseChain.then(function () {
                return scmInstance.getOpenGitBranches(handlerParams, log).then(function (openBranches) {
                    handlerParams.finalOutput.meta.additionalGitDetails.openBranches = openBranches;
                });
            });
            // Check if workflow includes git submodules
            promiseChain = promiseChain.then(function () {
                return scmInstance.getGitSubmodules(handlerParams, log).then(function (submodules) {
                    handlerParams.finalOutput.meta.additionalGitDetails.submodules = submodules;
                });
            });
        }
        return promiseChain;
    }
    this.run = function run(buildArguments) {
        return createBuildDiffPromiseChain(buildArguments);
    };
    function runBrowserInstrumentation(log, instrumentationConfig, callback, slMapper) {
        log.info("Running browser instrumentation.");
        instrumentationConfig.extensionsToInstrument = dvr.getFileExtensions();
        var bi = new BrowserInstrumenter(instrumentationConfig, log, slMapper);
        bi.instrument(callback);
    }
    function loadBranchHistory(handlerParams, scmInstance) {
        return scmInstance.getBranchHistory(handlerParams, log).then(function (gitLog) {
            if (gitLog && gitLog.commitHistory && gitLog.commitHistory.length && gitLog.commitLog && gitLog.commitLog.length) {
                log.info('Branch history loaded (' + gitLog.commitHistory.length + ' commits)');
                handlerParams.finalOutput.meta.history = gitLog.commitHistory;
                handlerParams.finalOutput.meta.commitLog = gitLog.commitLog;
            }
            else {
                logBranchHistoryNotFound(gitLog, log);
            }
            return loadCommitIndexMap(gitLog, handlerParams, log);
        });
    }
    function getRepositoryUrl(handlerParams, scmInstance) {
        return scmInstance.getRepositoryUrl(handlerParams, log).then(function (repositoryUrl) {
            if (repositoryUrl) {
                log.info('Repository Url loaded (' + repositoryUrl + ')');
                handlerParams.finalOutput.meta.repositoryUrl = repositoryUrl;
            }
            return repositoryUrl;
        });
    }
    function getContributors(handlerParams, scmInstance) {
        return scmInstance.getContributors(handlerParams, log).then(function (contributorsLog) {
            if (contributorsLog && contributorsLog.contributors && contributorsLog.emailToIndexMap) {
                log.info('Contributors list loaded (' + contributorsLog.contributors.length + ' contributors)');
                handlerParams.finalOutput.meta.contributors = contributorsLog.contributors;
                handlerParams.emailToIndexMap = contributorsLog.emailToIndexMap;
            }
            else {
                logContributorsNotFound(contributorsLog, log);
            }
            return contributorsLog;
        });
    }
    function getCommitsPerFile(handlerParams, scmInstance) {
        return scmInstance.getCommitsPerFile(handlerParams, log).then(function (fileToCommitsMap) {
            if (fileToCommitsMap != null) {
                log.info('File commit map loaded (' + Object.keys(fileToCommitsMap).length + ' records)');
                handlerParams.fileToCommitsMap = fileToCommitsMap;
            }
            else {
                log.error("Commits map is null or undefined.");
            }
            return fileToCommitsMap;
        });
    }
}
function logContributorsNotFound(contributorsLog, log) {
    var fieldsMap = {
        contributorsLog: !contributorsLog,
        contributors: contributorsLog && !contributorsLog.contributors,
        emailToIndexMap: contributorsLog && !contributorsLog.emailToIndexMap
    };
    var missing = utils.getMissingProperties(fieldsMap);
    log.error("Contributors list not loaded, missing fields: " + missing);
}
function logBranchHistoryNotFound(gitLog, log) {
    var fieldsMap = {
        gitLog: !gitLog,
        commitHistory: gitLog && !gitLog.commitHistory,
        commitHistoryLength: gitLog && gitLog.commitHistory && !gitLog.commitHistory.length,
        commitLog: gitLog && !gitLog.commitLog,
        commitLogLength: gitLog && gitLog.commitLog && !gitLog.commitLog.length
    };
    var missing = utils.getMissingProperties(fieldsMap);
    log.error("Branch history not loaded, missing fields: " + missing);
}
function clone(o) {
    //if (!o) return o; //Unreachable
    return JSON.parse(JSON.stringify(o));
}
var getProcessedFiles = function (buildArguments, processedFiles, logger) {
    var folderToScan = buildArguments.workspacepath;
    return fileAndFolderUtils.scanDirRecursively(folderToScan, logger);
};
var loadCommitIndexMap = function (gitLog, handlerParams, log) {
    if (!handlerParams.buildArguments.sendContributors) {
        return gitLog;
    }
    if (gitLog && gitLog.commitToIndexMap) {
        handlerParams.commitToIndexMap = gitLog.commitToIndexMap;
    }
    else {
        log.error("Commit log index map not loaded");
    }
    return gitLog;
};
function createMetaTag(buildArguments) {
    return {
        "generated": new Date().valueOf(),
        "build": buildArguments.build,
        "commit": buildArguments.commit,
        "customerId": buildArguments.customerId,
        "appName": buildArguments.appname,
        //"technologies": "nodejs",
        "technology": "nodejs",
        "branch": buildArguments.branch,
        "environment": {
            agentVersion: version,
            agentType: "nodeJsBuildScanner",
            processArgv: process.argv,
            machineName: os.hostname(),
            platform: os.platform(),
            os: os.type(),
            osVersion: os.release(),
            arch: os.arch(),
            processId: process.pid,
            ipAddress: clone(os.networkInterfaces()),
            dependencies: clone(process.versions),
            runtime: process.version
        },
        "authors": buildArguments.author,
        "logsUrl": buildArguments.logsUrl,
        "jobName": buildArguments.jobName,
        "moduleName": buildArguments.uniqueModuleId,
        "uniqueModuleId": buildArguments.uniqueModuleId,
        "configurationData": buildArguments,
        "scmProvider": buildArguments.scmProvider,
        "scmVersion": buildArguments.scmVersion,
        "scmBaseUrl": buildArguments.scmBaseUrl,
        "buildSessionId": buildArguments.buildSessionId
    };
}
function countElements(files) {
    const counters = {
        methods: 0,
        branches: 0,
        files: (files === null || files === void 0 ? void 0 : files.length) || 0
    };
    files === null || files === void 0 ? void 0 : files.forEach(file => {
        var _a, _b;
        counters.methods += ((_a = file.methods) === null || _a === void 0 ? void 0 : _a.length) || 0;
        counters.branches += ((_b = file.branches) === null || _b === void 0 ? void 0 : _b.length) || 0;
    });
    return counters;
}
function resolveProjectRoot(logger, diagnosticCollector, cliOption, scmRootDir) {
    let projectRoot;
    if (cliOption) {
        const normalizedRoot = path.normalize(cliOption);
        if (utils.isAbsolutePath(normalizedRoot)) {
            // absolute path is fine
            projectRoot = normalizedRoot;
        }
        else {
            // relative path should be resolved first
            projectRoot = path.resolve(process.cwd(), normalizedRoot);
        }
        diagnosticCollector.projectRootResolved(projectRoot, 'command-argument');
        logger.info(`Project root set to '${projectRoot}' from 'sourceRoot'`);
    }
    else if (scmRootDir) {
        projectRoot = scmRootDir;
        diagnosticCollector.projectRootResolved(projectRoot, 'scm');
        logger.info(`Project root set to '${projectRoot}' same as git root`);
    }
    else {
        projectRoot = process.cwd();
        diagnosticCollector.projectRootResolved(projectRoot, 'cwd');
        logger.info(`Project root set to '${projectRoot}' same as CWD`);
    }
    return utils.adjustPathSlashes(projectRoot);
}
module.exports.BuildDiffProcess = BuildDiffProcess;
//# sourceMappingURL=build-diff-process.js.map