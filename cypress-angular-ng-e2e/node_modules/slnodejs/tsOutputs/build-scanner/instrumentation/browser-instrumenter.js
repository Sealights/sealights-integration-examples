var mkdirp = require('mkdirp');
var async = require('async');
const os = require('os');
var fileAndFolderUtils = require('../file-and-folder-utils');
const { CliProgress } = require("../../common/cli-progress");
var ValidationUtils = require("../../common/utils/validation-utils").ValidationUtils;
var MessagesFormatter = require("../../common/messages-formatter").MessagesFormatter;
var ConfigLoader = require("../../common/config-process/config-loader").ConfigLoader;
var SlEnvVars = require("../../common/constants/sl-env-vars").SlEnvVars;
var Constants = require("../../common/constants/constants").Constants;
const { FilesInstrumenter, IFilesInstrumenterParams } = require("./files-instrumenter");
const { CockpitNotifier } = require("../../common/agent-events/cockpit-notifier");
const { AgentEventCode } = require("../../common/agent-events/agent-events-contracts");
var CiaEnvVars = SlEnvVars.CIA;
const { OUT_OF_MEMORY } = require("./process-pool/contracts");
const PARALLALIZATION_THRESHOLD = 0;
const OUT_OF_MEMORY_DOCUMENTATION_URL = 'https://sealights.atlassian.net/wiki/spaces/SUP/pages/561905721/NodeJS+-+JavaScript+heap+out+of+memory';
/**
 * * This class responsible to instrument a set of files with Sealights information.
 * @param {* Instrumentation options} opts
 * @param {* A logger} logger
 */
function BrowserInstrumenter(opts, logger, slMapper) {
    ValidationUtils.verifyNotNullOrEmpty(opts, "opts");
    ValidationUtils.verifyNotNullOrEmpty(logger, "logger");
    ValidationUtils.verifyNotNullOrEmpty(slMapper, "slMapper");
    this.cliProgress = new CliProgress(logger);
    this.opts = opts;
    this.logger = logger;
    this.slMapper = slMapper;
    this.files = {
        instrumented: [],
        notInstrumented: [],
        withInstrumentationErrors: [],
        withCopyErrors: []
    };
}
BrowserInstrumenter.prototype.instrument = function (callback) {
    const _this = this;
    ValidationUtils.verifyNotNullOrEmpty(callback, "callback");
    try {
        var err = this._validate(callback);
        const origCallback = callback;
        callback = function (...args) {
            var _a, _b;
            (_b = (_a = _this.cliProgress) === null || _a === void 0 ? void 0 : _a.stop) === null || _b === void 0 ? void 0 : _b.call(_a);
            origCallback(...args);
        };
        if (err) {
            this.logger.error(`Instrumentation failed due to invalid input. Error: ${err}`);
            return callback(err);
        }
        var hasPhysicalFiles = this.opts.files && this.opts.files.length > 0;
        if (!hasPhysicalFiles) {
            this.logger.warn("Didn't find any files which require instrumentation. Skipping browser instrumentation.");
            return callback();
        }
        this.logger.info("Starting instrumentation process.");
        this._processFiles(function () {
            _this._onComplete(callback);
        });
    }
    catch (e) {
        this.logger.error(`Failed during instrumentation. Error: ${e}`);
        return callback(e);
    }
};
BrowserInstrumenter.prototype._printSummaries = function () {
    var summary = "Instrumentation summary:" +
        "\n\tInstrumented files: " + this.files.instrumented.length +
        "\n\tFiles copied as is (not instrumented): " + this.files.notInstrumented.length +
        "\n\tFiles with instrumentation errors: " + this.files.withInstrumentationErrors.length +
        "\n\tFiles with copy errors: " + this.files.withCopyErrors.length;
    this.logger.info(summary);
};
BrowserInstrumenter.prototype._onComplete = function (callback) {
    var _this = this;
    if (this.opts.copyAllFilesToOutput) {
        fileAndFolderUtils.copyDir(this.opts.sourceRoot, this.opts.outputPath, this.opts.files, function (err) {
            _this.logger.info(`Finished copying all files to output. Error: ${err}`);
            _this._printSummaries();
            return callback(err, _this.files);
        });
    }
    else {
        _this._printSummaries();
        return callback(null, _this.files);
    }
};
BrowserInstrumenter.prototype._onFileCopied = function (inputFile) {
    this.files.notInstrumented.push(inputFile);
    this.logger.debug(`File '${inputFile}' copied successfully.`);
};
BrowserInstrumenter.prototype._onFileCopyError = function (inputFile, errorMsg) {
    this.files.withCopyErrors.push({
        file: inputFile,
        error: errorMsg
    });
    this.logger.warn(`Had error while coping '${inputFile}'. ${errorMsg}.`);
};
BrowserInstrumenter.prototype._onFileWithInstrumentationError = function (inputFile, errorMsg) {
    this.files.withInstrumentationErrors.push({
        file: inputFile,
        error: errorMsg
    });
    this.logger.warn(`Had error while processing '${inputFile}'. ${errorMsg}. File will be copied as is.`);
};
BrowserInstrumenter.prototype._onFileInstrumented = function (inputFile) {
    this.files.instrumented.push(inputFile);
    this.logger.debug(`Processed '${inputFile}'.`);
};
BrowserInstrumenter.prototype._validate = function (callback) {
    var opts = this.opts;
    if (opts.instrumentationType != "browser") {
        return new Error("instrumentationType must be 'browser'");
    }
    if (!opts.extensionsToInstrument || opts.extensionsToInstrument.length === 0) {
        return new Error("'extensionsToInstrument' must specified");
    }
    var hasPhysicalFiles = opts.files && opts.files.length > 0;
    if (hasPhysicalFiles) {
        if (!opts.outputPath) {
            return new Error("outputPath was not specified");
        }
        if (!opts.sourceRoot) {
            return new Error("sourceRoot was not specified");
        }
    }
    if (!opts.server) {
        return new Error("server was not specified");
    }
    if (!opts.token) {
        return new Error("token was not specified");
    }
    if (!opts.customerId) {
        return new Error("customerId was not specified");
    }
    if (!opts.workspacepath) {
        return new Error("workspacepath was not specified");
    }
    //All good.
    return null;
};
function addHtmlTag(preambleHeader, sourceUrl, loadedFlag) {
    preambleHeader.push("if(!window.$Sealights." + loadedFlag + " && !" + Constants.SKIP_BROWSER_AGENT + ") {", "   var script   = document.createElement(\"script\");", "   script.type  = \"text/javascript\";", "   script.src   = \"" + sourceUrl + "\";", "   var head     = document.head || document.getElementsByTagName && document.getElementsByTagName('head')[0]", "   if (head) { head.appendChild(script); window.$Sealights." + loadedFlag + " = true; } else { /* Unsupported/restricted browser */ }", "}");
}
BrowserInstrumenter.prototype._createPreamble = function () {
    var opts = this.opts;
    var agentUrl = opts.collectorUrl || opts.server;
    if (agentUrl[agentUrl.length] != '/')
        agentUrl += '/';
    agentUrl += 'v1/agents/browser/recommended?redirect=1&customerId=' + encodeURIComponent(opts.customerId);
    var workspacePath = opts.workspacepath;
    if (CiaEnvVars.getSourceRoot() != null) {
        workspacePath = CiaEnvVars.getSourceRoot();
        this.logger.info("Overriding 'workspacepath' with 'Source Root'. Old: '" + opts.workspacepath + "', New: '" + workspacePath + "'.");
    }
    var lastChar = workspacePath[workspacePath.length - 1];
    if (lastChar != "\\" && lastChar != "/") {
        workspacePath = workspacePath + "/";
    }
    var config = JSON.stringify(this.createConfigObject(opts, workspacePath), null, '  ');
    var slConfigVar = "slConfig";
    var preambleHeader = [
        "var " + slConfigVar + " = " + config + ";\n" +
            "window.$Sealights = window.$Sealights || {};\n" +
            "if(window && window.$SealightsAgent){\n" +
            "   window.$SealightsAgent.createInstance(" + slConfigVar + ")\n" +
            "} else {\n" +
            "   window.$Sealights.components = window.$Sealights.components || {};\n" +
            "   window.$Sealights.components[\"" + this.opts.buildSessionId + "\"] = " + slConfigVar + ";" +
            "   document.addEventListener(\"DOMContentLoaded\", function(event) {\n" +
            "       document.body.dataset.components = JSON.stringify(window.$Sealights.components || {});\n" +
            "   });" +
            "}"
    ];
    if (this.slMapper && opts.slMappingUrl) {
        this.slMapper.writeToFile();
        addHtmlTag(preambleHeader, opts.slMappingUrl, "slMappingAdded");
    }
    if (opts.downloadAgent == true) {
        addHtmlTag(preambleHeader, agentUrl, "scriptAdded");
    }
    return preambleHeader;
};
BrowserInstrumenter.prototype._processFiles = function (callback) {
    var _a, _b;
    const relativeNames = this.opts.files;
    const preambleHeader = this._createPreamble();
    this.logger.info(`Starting to process files. Number of files to process: ${relativeNames.length}`);
    var extensions = {};
    this.opts.extensionsToInstrument.map(function (ext) {
        extensions[ext] = true;
    });
    this.opts.extensionsToInstrument = extensions;
    (_b = (_a = this.cliProgress) === null || _a === void 0 ? void 0 : _a.start) === null || _b === void 0 ? void 0 : _b.call(_a, {
        total: relativeNames.length,
        startValue: 0
    });
    //Verify the output folder exists
    if (this.opts.outputPath) {
        mkdirp.sync(this.opts.outputPath);
    }
    const experimentalSizeReduction = this.opts.experimentalSizeReduction || CiaEnvVars.useExperimentalSizeReduction();
    // TODO - remove after new instrumenter has enough usage.
    const newInstrumenter = this.opts.newInstrumenter || CiaEnvVars.useNewInstrumenter();
    //const shouldForceInstrumentationFileSizeReduction = !this.opts.usebranchcoverage && !CiaEnvVars.reduceInstrumentedFileSize();
    const config = {
        useRelativeSlMapping: this.opts.useRelativeSlMapping,
        workspacePath: this.opts.workspacepath,
        buildSessionId: this.opts.buildSessionId,
        esModules: !!this.opts.esModules,
        sourceRoot: this.opts.sourceRoot,
        outputPath: this.opts.outputPath,
        excludedPaths: this.opts.excludedPaths,
        extensionsToInstrument: this.opts.extensionsToInstrument,
        shouldMinifyInstrumentedOutput: CiaEnvVars.minifyInstrumentedOutput(),
        shouldReduceInstrumentedFileSize: CiaEnvVars.reduceInstrumentedFileSize(),
        //shouldReduceInstrumentedFileSize: CiaEnvVars.reduceInstrumentedFileSize() || shouldForceInstrumentationFileSizeReduction,
        omitInstrumentedFunctionMap: CiaEnvVars.omitInstrumentedFunctionMap(),
        experimentalSizeReduction,
        //experimentalSizeReduction: experimentalSizeReduction || shouldForceInstrumentationFileSizeReduction,
        useBranchCoverage: this.opts.usebranchcoverage,
        babylonPlugins: this.opts.babylonPlugins || [],
        excludeSourceMapFiles: this.opts.excludeSourceMapFiles,
        newInstrumenter
    };
    const numOfCpu = os.cpus().length;
    const ProcessPool = this.tryImportProcessPool();
    const isEnoughFilesForParallalization = relativeNames.length > PARALLALIZATION_THRESHOLD;
    const shouldUseWorkers = !CiaEnvVars.inProcessInstrumentation() && isEnoughFilesForParallalization && ProcessPool;
    let pool = null;
    let filesInstrumenter = null;
    if (shouldUseWorkers) {
        this.logger.info(`Run instrumentation in ${numOfCpu} threads`);
        pool = new ProcessPool(numOfCpu, {
            config,
            preambleHeader,
        }, this.logger);
        pool.initSubprocesses();
    }
    else {
        filesInstrumenter = new FilesInstrumenter(config, preambleHeader, this.logger, CockpitNotifier);
    }
    const startTime = new Date().getTime();
    let count = 0;
    q = async.queue((filename, cb) => {
        Promise.resolve()
            .then(() => {
            const skipInstrumentation = this.files.withInstrumentationErrors.some(x => x.file === filename);
            if (shouldUseWorkers) {
                return pool.runInstrumentationTask({ inputFile: filename, skipInstrumentation });
            }
            return filesInstrumenter.processSingleFileAsync(filename, skipInstrumentation);
        })
            .then(result => {
            if (result.isInstrumented) {
                this._onFileInstrumented(result.filename);
            }
            if (result.isInstrumentationError) {
                this._onFileWithInstrumentationError(result.filename, result.instrumentationErrorMessage);
            }
            if (result.isCopied) {
                this._onFileCopied(result.filename);
            }
            if (result.isCopyError) {
                this._onFileCopyError(result.filename, result.copyErrorMessage);
            }
            cb && cb(null, result);
        })
            .catch(error => {
            if (error.message === OUT_OF_MEMORY) {
                const cockpitMessage = `Got out of memory while instrumenting file '${filename}'.
More memory can by provided by using '--max_old_space_size'. for more information please see ${OUT_OF_MEMORY_DOCUMENTATION_URL}`;
                CockpitNotifier.sendError(cockpitMessage);
            }
            else {
                this.logger.error(error.message);
            }
            CockpitNotifier.sendEvent(AgentEventCode.STATIC_INSTRUMENTATION_ERROR);
            this._onFileWithInstrumentationError(filename, error.message);
            q.push(filename, () => { });
            cb && cb(error, null);
        });
    }, numOfCpu),
        q.push(relativeNames, (err, name) => {
            var _a, _b;
            (_b = (_a = this.cliProgress) === null || _a === void 0 ? void 0 : _a.update) === null || _b === void 0 ? void 0 : _b.call(_a, { currentValue: count + 1 });
            count += 1;
        });
    q.drain = () => {
        this.logger.info('Draining the Queue.');
        pool === null || pool === void 0 ? void 0 : pool.close();
        var endTime = new Date().getTime();
        this.logger.info(`Processed [${count}] files in ${Math.floor((endTime - startTime) / 1000)} secs`);
        if (this.files.withCopyErrors.length > 0) {
            this.logger.warn(`The following ${this.files.withCopyErrors.length} file(s) had errors and were copied as-is:\n ${this._formatErrorMessage(this.files.withCopyErrors)}`);
        }
        callback && callback();
    };
};
BrowserInstrumenter.prototype._formatErrorMessage = function (fileWithErrors) {
    var messageFormatter = new MessagesFormatter();
    var counter = 1;
    fileWithErrors.forEach(function (f) {
        var msg = "[" + counter++ + "] '" + f.file + "'. Error: '" + f.error;
        messageFormatter.addContent(msg);
    });
    return messageFormatter.content;
};
BrowserInstrumenter.prototype.createConfigObject = function (opts, workspacePath) {
    // Should load all env vars starting With 'SL_'
    var agentConfig = new ConfigLoader().loadAgentConfiguration();
    // TODO - why don't we copy opts as a whole and just override the fields that require logic?
    return {
        customerId: opts.customerId,
        appName: opts.appName,
        buildName: opts.build,
        branchName: opts.branch,
        server: opts.server,
        token: opts.token,
        buildSessionId: opts.buildSessionId,
        labId: opts.labId,
        collectorUrl: opts.collectorUrl,
        enabled: true,
        workspacepath: workspacePath,
        maxItemsInQueue: 500,
        registerShutdownHook: true,
        interval: 10,
        resolveWithoutHash: opts.resolveWithoutHash,
        delayShutdownInSeconds: opts.delayShutdownInSeconds,
        isUseNewUniqueId: SlEnvVars.isUseNewUniqueId(),
        footprintsEnableV6: agentConfig.footprintsEnableV6.value,
        footprintsBufferThresholdMb: agentConfig.footprintsBufferThresholdMb.value,
        footprintsCollectIntervalSecs: agentConfig.footprintsCollectIntervalSecs.value,
        footprintsSendIntervalSecs: agentConfig.executionQueryIntervalSecs.value,
        executionQueryIntervalSecs: agentConfig.executionQueryIntervalSecs.value,
        footprintsQueueSize: agentConfig.footprintsQueueSize.value,
        blockBrowserHttpTraffic: SlEnvVars.blockBrowserHttpTraffic(),
        enableOpenTelemetry: opts.enableOpenTelemetry,
        allowCORS: opts.allowCORS,
        footprintsMapping: opts.footprintsMapping,
        removeSensitiveData: opts.removeSensitiveData,
        experimentalSizeReduction: opts.experimentalSizeReduction,
    };
};
BrowserInstrumenter.prototype.tryImportProcessPool = function () {
    try {
        const { ProcessPool } = require('./process-pool/process-pool');
        return ProcessPool;
    }
    catch (e) {
        this.logger.error(`Could not import ProcessPool, using in process instrumentation. Error: ${e} `);
        return null;
    }
};
module.exports = BrowserInstrumenter;
//# sourceMappingURL=browser-instrumenter.js.map