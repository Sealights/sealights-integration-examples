"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilesInstrumenter = void 0;
const path = require("path");
const mkdirp_1 = require("mkdirp");
const fs = require("fs");
const fileAndFolderUtils = require("../file-and-folder-utils");
const ignored_files_handler_1 = require("../../common/ignored-files-handler");
const utils = require("../utils");
const content_instrumenter_1 = require("./content-instrumenter");
const copy_as_is_strategy_1 = require("./strategies/copy-as-is-strategy");
const js_instrumnetation_strategy_1 = require("./strategies/js-instrumnetation-strategy");
const markup_instrumnetation_strategy_1 = require("./strategies/markup-instrumnetation-strategy");
const validation_utils_1 = require("../../common/utils/validation-utils");
const factory_1 = require("../source-map-eraser/factory");
class FilesInstrumenter {
    constructor(params, preambleHeader, logger, cockpitNotifier) {
        this.params = params;
        this.preambleHeader = preambleHeader;
        this.logger = logger;
        this.cockpitNotifier = cockpitNotifier;
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(params, 'params');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(preambleHeader, 'preambleHeader');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(logger, 'logger');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(cockpitNotifier, 'cockpitNotifier');
        this.sourceMapsEraser = factory_1.SourceMapEraserFactory.createSourceMapEraserByMode(params.excludeSourceMapFiles, logger, params.workspacePath);
        this.ignoredFilesHandler = this.createIgnoreHandler(ignored_files_handler_1.IgnoredFilesHandler.SCAN_IGNORE_FILE_NAME);
        this.instrumenter = new content_instrumenter_1.ContentInstrumenter({
            buildSessionId: params.buildSessionId,
            esModules: params.esModules,
            instrumentLineLevel: !params.shouldReduceInstrumentedFileSize,
            newInstrumenter: params.newInstrumenter
        });
        this.copyAsIsStrategy = new copy_as_is_strategy_1.CopyAsIsStrategy(this.logger);
        this.jsFileInstrumentationStrategy = new js_instrumnetation_strategy_1.JsFileInstrumentationStrategy(params, this.instrumenter, this.preambleHeader, this.logger, this.cockpitNotifier);
        this.markupFileInstrumentationStrategy = new markup_instrumnetation_strategy_1.MarkupFileInstrumentationStrategy(params, this.instrumenter, this.preambleHeader, this.logger, this.cockpitNotifier);
    }
    createIgnoreHandler(ignoreFileName) {
        const slIgnoreScanFilePath = fileAndFolderUtils.findFileRecursively(ignoreFileName, this.params.workspacePath, true, this.logger);
        return new ignored_files_handler_1.IgnoredFilesHandler(slIgnoreScanFilePath, this.params.outputPath, this.params.excludedPaths, ignoreFileName, this.logger);
    }
    processSingleFileAsync(filePath, skipInstrumentation = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Processing file: ${filePath}`);
            const inputFile = this.getInputFile(filePath);
            const outputFile = this.getOutputFile(filePath);
            const fileKey = utils.toRelativePath(inputFile, this.params.useRelativeSlMapping, this.params.workspacePath);
            const fileInstrumentationResult = {
                filename: fileKey,
                isInstrumented: false,
                isInstrumentationError: false,
                instrumentationErrorMessage: null,
                isCopied: false,
                isCopyError: false,
                copyErrorMessage: null,
            };
            const outputDir = path.dirname(outputFile);
            mkdirp_1.mkdirp.sync(outputDir);
            if (fs.statSync(inputFile).isDirectory()) {
                this.logger.info(`Input file '${inputFile}' is a directory. No need to process`);
                return fileInstrumentationResult;
            }
            const inputFileExtension = path.extname(inputFile);
            const isValidExtension = this.params.extensionsToInstrument[inputFileExtension] || utils.isMarkupFile(inputFileExtension);
            const shouldInstrumentFile = isValidExtension && this.isFileAcceptedBySlIgnore(filePath) && !skipInstrumentation;
            if (shouldInstrumentFile) {
                try {
                    if (utils.isMarkupFile(inputFileExtension)) {
                        yield this.markupFileInstrumentationStrategy.process(inputFile, outputFile, fileKey);
                    }
                    else {
                        yield this.jsFileInstrumentationStrategy.process(inputFile, outputFile, fileKey);
                    }
                    fileInstrumentationResult.isInstrumented = true;
                    return fileInstrumentationResult;
                }
                catch (error) {
                    const errMessage = `${error.message} File: '${filePath}. Error: ${error}`;
                    fileInstrumentationResult.instrumentationErrorMessage = errMessage;
                    fileInstrumentationResult.isInstrumentationError = true;
                }
            }
            if (!shouldInstrumentFile || fileInstrumentationResult.isInstrumentationError) {
                try {
                    if (this.sourceMapsEraser.isShouldSkipCopy(filePath)) {
                        throw new Error(`File skipped due to source maps skip mode ${this.excludeSourceMapFiles}`);
                    }
                    yield this.copyAsIsStrategy.process(inputFile, outputFile, fileKey);
                    fileInstrumentationResult.isCopied = true;
                    return fileInstrumentationResult;
                }
                catch (error) {
                    const errMessage = `${error.message} File: '${filePath}. Error: ${error}`;
                    fileInstrumentationResult.copyErrorMessage = errMessage;
                    fileInstrumentationResult.isCopyError = true;
                }
            }
            return fileInstrumentationResult;
        });
    }
    getInputFile(filePath) {
        const folder = this.params.sourceRoot;
        return path.resolve(folder, filePath);
    }
    getOutputFile(filePath) {
        const folder = this.params.outputPath;
        return path.resolve(folder, filePath);
    }
    isFileAcceptedBySlIgnore(filePath) {
        if (this.ignoredFilesHandler.denies(filePath)) {
            this.logger.info(`File '${filePath}' ignored by .slignore, will be copied as is`);
            return false;
        }
        return true;
    }
}
exports.FilesInstrumenter = FilesInstrumenter;
//# sourceMappingURL=files-instrumenter.js.map