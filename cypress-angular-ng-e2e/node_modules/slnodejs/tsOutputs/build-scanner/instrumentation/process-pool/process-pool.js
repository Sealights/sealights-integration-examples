"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessPool = void 0;
const events_1 = require("events");
const path = require("path");
const child_process_1 = require("child_process");
const split_by_transform_stream_1 = require("./split-by-transform-stream");
const cockpit_notifier_1 = require("../../../common/agent-events/cockpit-notifier");
const contracts_1 = require("./contracts");
const stop_by_condition_transform_stream_1 = require("./stop-by-condition-transform-stream");
const kTaskInfo = Symbol('instrumentationTask');
const kProcessFreedEvent = Symbol('kProcessFreedEvent');
const OUT_OF_MEMORY_PATTERN = 'JavaScript heap out of memory';
class InstrumentationTask {
    constructor(callback) {
        this.callback = callback;
    }
    done(result) {
        this.callback(null, result);
    }
    fail(error) {
        this.callback(error, null);
    }
}
class ProcessPool extends events_1.EventEmitter {
    constructor(numProcesses, processOptions, logger) {
        super();
        this.numProcesses = numProcesses;
        this.logger = logger;
        this.processes = [];
        this.freeProcesses = [];
        this.processOptions = '';
        this.processOptions = JSON.stringify(processOptions);
    }
    initSubprocesses() {
        for (let i = 0; i < this.numProcesses; i++) {
            this.addNewProcess();
        }
    }
    addNewProcess() {
        const pathToInstrumenter = path.resolve(__dirname, 'instrumenter-spawn.js');
        const subprocess = (0, child_process_1.fork)(pathToInstrumenter, [this.processOptions], { silent: true });
        this.logger.info(`Subrocess with pid - ${subprocess.pid} was started`);
        const subprocessPrefix = `Subprocess [${subprocess.pid}]: `;
        subprocess.on('message', (data) => {
            var _a;
            if (data.type === contracts_1.PROCESS_MESSAGE_TYPE.INSTRUMENTATION_RESULT) {
                // In case of success: Call the callback that was passed to `runTask`,
                // remove the `TaskInfo` associated with the Worker, and mark it as free
                // again.
                (_a = subprocess[kTaskInfo]) === null || _a === void 0 ? void 0 : _a.done(data.payload);
                subprocess[kTaskInfo] = null;
                this.emitFreeProcess(subprocess);
                return;
            }
            if (data.type === contracts_1.PROCESS_MESSAGE_TYPE.LOG) {
                const logMessage = data.payload;
                this.logger.log(logMessage.level, logMessage.label + ' ' + logMessage.message);
                return;
            }
            if (data.type === contracts_1.PROCESS_MESSAGE_TYPE.COCKPIT_NOTIFY) {
                cockpit_notifier_1.CockpitNotifier.sendError(subprocessPrefix + data.payload.message);
                return;
            }
            this.logger.info(`${subprocessPrefix} unprocessed message - ${JSON.stringify(data)}`);
        });
        subprocess.on('exit', (_data) => {
            var _a;
            this.logger.info(`Subrocess with pid - ${subprocess.pid} was closed`);
            // In case if process have active task: Call the callback that was passed to `runTask`
            // process will be closed without reopening
            if (subprocess[kTaskInfo]) {
                (_a = subprocess[kTaskInfo]) === null || _a === void 0 ? void 0 : _a.fail(new Error(`Cancelled due to unexpected closing of process`));
                subprocess[kTaskInfo] = null;
            }
            const processIndex = this.processes.indexOf(subprocess);
            if (processIndex != -1) {
                this.processes.splice(processIndex, 1);
            }
        });
        // this listener doesn't trigger on oom exeption so we a waiting for synthetic error
        subprocess.on('error', err => {
            var _a;
            // works fine for node >= 12, versions 8 and 10 doesn't send any error when child_process is out of memory
            if (err.message === contracts_1.OUT_OF_MEMORY) {
                this.logger.error(subprocessPrefix + err.message);
                if (subprocess[kTaskInfo]) {
                    (_a = subprocess[kTaskInfo]) === null || _a === void 0 ? void 0 : _a.fail(err);
                    subprocess[kTaskInfo] = null;
                    const processIndex = this.processes.indexOf(subprocess);
                    if (processIndex != -1) {
                        this.processes.splice(processIndex, 1);
                    }
                    this.addNewProcess();
                }
            }
            else {
                this.logger.error(subprocessPrefix + err.message);
            }
        });
        const splitByLines = new split_by_transform_stream_1.SplitByTransformStream('\n');
        const stopIfOutOfMemoryDetected = new stop_by_condition_transform_stream_1.StopByConditionTransformStream(line => {
            if (line.indexOf(OUT_OF_MEMORY_PATTERN) > -1) {
                // emit synthetic oom exeption
                subprocess.emit('error', new Error(contracts_1.OUT_OF_MEMORY));
                return true;
            }
            return false;
        });
        subprocess.stderr.pipe(splitByLines).pipe(stopIfOutOfMemoryDetected).on('data', (data) => {
            const errorText = data.toString();
            this.logger.error(subprocessPrefix + errorText);
        });
        this.processes.push(subprocess);
        this.emitFreeProcess(subprocess);
    }
    runInstrumentationTask(task) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.freeProcesses.length === 0) {
                // No free threads, wait until a worker thread becomes free.
                yield this.waitForFreeProcess();
                return this.runInstrumentationTask(task);
            }
            return new Promise((resolve, reject) => {
                const subprocess = this.freeProcesses.pop();
                subprocess[kTaskInfo] = new InstrumentationTask((error, result) => {
                    if (error) {
                        return reject(error);
                    }
                    return resolve(result);
                });
                subprocess.send(task);
            });
        });
    }
    waitForFreeProcess() {
        return new Promise(resolve => {
            this.once(kProcessFreedEvent, () => resolve());
        });
    }
    emitFreeProcess(subprocess) {
        this.freeProcesses.push(subprocess);
        this.emit(kProcessFreedEvent);
    }
    close() {
        for (const subprocess of this.processes) {
            try {
                const killStatus = subprocess.kill();
                if (!killStatus) {
                    this.logger.error(`Subprocess ${subprocess.pid} wasn't killed.`);
                    subprocess.unref();
                }
            }
            catch (error) {
                this.logger.error(`Subprocess ${subprocess.pid} wasn't killed.`, error);
                subprocess.unref();
            }
        }
    }
}
exports.ProcessPool = ProcessPool;
//# sourceMappingURL=process-pool.js.map