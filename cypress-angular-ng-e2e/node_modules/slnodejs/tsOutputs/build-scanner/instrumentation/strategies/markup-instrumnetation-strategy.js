"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkupFileInstrumentationStrategy = void 0;
const fs = require("fs");
const MarkupFileParser = require("../../markup-files-parser");
const js_instrumnetation_strategy_1 = require("./js-instrumnetation-strategy");
class MarkupFileInstrumentationStrategy extends js_instrumnetation_strategy_1.JsFileInstrumentationStrategy {
    process(inputFile, outputFile, fileKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const singleMarkupFileInstrumenter = new SingleMarkupFileInstrumenter(this.logger);
            singleMarkupFileInstrumenter.extractScripts(inputFile);
            if (!singleMarkupFileInstrumenter.hasJsInFile()) {
                throw new Error('No script tags. Nothing to instrument');
            }
            singleMarkupFileInstrumenter.markScripts();
            const content = singleMarkupFileInstrumenter.getAllJsInFile();
            const instrumentedJsContent = this.instrumenter.instrumentContent(content, fileKey);
            let instrumentedContent = this.replaceOldJsByInstrumented(singleMarkupFileInstrumenter.originalFileContent, singleMarkupFileInstrumenter.originalScriptTags, instrumentedJsContent);
            instrumentedContent = this.insertCoverageCodeTag(instrumentedContent, instrumentedJsContent);
            instrumentedContent = this.postInstrumentation(instrumentedContent, fileKey);
            fs.writeFileSync(outputFile, instrumentedContent, 'utf8');
        });
    }
    replaceOldJsByInstrumented(originalFileContent, originalScriptTags, instrumentedContent) {
        let instrumentedFileContent = originalFileContent;
        for (let i = 0; i < originalScriptTags.length; i++) {
            const currentTag = originalScriptTags[i];
            const scriptMarker = createScriptMarker(i);
            let scriptStartIndex = instrumentedContent.indexOf(scriptMarker);
            scriptStartIndex += scriptMarker.length;
            const scriptEndIndex = instrumentedContent.lastIndexOf(scriptMarker);
            const instrumentedScript = instrumentedContent.substring(scriptStartIndex, scriptEndIndex);
            instrumentedFileContent = instrumentedFileContent.replace(currentTag.content, instrumentedScript);
        }
        return instrumentedFileContent;
    }
    insertCoverageCodeTag(fileContent, instrumentedJsContent) {
        const firstTagMarker = createScriptMarker(0);
        const firstTagStart = instrumentedJsContent.indexOf(firstTagMarker);
        const istanbulCoverageCode = instrumentedJsContent.substring(0, firstTagStart);
        const coverageCodeTag = `<script>\n\t${istanbulCoverageCode}\n</script>\n`;
        return this.insertTagAtBeginning(coverageCodeTag, fileContent);
    }
    addPreamble(instrumentedContent) {
        const preambleTag = `<script>\n\t${this.preamble.join('\n')}\n</script>\n`;
        return this.insertTagAtBeginning(preambleTag, instrumentedContent);
    }
    insertTagAtBeginning(newTag, instrumentedContent) {
        const firstScriptTagIndex = instrumentedContent.search(/<script[\s\S]*?>/);
        return instrumentedContent.slice(0, firstScriptTagIndex) + newTag +
            instrumentedContent.slice(firstScriptTagIndex);
    }
}
exports.MarkupFileInstrumentationStrategy = MarkupFileInstrumentationStrategy;
class SingleMarkupFileInstrumenter {
    constructor(logger) {
        this.logger = logger;
        this.originalScriptTags = [];
    }
    extractScripts(inputFile) {
        this.originalFileContent = fs.readFileSync(inputFile, 'utf8');
        this.fileParser = new MarkupFileParser(this.originalFileContent, inputFile, this.logger);
        this.fileParser.extractScriptTags();
        this.originalScriptTags = cloneTagsArray(this.fileParser.scriptTags);
    }
    hasJsInFile() {
        return this.fileParser.scriptTags.length !== 0 && isJSEmbeddedInFile(this.fileParser);
    }
    markScripts() {
        this.fileParser.scriptTags = this.fileParser.scriptTags.map((scriptTag, index) => {
            const slComment = createScriptMarker(index);
            scriptTag.content = slComment + scriptTag.content + slComment;
            return scriptTag;
        });
    }
    getAllJsInFile() {
        return this.fileParser.getAllJsInFile();
    }
}
// Checks if the js code is inside file or loaded from external js file (ie <script src="..."></script>).
function isJSEmbeddedInFile(fileParser) {
    return fileParser.getAllJsInFile() !== '';
}
function createScriptMarker(index) {
    return `/********** SL tag no ${index} **********/`;
}
// Because we add mark comments to tag scripts we want to save the original without any changes so we implement deep copy.
function cloneTagsArray(tagsArray) {
    return JSON.parse(JSON.stringify(tagsArray));
}
//# sourceMappingURL=markup-instrumnetation-strategy.js.map