var babelGenerator = require("@babel/generator");
var babelParser = require("@babel/parser");
var astTypes = require("ast-types");
var plugins = ["*", ["decorators", { decoratorsBeforeExport: true }]];
var updateStatementCoverageCommand = ".s\\[\\d+\\]\\++";
var updateBranchCoverageCommand = ".b\\[\\d+\\]\\[\\d+\\]\\++";
var updateFnMapCoverageCommand = "\\.fnMap\\[\\d+\\]\\++";
var propNameToShort = {
    start: "st",
    end: "e",
    line: "l",
    column: "c",
    name: "n",
    decl: "d",
    loc: "lc",
    type: "t",
    locations: "lcs"
};
function reduceContentSize(filename, instrumentedCode, babylonPlugins, shouldRemoveBranchCoverage, shouldMinifyOutput, logger, cockpitNotifier, useExperimentalSizeReduction, omitInstrumentedFunctionMap) {
    try {
        var ast = createAST(instrumentedCode, babylonPlugins);
        var coverageObjectNode = getCoverageObjectNode(ast);
        var coverageObjectName = coverageObjectNode.id.name;
        reduceCoverageObjectSize(coverageObjectNode, shouldRemoveBranchCoverage, omitInstrumentedFunctionMap);
        var updateStatementCoverageRegEx = new RegExp(coverageObjectName + updateStatementCoverageCommand);
        var updateBranchCoverageRegEx = new RegExp(coverageObjectName + updateBranchCoverageCommand);
        var updateFnMapCoverageCommand = new RegExp(coverageObjectName + updateFnMapCoverageCommand);
        removeRedundantUpdateCommands(ast, shouldRemoveBranchCoverage, updateStatementCoverageRegEx, updateBranchCoverageRegEx, omitInstrumentedFunctionMap, updateFnMapCoverageCommand);
        var finalContent = parseASTToCode(ast, shouldMinifyOutput);
        if (useExperimentalSizeReduction) {
            // TODO: remove after proper fix
            // patch - there's an issue with astTypes.visit which cause some of the class nodes to be marked with typescript attributes
            //        causing the output source to be unrunable in the browser.
            // finalContent = finalContent.replace(/(?<!\.)\b(implements|abstract|declare)\b(?!\.)/g, ''); 
            // finalContent = finalContent.replace(/(?<!\.)\b(implements)\b(?!\.)/g, ''); 
            // https://regex101.com/r/kcnNgg/1 - exclude matches in strings and names
            finalContent = finalContent.replace(/(?<=class\s+(\S+\s+)?(?:extends\s+\S+\s+)?)implements(?=\s*\{)/g, '').replace(/\}implements\{/g, '}{').replace(/\]implements\{/g, ']{');
        }
        validateFinalContent(finalContent, shouldRemoveBranchCoverage, updateStatementCoverageRegEx, updateBranchCoverageRegEx, omitInstrumentedFunctionMap, updateFnMapCoverageCommand);
        return finalContent;
    }
    catch (e) {
        var message = "Error while removing statement coverage from '" + filename + "' Error: '" + e + "'";
        cockpitNotifier.sendError(message);
        logger.warn(message + " Using file with statement coverage data");
        return instrumentedCode;
    }
}
function verifyUpdateCoverageRemoved(finalContent, updateStatementCoverageRegEx, coverageElement) {
    var match = finalContent.match(updateStatementCoverageRegEx);
    if (match != null) {
        throw new Error("Expected all " + coverageElement + " related expression to be removed");
    }
}
function validateFinalContent(finalContent, shouldRemoveBranchCoverage, updateStatementCoverageRegEx, updateBranchCoverageRegEx, omitInstrumentedFunctionMap, updateFnMapCoverageCommand) {
    verifyUpdateCoverageRemoved(finalContent, updateStatementCoverageRegEx, "statement");
    if (shouldRemoveBranchCoverage) {
        verifyUpdateCoverageRemoved(finalContent, updateBranchCoverageRegEx, "branch");
    }
    if (omitInstrumentedFunctionMap) {
        verifyUpdateCoverageRemoved(finalContent, updateFnMapCoverageCommand, "function map");
    }
}
function shouldConvertToEmptyObject(path, shouldRemoveBranchCoverage, omitInstrumentedFunctionMap) {
    return isStatementCoverageRelatedObject(path.value) || (shouldRemoveBranchCoverage && isBranchCoverageRelatedObject(path.value)) || (omitInstrumentedFunctionMap && isFunctionMapCoverageRelatedObject(path.value));
}
function shouldUseShortPropNames(path, shouldRemoveBranchCoverage) {
    if (path && path.key && path.key.name) {
        return path.key.name == "fnMap" || (!shouldRemoveBranchCoverage && path.key.name == "branchMap");
    }
    return isStatementCoverageRelatedObject(path.value) || (shouldRemoveBranchCoverage && isBranchCoverageRelatedObject(path.value));
}
function nodeShouldBeDeleted(path, updateStatementCoverageRegEx, shouldRemoveBranchCoverage, updateBranchCoverageRegEx, omitInstrumentedFunctionMap, updateFnMapCoverageCommand) {
    return isStatementCoverageUpdateExpresion(path.node, updateStatementCoverageRegEx) || (shouldRemoveBranchCoverage && isBranchCoverageUpdateExpresion(path.node, updateBranchCoverageRegEx))
        || (omitInstrumentedFunctionMap && isFunctionMapCoverageRelatedObject(path.node, updateFnMapCoverageCommand));
}
/**
 * Traverse over the ast and deletes statement (and branch) coverage update  commands (cov_1234.s[1]++)
 * @param ast
 * @param shouldRemoveBranchCoverage
 * @param updateStatementCoverageRegEx
 * @param updateBranchCoverageRegEx
 */
// TODO: Remove omitInstrumentedFunctionMap addition from this method, unnecessary step
function removeRedundantUpdateCommands(ast, shouldRemoveBranchCoverage, updateStatementCoverageRegEx, updateBranchCoverageRegEx, omitInstrumentedFunctionMap, updateFnMapCoverageCommand) {
    astTypes.visit(ast, {
        visitUpdateExpression(path) {
            if (nodeShouldBeDeleted(path, updateStatementCoverageRegEx, shouldRemoveBranchCoverage, updateBranchCoverageRegEx, omitInstrumentedFunctionMap, updateFnMapCoverageCommand)) {
                path.prune();
            }
            this.traverse(path);
        }
    });
}
/**
 * Traverse over the ast of the coverage object and do the followings:
 * 1. Set 'statementMap' and 's' to empty objects
 * 2. If user not use branchCoverage, remove also set also 'branchMap' and 'b' to empty projects
 * 3. Convert elements metadata (start, end, name, etc...) to short names based on 'propNameToShort'
 * @param ast
 * @param shouldRemoveBranchCoverage
 */
function reduceCoverageObjectSize(ast, shouldRemoveBranchCoverage, omitInstrumentedFunctionMap) {
    astTypes.visit(ast, {
        visitObjectProperty(path) {
            if (shouldConvertToEmptyObject(path, shouldRemoveBranchCoverage, omitInstrumentedFunctionMap)) {
                path.value.value.properties = [];
            }
            else if (shouldUseShortPropNames(path.value, shouldRemoveBranchCoverage)) {
                convertToShortPropNames(path.value);
            }
            this.traverse(path);
        }
    });
}
function convertToShortPropNames(path) {
    astTypes.visit(path, {
        visitObjectProperty(path) {
            if (path && path.value && path.value.key && path.value.key.name) {
                path.value.key.name = propNameToShort[path.value.key.name] || path.value.key.name;
            }
            this.traverse(path);
        }
    });
}
function getCoverageObjectNode(ast) {
    var coverageObject;
    astTypes.visit(ast, {
        visitVariableDeclarator(path) {
            if (path.value && path.value.id && path.value.id.name && path.value.id.name.startsWith("cov_")) {
                coverageObject = path.value;
                this.abort();
            }
            this.traverse(path);
        }
    });
    if (!coverageObject) {
        throw new Error("Could find coverage object");
    }
    return coverageObject;
}
function parseASTToCode(ast, minified) {
    try {
        return babelGenerator.default(ast, {
            comments: false,
            compact: true,
            minified: minified
        }, '').code;
    }
    catch (e) {
        throw e;
    }
}
function createAST(instrumentedCode, babylonPlugins) {
    return babelParser.parse(instrumentedCode, {
        sourceType: "unambiguous",
        plugins: plugins.concat(babylonPlugins)
    });
}
function isStatementCoverageRelatedObject(node) {
    return node && node.key && (node.key.name === "statementMap" || node.key.name === "s") && node.value;
}
function isFunctionMapCoverageRelatedObject(node) {
    return node && node.key && (node.key.name === "fnMap") && node.value;
}
function isBranchCoverageRelatedObject(node) {
    return node && node.key && (node.key.name === "branchMap" || node.key.name === "b") && node.value;
}
function isStatementCoverageUpdateExpresion(node, updateStatementCoverageRegEx) {
    var expressionCode = parseASTToCode(node, false);
    return updateStatementCoverageRegEx.test(expressionCode);
}
function isBranchCoverageUpdateExpresion(node, updateBranchCoverageRegEx) {
    var expressionCode = parseASTToCode(node, false);
    return updateBranchCoverageRegEx.test(expressionCode);
}
module.exports.reduceContentSize = reduceContentSize;
//# sourceMappingURL=instrumented-file-size-reducer.js.map