var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var mocha = require('mocha');
var Base = mocha.reporters.Base;
var utils = mocha.utils;
var inherits = utils.inherits;
var logger;
var sealights = require('../test-listener/api');
var ConfigLoader = require('../common/config-process/config-loader').ConfigLoader;
var Constants = require('./constants');
var childProcess = require('child_process');
var path = require('path');
var { CockpitNotifier } = require('../common/agent-events/cockpit-notifier');
var { SlEnvVars } = require('../common/constants/sl-env-vars');
const { OtelAgent } = require('./otel-agent');
function log(msg) {
    var args = Array.prototype.slice.apply(arguments);
    if (logger) {
        logger.info.apply(logger, args);
    }
    else {
        args[0] = '[SeaLights for Mocha] ' + args[0];
        console.log.apply(console, args);
    }
}
function warn(msg) {
    var args = Array.prototype.slice.apply(arguments);
    if (logger) {
        logger.warn.apply(logger, args);
    }
    else {
        args[0] = '[SeaLights for Mocha] ' + args[0];
        console.warn.apply(console, args);
    }
}
function error(msg) {
    var args = Array.prototype.slice.apply(arguments);
    if (logger) {
        logger.error.apply(logger, args);
    }
    else {
        args[0] = '[SeaLights for Mocha] ' + args[0];
        console.error.apply(console, args);
    }
}
/**
 * Expose `SeaLightsReporter`.
 */
exports = module.exports = SeaLightsReporter;
/**
 * Initialize a new `SeaLightsReporter` reporter.
 *
 * @param {Runner} runner
 * @api public
 */
function SeaLightsReporter(runner, options) {
    // Use for silent running during tests (Summary of test result not printed)
    if (options && options.reporterOptions && options.reporterOptions.skipEpilogue) {
        Base.prototype.epilogue = function () {
        };
    }
    Base.call(this, runner, options);
    let otelAgent;
    var reporter = this;
    var slProcess = null;
    var executionId = null;
    var shutDownTimeout = 60 * 1000; //Allow 1 minute to send all remaining footprints and events
    var counters = {
        start: 0,
        fail: 0,
        pass: 0,
        end: 0,
        skipped: 0
    };
    var warnedOnce = false;
    var reporterName = (options && options.reporterOptions && options.reporterOptions.reporter) || 'spec';
    var mochaReporters = mocha.reporters;
    var ChainedReporterType = mochaReporters.spec;
    var chainedReporter = null;
    var afterAllCalled = false;
    if (mochaReporters.hasOwnProperty(reporterName)) {
        ChainedReporterType = mochaReporters[reporterName];
    }
    else {
        try {
            ChainedReporterType = require(reporterName);
        }
        catch (e) {
            warn('Cannot find reporter ' + reporterName + ', using default Spec reporter');
            //ChainedReporterType = mochaReporters.spec; //default
        }
    }
    chainedReporter = new ChainedReporterType(runner, options);
    runner.suite.beforeEach(function (done) {
        if (!slProcess)
            return;
        otelAgent.handleBeforeEach({
            testData: { executionId },
            context: this,
            done
        });
    });
    runner.suite.afterEach(function (done) {
        if (!slProcess)
            return;
        otelAgent.handleAfterEach({
            testData: { executionId },
            context: this,
            done
        });
    });
    // Before running any suite, initialize SL and create a test execution ID
    runner.suite.beforeAll(function () {
        return __awaiter(this, void 0, void 0, function* () {
            log('Version ' + reporter.getVersion() + ', agent version ' + sealights.getVersion());
            log('Initializing');
            this.timeout((Constants.TIA_TIMEOUT + 10) * 1000); // TIA polling timeout is 60 seconds plus an extra 10 seconds
            let timeoutReached = false;
            let timer;
            const timeoutPromise = new Promise((resolve) => {
                timer = setTimeout(() => {
                    timeoutReached = true;
                    error('****** Timeout reached in beforeAll hook - skipping TIA logic ******');
                    resolve(); // Complete the Promise, even if it times out
                }, Constants.TIA_TIMEOUT * 1000); // Same value as the timeout above
            });
            const failurePromise = new Promise((resolve) => {
                runner.on('fail', (test, err) => {
                    error(err.message);
                    // Check if the failure is due to a timeout
                    if (err.message.startsWith('Timeout')) {
                        error(`****** Test "${test.title}" timed out. ******`);
                        resolve(); // Complete the Promise, even if it times out
                    }
                });
            });
            // Use Promise.race to resolve with the first settled promise (either timeoutPromise, failurePromise, or initPromise)
            yield Promise.race([timeoutPromise, failurePromise, initTestListener()]);
            if (!timeoutReached) {
                timeoutReached = true;
                clearTimeout(timer); // Clear the timer
            }
        });
    });
    // After all tests have been executed, wait for the SL process to shut down
    runner.suite.afterAll(function (done) {
        afterAllCalled = true;
        if (!slProcess)
            return done();
        otelAgent.handleAfterAll({
            testData: { executionId },
            context: this
        });
        pushExecutionEndEvent();
        slProcess.resume && slProcess.resume();
        executionId = null;
        var doneCallbackInvoked = false;
        function invokeDoneCallback(err) {
            if (doneCallbackInvoked)
                return;
            if (handle) {
                try {
                    clearTimeout(handle); //Don't keep the process running because of this timeout
                    handle = null;
                }
                catch (e) {
                    error(e);
                }
            }
            doneCallbackInvoked = true;
            if (done) {
                done(err);
            }
        }
        var handle = setTimeout(function () {
            if (doneCallbackInvoked)
                return; //callback already called
            handle = null;
            warn('Send operation timed out.');
            invokeDoneCallback();
        }, shutDownTimeout);
        this.timeout(0); //Disable mocha's timeout, since we handle the timeout here^^.
        try {
            log('Sending remaining data to server');
            slProcess.stop(invokeDoneCallback);
        }
        catch (err) {
            error('Error send remaining data to the server', err);
            invokeDoneCallback();
        }
    });
    runner.on(Constants.MOCHA.EVENT_TEST_BEGIN, function (test) {
        counters.start++;
        try {
            if (!slProcess && !warnedOnce) {
                warn('Mocha reporter was not properly intiailized.');
                warnedOnce = true;
                return;
            }
            pushTestStartEvent(test);
        }
        catch (e) {
            error('error in test event handler: ' + e);
        }
    });
    runner.on(Constants.MOCHA.EVENT_TEST_FAIL, function (test, err) {
        if (test.type !== Constants.MOCHA.TYPE_TEST)
            return;
        counters.fail++;
        try {
            if (!slProcess)
                return;
            pushTestEndEvent(test, Constants.SEALIGHTS.TEST_STATUS.FAILED);
        }
        catch (e) {
            error('error in fail event handler: ' + e);
        }
    });
    runner.on(Constants.MOCHA.EVENT_TEST_PASS, function (test, err) {
        counters.pass++;
        if (err)
            error('pass error: ' + err + '\n' + err.stack);
        try {
            if (!slProcess)
                return;
            pushTestEndEvent(test, Constants.SEALIGHTS.TEST_STATUS.PASSED);
        }
        catch (e) {
            error('error in test pass event handler: ' + e);
        }
    });
    runner.on(Constants.MOCHA.EVENT_TEST_END, function (test) {
        counters.end++;
        try {
            if (!slProcess)
                return;
            slProcess.setCurrentTestIdentifier(null);
        }
        catch (e) {
            error('error in test end event handler: ' + e);
        }
    });
    runner.on(Constants.MOCHA.EVENT_TEST_PENDING, function (test) {
        counters.skipped++;
        try {
            if (!slProcess)
                return;
            pushTestStartEvent(test);
            pushTestEndEvent(test, Constants.SEALIGHTS.TEST_STATUS.SKIPPED);
        }
        catch (e) {
            error('error in pending test event handler: ' + e);
        }
    });
    function getSuitePath(t) {
        var parts = [];
        while (t) {
            if (t.parent)
                parts.unshift(t.title);
            t = t.parent;
        }
        return parts;
    }
    function clone(o) {
        return JSON.parse(JSON.stringify(o));
    }
    this.getExecutionId = function getExecutionId() {
        return executionId;
    };
    this.getVersion = function getVersion() {
        return process.env.npm_package_version;
    };
    function initTestListener() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const toolInfo = {
                    name: 'mocha',
                    version: mocha.prototype.version
                };
                let agentConfig = new ConfigLoader().loadAgentConfiguration();
                agentConfig.shouldCheckForActiveExecutionOnStartUp.value = false;
                slProcess = yield sealights.initAsync(agentConfig, toolInfo);
                logger = slProcess.getLogger('SeaLights for Mocha');
                otelAgent = new OtelAgent({ agentConfig, logger });
                log('Initialized');
                yield pushExecutionStartedEvent();
                let __initTestId = slProcess.createTestId(executionId, '__init');
                slProcess.setCurrentTestIdentifier(__initTestId, true);
                const excludedTestsMap = yield slProcess.testRecommendationHandler.getExcludedTests();
                processTests(runner.suite, excludedTestsMap);
            }
            catch (err) {
                error('Initialization error', err);
            }
        });
    }
    function pushExecutionStartedEvent() {
        executionId = slProcess.createTestSuiteId();
        return slProcess.startColoredExecution(executionId);
    }
    function pushExecutionEndEvent() {
        slProcess.pushEvent({
            type: Constants.SEALIGHTS.EVENT_TYPES.EXECUTION.END,
            executionId: executionId,
            meta: {
                counters: clone(counters)
            }
        });
    }
    function pushTestStartEvent(test) {
        var testName = test.fullTitle();
        var testId = slProcess.createTestId(executionId, testName);
        slProcess.setCurrentTestIdentifier(testId);
        pushTestEvent(test, Constants.SEALIGHTS.EVENT_TYPES.TESTS.START);
    }
    function pushTestEndEvent(test, testStatus) {
        pushTestEvent(test, Constants.SEALIGHTS.EVENT_TYPES.TESTS.END, testStatus);
    }
    function pushTestEvent(test, eventType, testStatus) {
        var testName = test.fullTitle();
        var suitePath = getSuitePath(test);
        var event = {
            type: eventType,
            testName: testName,
            executionId: executionId,
            testPath: suitePath,
            meta: {
                counters: clone(counters)
            }
        };
        // Mark test as dummy
        if (test.title === 'SLEmptyTest') {
            event.testType = 'dummy';
        }
        if (eventType === Constants.SEALIGHTS.EVENT_TYPES.TESTS.END) {
            event.result = testStatus;
            event.duration = test.duration;
        }
        slProcess.pushEvent(event);
    }
    function processTests(suite, excludedTestsMap) {
        var childHasBeforeHook = false; // Child suite has beforeAll hook
        var allTestsSkip = true; // There are no tests or all the tests are skipped
        var hasBeforeEachHook = false; // Current suite has beforeEach hook
        if (suite.suites && suite.suites.length) {
            suite.suites.forEach(function (currSuite) {
                if (currSuite._beforeAll.length)
                    childHasBeforeHook = true;
                processTests(currSuite, excludedTestsMap);
            });
        }
        if (suite.tests && suite.tests.length) {
            suite.tests.forEach(function (tst) {
                if (excludedTestsMap[tst.fullTitle()]) {
                    log('Test ' + tst.fullTitle() + ' skipped');
                    tst.pending = true;
                }
                else if (!tst.pending) {
                    // At least one test exists that is not skipped
                    allTestsSkip = false;
                }
            });
        }
        if (suite._beforeEach.length - 1)
            hasBeforeEachHook = true;
        // Inject dummy test [SLDEV-10234]
        if (childHasBeforeHook && allTestsSkip && hasBeforeEachHook) {
            if (!SlEnvVars.getDisableHookDependencyGuard()) {
                CockpitNotifier.sendWarning('Hook dependency detected in "' + suite.title + '". Dummy test was injected to avoid failure.');
                suite.addTest(new mocha.Test('SLEmptyTest', () => { }));
            }
            else {
                CockpitNotifier.sendWarning('Hook dependency detected in "' + suite.title + '". Test injection is disabled.');
            }
        }
    }
    process.on('exit', function () {
        if (!afterAllCalled) {
            endExecutionSync();
        }
    });
    function endExecutionSync() {
        var scriptPath = path.resolve(__dirname, 'end-execution.js');
        childProcess.spawnSync(process.argv0, [scriptPath, executionId], {
            stdio: [process.stdin, process.stdout, process.stderr],
            encoding: 'utf-8'
        });
    }
}
inherits(SeaLightsReporter, Base);
//# sourceMappingURL=index.js.map