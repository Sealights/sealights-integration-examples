"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestRecommendationHandler = void 0;
const validation_utils_1 = require("../common/utils/validation-utils");
const contracts_1 = require("../common/http/contracts");
const events_contracts_1 = require("../common/events-process/events-contracts");
const cockpit_notifier_1 = require("../common/agent-events/cockpit-notifier");
const timer_utils_1 = require("../common/utils/timer-utils");
class TestRecommendationHandler {
    constructor(backendProxy, eventsProcess, logger, configParams) {
        this.SLEEP_BETWEEN_RETRIES = 1000;
        this.MAX_RETRIES = 60;
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(backendProxy, 'backendProxy');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(eventsProcess, 'eventsProcess');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(logger, 'logger');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(configParams.buildSessionId, 'buildSessionId');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(configParams.testStage, 'testStage');
        this.backendProxy = backendProxy;
        this.eventsProcess = eventsProcess;
        this.logger = logger;
        this.buildSessionId = configParams.buildSessionId;
        this.testStage = configParams.testStage;
        this.tiaDisabled = !!configParams.tiaDisabled;
        this.testGroupId = configParams.testGroupId;
        if (configParams.testRecommendationSleepSeconds >= 1) {
            this.SLEEP_BETWEEN_RETRIES = configParams.testRecommendationSleepSeconds * 1000;
        }
    }
    getExcludedTests() {
        return __awaiter(this, void 0, void 0, function* () {
            const excludedTestsMap = {};
            if (!this.shouldGetRecommendation()) {
                return excludedTestsMap;
            }
            let message;
            try {
                const testsRecommendationResponse = yield this.getTestRecommendation();
                this.logger.info(`Tests recommendation response: ${JSON.stringify(testsRecommendationResponse)}`);
                if (!this.isSelectionEnabled(testsRecommendationResponse)) {
                    if (this.eventsProcess.testSelectionStatus === events_contracts_1.TestSelectionStatus.RECOMMENDATIONS_NOT_AVAILABLE) {
                        this.logger.info(`
**************************************************************************
* Test recommendation request timed out. Recommendations will be ignored *
**************************************************************************`);
                    }
                    return excludedTestsMap;
                }
                const excludedTests = testsRecommendationResponse.excludedTests;
                this.logExcludedTests(excludedTests);
                excludedTests.forEach(test => excludedTestsMap[test.name] = true);
                this.eventsProcess.testSelectionStatus = events_contracts_1.TestSelectionStatus.RECOMMENDED_TESTS;
            }
            catch (e) {
                message = `Error while trying to get excluded tests list, run all tests as fallback. Error: ${e}`;
                this.logger.warn(message);
                cockpit_notifier_1.CockpitNotifier.sendGenericMessage(message);
                this.eventsProcess.testSelectionStatus = events_contracts_1.TestSelectionStatus.ERROR;
            }
            return excludedTestsMap;
        });
    }
    getExcludedTestsAsync(callback) {
        this.getExcludedTests().then(excludedTests => callback(excludedTests));
    }
    getTestRecommendation() {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            let retries = 0;
            while (true) {
                response = yield this.backendProxy.getTestsRecommendation(this.buildSessionId, this.testStage, this.testGroupId);
                retries++;
                this.logger.debug(`Test recommendation status is ${response.recommendationSetStatus} retry ${retries}/${this.MAX_RETRIES}`);
                if (retries >= this.MAX_RETRIES || !this.isRecommendationsEnabledAndNotReady(response))
                    break;
                yield timer_utils_1.TimerUtils.sleep(this.SLEEP_BETWEEN_RETRIES);
            }
            return response;
        });
    }
    isRecommendationsEnabledAndNotReady(response) {
        return response && response.testSelectionEnabled !== false && response.recommendationSetStatus == contracts_1.RecommendationSetStatus.NOT_READY;
    }
    logExcludedTests(excludedTests) {
        this.logger.info(`${excludedTests.length} tests will be excluded`);
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(`The following tests will be excluded: ${JSON.stringify(excludedTests)}`);
        }
    }
    isSelectionEnabled(response) {
        if (response.recommendationSetStatus === contracts_1.RecommendationSetStatus.NOT_READY) {
            cockpit_notifier_1.CockpitNotifier.sendGenericMessage('Test recommendation request timed out. Recommendations will be ignored');
            this.eventsProcess.testSelectionStatus = events_contracts_1.TestSelectionStatus.RECOMMENDATIONS_NOT_AVAILABLE;
            return false;
        }
        if (response.recommendationSetStatus === contracts_1.RecommendationSetStatus.WONT_BE_READY) {
            cockpit_notifier_1.CockpitNotifier.sendGenericMessage('Test recommendation won\'t be ready');
            this.eventsProcess.testSelectionStatus = events_contracts_1.TestSelectionStatus.RECOMMENDATIONS_NOT_AVAILABLE;
            return false;
        }
        if (response.testSelectionEnabled === false) {
            cockpit_notifier_1.CockpitNotifier.sendGenericMessage('Test recommendation disabled');
            this.eventsProcess.testSelectionStatus = events_contracts_1.TestSelectionStatus.DISABLED;
            return false;
        }
        return true;
    }
    shouldGetRecommendation() {
        if (this.tiaDisabled) {
            cockpit_notifier_1.CockpitNotifier.sendGenericMessage('Test recommendation disabled by configuration');
            this.eventsProcess.testSelectionStatus = events_contracts_1.TestSelectionStatus.DISABLED_BY_CONFIGURATION;
            return false;
        }
        return true;
    }
}
exports.TestRecommendationHandler = TestRecommendationHandler;
//# sourceMappingURL=test-recommendation-handler.js.map