"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseProxy = void 0;
const zlib = require("zlib");
class BaseProxy {
    constructor(cfg, request, logger) {
        this.cfg = cfg;
        this.request = request;
        this.logger = logger;
        if (!cfg) {
            throw new Error('cfg is required');
        }
        if (!request) {
            throw new Error('request is required');
        }
        if (!logger) {
            throw new Error('logger is required');
        }
    }
    get(urlPath, callback) {
        const opts = {
            url: this.cfg.server.value + urlPath,
            json: true,
            compressed: true,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + this.cfg.token.value
            }
        };
        if (this.cfg.proxy.hasValue) { //http://user:pass@proxy.server.com:3128
            opts.proxy = this.cfg.proxy.value;
            this.allowUntrustedCertificates();
        }
        this.request.get(opts, (err, response, data) => {
            if (err) {
                return callback(err, null);
            }
            if (response.statusCode == 404) {
                return callback(null, null);
            }
            if (response.statusCode != 200) {
                return callback(new Error('Server returned HTTP Status ' + response.statusCode), null);
            }
            return callback(null, data);
        });
    }
    delete(urlPath, callback) {
        const opts = {
            url: this.cfg.server + urlPath,
            json: true,
            compressed: true,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + this.cfg.token
            }
        };
        if (this.cfg.proxy) { //http://user:pass@proxy.server.com:3128
            opts.proxy = this.cfg.proxy;
            this.allowUntrustedCertificates();
        }
        this.request.delete(opts, (err, response, data) => {
            if (err) {
                return callback(err, null);
            }
            if (response.statusCode == 404) {
                return callback(null, null);
            }
            if (response.statusCode != 200) {
                return callback(new Error('Server returned HTTP Status ' + response.statusCode), null);
            }
            return callback(null, data);
        });
    }
    post(bufferToSend, urlPath, callback) {
        const shouldZip = this.cfg.gzip.value;
        //let bufferToSend = new Buffer(JSON.stringify(packetToSend));
        if (shouldZip) {
            zlib.gzip(bufferToSend, (err, compressedBuf) => {
                if (err) {
                    //Fallback to sending data uncompressed
                    this.internalPost(urlPath, bufferToSend, null, callback);
                }
                else {
                    this.internalPost(urlPath, compressedBuf, { 'Content-Encoding': 'gzip' }, callback);
                }
            });
        }
        else {
            this.internalPost(urlPath, bufferToSend, null, callback); //Submit buffer as-is
        }
    }
    internalPost(urlPath, buffer, additionalHeaders, callback) {
        try {
            const opts = {
                url: this.cfg.server.value + urlPath,
                //json: true,
                compressed: true,
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + this.cfg.token.value
                },
                body: buffer,
            };
            if (additionalHeaders) {
                for (const header in additionalHeaders) { //Copy additional headers
                    opts.headers[header] = additionalHeaders[header];
                }
            }
            if (this.cfg.proxy.hasValue) { //http://user:pass@proxy.server.com:3128
                opts.proxy = this.cfg.proxy.value;
                this.allowUntrustedCertificates();
            }
            this.request.post(opts, (err, response, data) => {
                if (err)
                    return callback(err);
                if (response.statusCode >= 400)
                    return callback(new Error('HTTP error ' + response.statusCode));
                return callback(null);
            });
        }
        catch (err) {
            this.logger.error('Failed sending Http POST to :\'' + urlPath + '\'. Error:' + err);
            callback(err);
        }
    }
    allowUntrustedCertificates() {
        //For more information: https://stackoverflow.com/questions/17383351/how-to-capture-http-messages-from-request-node-library-with-fiddler/22996076#22996076
        process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
    }
}
exports.BaseProxy = BaseProxy;
//# sourceMappingURL=base-proxy.js.map