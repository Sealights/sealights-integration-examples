"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionServiceProxy = void 0;
const base_proxy_1 = require("../base-proxy");
const request = require("sl-request");
const path = require("path");
const async_1 = require("async");
const fs = require("fs");
const querystring_1 = require("querystring");
class ExecutionServiceProxy extends base_proxy_1.BaseProxy {
    constructor(cfg, request, logger) {
        super(cfg, request, logger);
    }
    //var log = logger? logger.child({className: "ExecutionService"}) : consoleFileLogger("ExecutionService");
    startExecution(config, callback) {
        const data = {
            'customerId': config.customerId,
            'appName': config.appName,
            'newEnvironment': config.testStage,
            'source': config.source
        };
        if (config.labId) {
            data.environment = config.labId;
        }
        if (config.testGroupId) {
            data.testGroupId = config.testGroupId;
        }
        if (config.build) {
            data.buildName = config.build;
        }
        if (config.branch) {
            data.branchName = config.branch;
        }
        const routeVersion = config.isValidToken ? '/v3' : '/v2';
        const relativeUrl = routeVersion + '/testExecution';
        const bufferToSend = new Buffer(JSON.stringify(data));
        this.logger.info(`Start execution. Url: '${relativeUrl} ', Data: ${data}`);
        this.post(bufferToSend, relativeUrl, callback);
    }
    endExecution(config, callback) {
        const queryParams = {
            'customerId': config.customerId.valueOf,
            'appName': config.appName
        };
        if (config.build) {
            queryParams.buildName = config.build;
        }
        if (config.branch) {
            queryParams.branchName = config.branch;
        }
        if (config.labId) {
            queryParams.environment = config.labId;
        }
        const routeVersion = config.isValidToken ? '/v3' : '/v2';
        let relativeUrl = routeVersion + '/testExecution';
        relativeUrl = relativeUrl.replace(/\?.*|$/, '?' + (0, querystring_1.stringify)(queryParams));
        this.logger.info(`End execution. url: ${relativeUrl}`);
        this.delete(relativeUrl, callback);
    }
    uploadExternalReport(config, data, callback) {
        const relativeUrl = '/v1/externalreport';
        const bufferToSend = new Buffer(JSON.stringify(data));
        this.logger.info(`Uploading external report ${data}`);
        this.post(bufferToSend, relativeUrl, callback);
    }
    uploadReport(config, agentData, reportFile, callback) {
        if (!reportFile) {
            return callback(new Error('\'reportFile\' can\'t be null or undefined'));
        }
        if (!reportFile.buffer) {
            return callback(new Error('\'reportFile.buffer\' can\'t be null or undefined'));
        }
        const routeVersion = config.isValidToken ? '/v3' : '/v2';
        const relativeUrl = routeVersion + '/externaldata';
        const req = request.post(relativeUrl, function (err, resp, body) {
            if (!err && resp && resp.statusCode >= 400) {
                err = new Error('HTTP ERROR: ' + resp.statusCode + ' ' + resp.statusMessage);
            }
            if (err) {
                this.logger.error('[UPLOAD REPORTS] Error Uploading Report File: ' + err + '. Report File: ' + reportFile.filename);
                callback(err);
            }
            else {
                this.logger.info('[UPLOAD REPORTS] Uploaded Report File Successfully. Report File: ' + reportFile.filename);
                callback(null);
            }
        });
        //When I was learning node and the request module, I was confused as to why the form could be modified
        // after the post method was called. Buried in the request docs is the explanation - "the form can be modified
        // until the request is fired on the next cycle of the event-loop"
        const form = req.form();
        form.append('file', JSON.stringify(agentData), {
            filename: 'agentData',
            contentType: 'multipart/form-data'
        });
        form.append('file', reportFile.buffer.toString(), {
            filename: 'agentData',
            contentType: 'multipart/form-data'
        });
    }
    uploadReports(config, callback) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const context = this;
        const agentData = this.getAgentData(config);
        try {
            const files = context.getAllFiles(config.reportFile, config.reportFilesFolder);
            if (files.length == 0) {
                this.logger.info('No report files found');
                return callback(null);
            }
            async_1.default.forEachLimit(files.slice(0, -1), 1, function (reportFile, callback) {
                context.uploadReport(config, agentData, reportFile, function (err) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        callback(null);
                    }
                });
            }, function (err) {
                if (err) {
                    return callback(err);
                }
                const lastFile = files[files.length - 1];
                agentData.hasMoreRequests = config.hasMoreRequests;
                context.uploadReport(config, agentData, lastFile, function (err) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        callback(null);
                    }
                });
            });
        }
        catch (err) {
            callback(err);
        }
    }
    getAllFiles(reportFiles, reportFilesFolders) {
        const files = [];
        // handle reportFilesFolders
        reportFilesFolders.forEach((reportFilesFolder) => {
            try {
                const folderFiles = fs.readdirSync(reportFilesFolder);
                folderFiles.forEach(function (folderFileName) {
                    const stat = fs.statSync(path.join(reportFilesFolder, folderFileName));
                    if (stat.isFile()) {
                        files.push({ filename: folderFileName, buffer: fs.readFileSync(path.join(reportFilesFolder, folderFileName)) });
                    }
                    else {
                        this.logger.warn('[UPLOAD REPORTS] ' + folderFileName + ' is a directory. Ignoring...');
                    }
                });
            }
            catch (err) {
                this.logger.error('[UPLOAD REPORTS] Failed Reading Folder: ' + reportFilesFolder);
            }
        });
        // handle reportFiles
        reportFiles.forEach((reportFilePath) => {
            if (fs.existsSync(reportFilePath)) {
                files.push({ filename: path.basename(reportFilePath), buffer: fs.readFileSync(reportFilePath) });
            }
            else {
                this.logger.warn('[UPLOAD REPORTS] reportFile doesn\'t exist. report file: ' + reportFilePath);
            }
        });
        return files;
    }
    getAgentData(config) {
        const agentData = {
            customerId: config.customerId,
            appName: config.appName,
            environment: {
                labId: config.labId,
                environmentName: config.environmentName
            },
            type: config.type,
            source: config.source,
            hasMoreRequests: true,
        };
        if (config.build) {
            agentData.buildName = config.build;
        }
        if (config.branch) {
            agentData.branchName = config.branch;
        }
        return agentData;
    }
}
exports.ExecutionServiceProxy = ExecutionServiceProxy;
//# sourceMappingURL=execution-service-proxy.js.map