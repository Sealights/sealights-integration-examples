"use strict";
/**
 * Created by nadav on 19/03/2017.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpColoring = void 0;
const url = require("url");
const objectAssign = require("object-assign");
const http = require("http");
const https = require("https");
const cookie = require("lightcookie");
class HttpColoring {
    setup(config, stateTracker, log) {
        this.setupHttpColoring(config, stateTracker, log);
    }
    teardown() {
    }
    setupHttpColoring(config, stateTracker, log) {
        if (config.httpServerColoring.value) {
            this.setupHttpServerColoring(config, stateTracker, log);
        }
        else {
            log.info('HTTP Server coloring is disabled');
        }
        if (config.httpClientColoring.value) {
            this.setupHttpClientColoring(config, stateTracker, log);
        }
        else {
            log.info('HTTP Client coloring is disabled');
        }
    }
    /*
    *
    * Server coloring means that we wrap the prototype of "Http.Server" in such a way that:
    *  1. Every request to the server will be searched. If we'll find the Sealights HTTP header, we'll read it and save into the state tracker.
    *  2. Add the sealights header to every response (regardless if the request had the sealights header or not).
    *
    *  Basically this handles all the INCOMING requests and their responses.
    * */
    setupHttpServerColoring(config, stateTracker, log) {
        function wrapListener(listener) {
            if (typeof listener !== 'function')
                return listener;
            return function (request, response) {
                try {
                    if (request && request.headers) {
                        let newTestIdentifier = request.headers[HttpColoring.COLORING_HEADER_NAME];
                        if (newTestIdentifier) {
                            log.info('Got test identifier from Sealights HTTP header: ' + newTestIdentifier);
                        }
                        else {
                            const cookiesHeader = request.headers['cookie'];
                            if (cookiesHeader) {
                                try {
                                    log.info('\'Got cookiesHeader: \'' + cookiesHeader + '\'');
                                    const parsed = cookie.parse(cookiesHeader) || {};
                                    newTestIdentifier = parsed[HttpColoring.COLORING_HEADER_NAME];
                                    if (newTestIdentifier) {
                                        log.info('\'Got test identifier from HTTP cookie: \'' + newTestIdentifier + '\'');
                                    }
                                    else {
                                        log.error('Got invalid cookie header: \'' + cookiesHeader);
                                    }
                                }
                                catch (e) {
                                    log.error(`Got invalid cookie header: '${cookiesHeader}' Error: ${e}`);
                                }
                            }
                        }
                        if (newTestIdentifier) {
                            log.info('Setting test identifier from HTTP header: ' + newTestIdentifier);
                            stateTracker.setTestIdentifier(newTestIdentifier);
                        }
                    }
                }
                catch (e) {
                    log.error('Exception in server communication hook: ' + e);
                }
                try {
                    const currentTestIdentifier = stateTracker.getCurrentTestIdentifier();
                    if (currentTestIdentifier) {
                        response.setHeader(HttpColoring.COLORING_HEADER_NAME, currentTestIdentifier);
                    }
                }
                catch (e) {
                    log.error('Error adding color to response');
                }
                // eslint-disable-next-line prefer-spread,prefer-rest-params
                listener.apply(null, arguments);
            };
        }
        function hookAddListenerFunction(oldListener) {
            return function (type, listener) {
                if (type == 'request') {
                    return oldListener.call(this, type, wrapListener(listener));
                }
                return oldListener.apply(this, arguments);
            };
        }
        const httpServerPrototype = http.Server.prototype;
        httpServerPrototype.on = hookAddListenerFunction(httpServerPrototype.on);
        httpServerPrototype.addListener = hookAddListenerFunction(httpServerPrototype.addListener);
    }
    /*
  *
  *     Client coloring means that we wrap 'http.request' and 'https.request' in such a way that:
  *  1. For every request that client application we should add the Sealights HTTP Header as long as the request is not to Sealights servers.
  *     The reason for the latter is that when the agent sends events and footprints to the cloud, we don't want to send the color.
  *  2. Since HTTP is based on request-response model, every request has a response. When the client sends a request, we also
  *     search for the Sealights HTTP Header on response (if the server uses HttpServerColoring=true). If it exists, we'll set to the state tracker.
  *
  *  Basically this handles all the OUTGOING requests and their responses.
  * */
    setupHttpClientColoring(config, stateTracker, log) {
        function hookRequestFunction(oldRequest, protocol) {
            return function (options, callback) {
                const currentTestIdentifier = stateTracker.getCurrentTestIdentifier();
                try {
                    if (currentTestIdentifier) {
                        if (typeof options === 'string') {
                            options = url.parse(options);
                        }
                        else {
                            options = objectAssign({}, options);
                        }
                        options.headers = options.headers || {};
                        options.protocol = options.protocol || protocol;
                        let fullUrl = url.format(options);
                        if (options.path)
                            fullUrl += options.path; //according to the docs, the generated url will NOT include the path
                        if (options.href) {
                            //This should fix the following:
                            //TODO: Fix the URL. Missing the protocol + should compare without casing issues. Example:
                            //fullUrl: "//dev-nadav-gw.sealights.co/api/v2/config/SeaLights/hello%20world/master/Unit%20Tests/nodejs-agent/3.0.28"
                            //config.server.value: "https://DEV-nadav-gw.sealights.co/api"
                            fullUrl = options.href;
                        }
                        const shouldSend = shouldSendHeader(config.server.value, options.method, fullUrl, currentTestIdentifier);
                        if (shouldSend) {
                            log.info('Sending test identifier: ' + currentTestIdentifier + ', url:' + fullUrl);
                            options.headers[HttpColoring.COLORING_HEADER_NAME] = currentTestIdentifier;
                        }
                    }
                }
                catch (e) {
                    log.error('Exception in client communication hook: ' + e);
                }
                const originalCallback = callback;
                callback = function (res) {
                    if (res && res.headers && res.headers[HttpColoring.COLORING_HEADER_NAME]) {
                        const newTestIdentifier = res.headers[HttpColoring.COLORING_HEADER_NAME];
                        if (newTestIdentifier) {
                            try {
                                log.info('Setting color from server response. newTestIdentifier:\'' + newTestIdentifier + '\'.');
                                stateTracker.setTestIdentifier(newTestIdentifier);
                            }
                            catch (e) {
                                log.error('Error setting test identifier' + e);
                            }
                        }
                    }
                    originalCallback && originalCallback.apply(this, arguments);
                };
                const req = oldRequest(options, callback);
                return req;
            };
        }
        function shouldSendHeader(server, method, fullUrl, currentTestIdentifier) {
            if (!currentTestIdentifier) {
                return false;
            }
            if (method === 'CONNECT') {
                return false;
            }
            return !isSealightsServer(fullUrl, server);
        }
        function isSealightsServer(fullUrl, server) {
            return fullUrl.toLowerCase().indexOf(server.toLowerCase()) === 0;
        }
        http.request = hookRequestFunction(http.request, 'http:');
        https.request = hookRequestFunction(https.request, 'https:');
    }
}
exports.HttpColoring = HttpColoring;
HttpColoring.COLORING_HEADER_NAME = 'x-sl-testid';
//# sourceMappingURL=http-coloring.js.map