"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentLoader = void 0;
const factory_1 = require("./factory");
const config_loader_1 = require("../common/config-process/config-loader");
const nycBinFile = require.resolve('nyc/bin/nyc.js');
const Module = require("module");
const otel_agent_loader_1 = require("./otel-agent-loader");
const sl_env_vars_1 = require("../common/constants/sl-env-vars");
const files_utils_1 = require("../common/utils/files-utils");
const fs = require("fs");
const cockpit_notifier_1 = require("../common/agent-events/cockpit-notifier");
const path = require("path");
const child_process_1 = require("child_process");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const patchChildProcess = require('./child-process-patcher').patchChildProcess;
class AgentLoader {
    static run(args, useIstanbul, spawnRuntimeArgs, shouldBootstrap = true, options = {}) {
        const configLoader = new config_loader_1.ConfigLoader();
        const agentCfg = configLoader.loadAgentConfiguration({});
        agentCfg.useIstanbul.value = useIstanbul;
        agentCfg.useTsNode.value = args.includes('ts-node/register');
        // There's a bug with "import * as program from 'commander'" that disregard no input flags when they're used before the -- pipeline
        // For example: mocha --tiaDisabled --tokenfile "sltoken.txt" --buildsessionidfile "buildSessionId" -- --parallel
        //      tiaDisabled will work in the above, but will not work if you call like this:
        //      mocha --tokenfile "sltoken.txt" --buildsessionidfile "buildSessionId" --tiaDisabled -- --parallel
        agentCfg.tiaDisabled.value = agentCfg.tiaDisabled.value || args.includes('--tiaDisabled');
        global['agentCfg'] = agentCfg;
        AgentLoader.init(agentCfg, args, spawnRuntimeArgs, shouldBootstrap, options);
    }
    static init(agentCfg, args, spawnRuntimeArgs, shouldBootstrap = true, options = {}) {
        const factory = new factory_1.NodeAgentFactory(agentCfg);
        const logger = factory.getCreateApplicationLogger();
        if (agentCfg.enableChildProcessPatcher.value) {
            logger.warn('patchChildProcess is enabled.');
            patchChildProcess(__filename);
        }
        const useIstanbul = agentCfg.useIstanbul.value == true;
        if (useIstanbul) {
            logger.warn('Running agent using Istanbul.');
            AgentLoader.runAgentUsingIstanbul(args, shouldBootstrap);
        }
        else {
            logger.info('Running agent using NYC');
            AgentLoader.checkIfCustomNycConfigExist(logger);
            AgentLoader.runAgentUsingNyc(agentCfg, args, spawnRuntimeArgs, shouldBootstrap, logger);
            logger.info('After Running agent using NYC');
        }
        const otelAgentLoader = new otel_agent_loader_1.OtelAgentLoader({
            command: options === null || options === void 0 ? void 0 : options.command,
            agentConfig: agentCfg,
            useIstanbul,
            logger
        });
        otelAgentLoader.resolveAgentRunningOtelAgent();
        AgentLoader.rerunMainModule();
    }
    // Function to check if a folder can be created
    static canCreateFolder(folderPath) {
        try {
            if (!fs.existsSync(folderPath)) {
                fs.mkdirSync(folderPath);
            }
            return true;
        }
        catch (error) {
        }
        return false;
    }
    static checkIfNycDefaultTempFolderCanBeCreated() {
        const folderPath = path.join('.', '.nyc_output');
        return AgentLoader.canCreateFolder(folderPath);
    }
    static rerunMainModule() {
        if (AgentLoader.shouldUseModuleRunMain) {
            Module.runMain();
            return;
        }
        const args = process.argv.join(' ');
        try {
            console.info('Rerun main module with args - ', args);
            (0, child_process_1.execSync)(args, { stdio: 'inherit' });
            process.exit(0);
        }
        catch (error) {
            process.exit(1);
        }
    }
    static shouldUseModuleRunMain() {
        const requiredVersion = '20.6.0';
        return compareVersions(process.versions.node, requiredVersion) < 1;
    }
    static runAgentUsingNyc(agentCfg, args, spawnRuntimeArgs, shouldBootstrap, logger) {
        let tempFolder = undefined;
        if (!AgentLoader.checkIfNycDefaultTempFolderCanBeCreated()) {
            const folderPath = path.join('/tmp', '.nyc_output');
            if (AgentLoader.canCreateFolder(folderPath)) {
                tempFolder = folderPath;
                logger.info(`Nyc will use the ${folderPath} as temporary folder.`);
            }
            else {
                const errorMessage = 'Unable to create temporary folder needed for Nyc due to permission issues.';
                cockpit_notifier_1.CockpitNotifier.sendWarning(errorMessage);
                logger.error(errorMessage);
                process.argv = [process.argv[0], ...args];
                return;
            }
        }
        process.env.SL_CONFIGURATION = JSON.stringify(agentCfg.toJsonObject());
        process.argv = [process.argv[0], nycBinFile, process.argv[0]].concat(spawnRuntimeArgs).concat(args);
        if (shouldBootstrap) {
            const nycArgs = ['-i', require.resolve('./bootstrap')];
            if (tempFolder) {
                nycArgs.push('--temp-dir', tempFolder);
            }
            if (sl_env_vars_1.SlEnvVars.useSpawnWrap()) {
                nycArgs.push('--use-spawn-wrap');
            }
            process.argv.splice(2, 0, ...nycArgs);
        }
    }
    static runAgentUsingIstanbul(args, shouldBootstrap) {
        if (shouldBootstrap) {
            require('./bootstrap');
        }
        const istanbulMain = require.resolve('istanbul/lib/cli.js');
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const x = require(istanbulMain); //Module.runMain();
        x.runToCompletion(['cover'].concat(args));
    }
    static checkIfCustomNycConfigExist(logger) {
        var _a;
        // check for config in package.json
        const pathToPackageJson = files_utils_1.FilesUtils.findFileUp('package.json', process.cwd());
        if (pathToPackageJson) {
            const packageJsonContent = fs.readFileSync(pathToPackageJson).toString();
            const nycConfig = (_a = JSON.parse(packageJsonContent)) === null || _a === void 0 ? void 0 : _a.nyc;
            if ((nycConfig === null || nycConfig === void 0 ? void 0 : nycConfig.include) || (nycConfig === null || nycConfig === void 0 ? void 0 : nycConfig.exclude)) {
                cockpit_notifier_1.CockpitNotifier.sendWarning(`NYC configuration detected in ${pathToPackageJson}. 
                    This may interfere with the Sealights configuration and result in no/low coverage because of difference in exclude/include rules.`);
                cockpit_notifier_1.CockpitNotifier.sendWarning(`Detected the following NYC include/exclude rules in package.json: ${nycConfig.include} / ${nycConfig.exclude}`);
            }
        }
        // check for nyc config files
        const nycConfigFiles = [
            '.nycrc',
            '.nycrc.json',
            '.nycrc.yaml',
            '.nycrc.yml',
            'nyc.config.js',
        ];
        nycConfigFiles.forEach(cf => {
            const pathToConfig = files_utils_1.FilesUtils.findFileUp(cf, process.cwd());
            if (pathToConfig) {
                cockpit_notifier_1.CockpitNotifier.sendWarning(`NYC configuration detected in ${pathToConfig}. 
                    This may interfere with the Sealights configuration and result in no/low coverage because of difference in exclude/include rules.`);
            }
        });
    }
}
exports.AgentLoader = AgentLoader;
function compareVersions(a, b) {
    const partsA = a.split('.');
    const partsB = b.split('.');
    for (let i = 0; i < partsA.length; i++) {
        const numA = parseInt(partsA[i]) || 0;
        const numB = parseInt(partsB[i]) || 0;
        if (numA > numB)
            return 1;
        if (numA < numB)
            return -1;
    }
    return 0;
}
//# sourceMappingURL=agent-loader.js.map