"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlNodeJsProxy = void 0;
const child_process = require("child_process");
/**
 * This class acts as proxy between the code to sl-node-js component.
 * */
class SlNodeJsProxy {
    constructor(userMessageHelper) {
        this.userMessageHelper = userMessageHelper;
        if (!userMessageHelper) {
            throw new Error('\'userMessageHelper\' cannot be null or undefined');
        }
    }
    runConfigMode(configModeData, callback) {
        //TODO: Check if we need additional arguments.
        const command = 'config';
        const params = {};
        const excludes = this.getBuildModeExcludeList();
        console.log('excludes:' + excludes);
        for (const p in configModeData) {
            if (excludes.indexOf(p) > -1 || p.indexOf('_') === 0 || !configModeData[p])
                continue;
            const pName = '--' + p.toLowerCase();
            params[pName] = configModeData[p];
        }
        this.invokeCommand(command, params, callback);
    }
    runScanMode(scanModeData, callback) {
        //TODO: Check if we need additional arguments.
        const command = 'build';
        const params = {};
        const excludes = this.getBuildModeExcludeList();
        console.log('excludes:' + excludes);
        for (const p in scanModeData) {
            if (excludes.indexOf(p) > -1 || p.indexOf('_') === 0 || !scanModeData[p])
                continue;
            const pName = '--' + p.toLowerCase();
            params[pName] = scanModeData[p];
        }
        this.invokeCommand(command, params, callback);
    }
    getBuildModeExcludeList() {
        const excludes = ['constructor'];
        return excludes;
    }
    invokeCommand(mode, params, callback) {
        if (!mode) {
            throw new Error('\'mode\' cannot be null or undefined');
        }
        if (!params) {
            throw new Error('\'params\' cannot be null or undefined');
        }
        if (!callback) {
            throw new Error('\'callback\' cannot be null or undefined');
        }
        const commandParts = [];
        commandParts.push(mode);
        for (const p in params) {
            commandParts.push(p);
            commandParts.push(params[p]);
        }
        const command = this.getSlNodeJsPath();
        this.userMessageHelper.println('Command: ' + command);
        this.userMessageHelper.println('Command Args: ' + commandParts.join(' '));
        const slNodeJsProcess = child_process.spawn(command, commandParts, {
            stdio: 'inherit'
        });
        slNodeJsProcess.on('close', (code) => {
            let error = null;
            if (code > 0) {
                const fullCommand = command + ' ' + commandParts.join(' ');
                error = new Error('Failed while running sl-node-js.\nReturn Code: ' + code + '\nCommand:\'' + fullCommand + '\'. ');
                return callback(error);
            }
            return callback(error);
        });
    }
    getSlNodeJsPath() {
        const SL_NODE_JS_PATH = 'SL_NODE_JS_PATH';
        if (process.env && process.env[SL_NODE_JS_PATH]) {
            return process.env[SL_NODE_JS_PATH];
        }
        try {
            const path = require.resolve('slnodejs');
            if (path) {
                return path;
            }
        }
        catch (e) {
        }
        return './node_modules/.bin/slnodejs';
    }
}
exports.SlNodeJsProxy = SlNodeJsProxy;
//# sourceMappingURL=SlNodeJsProxy.js.map