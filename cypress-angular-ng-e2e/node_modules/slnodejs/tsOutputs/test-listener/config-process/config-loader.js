"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigLoader = void 0;
const config_system_1 = require("./config-system");
const fs = require("fs");
const path = require("path");
const jwtDecode = require("jwt-decode");
const config_1 = require("../../common/config-process/config");
class ConfigLoader {
    constructor(logger) {
        this.logger = logger;
    }
    loadAgentConfiguration(initialJsonConfig, configFileOrDir) {
        //1. Defaults
        const agentCfg = new config_1.AgentConfig();
        if (!configFileOrDir) {
            configFileOrDir = path.resolve('sealights.json');
        }
        else {
            try {
                const stat = fs.statSync(configFileOrDir);
                if (stat.isDirectory()) {
                    configFileOrDir = path.resolve(configFileOrDir, 'sealights.json');
                }
            }
            catch (err) {
                //file/dir not found
                //TODO: LOG
            }
        }
        /**
         * 2. This is how the cli program, executed on the parent process, communicates with this process.
         * This configuration takes precedence over other environment variables
         */
        if (process.env.SL_CONFIGURATION) {
            try {
                const jsonCfg = JSON.parse(process.env.SL_CONFIGURATION);
                agentCfg.loadConfiguration(new config_system_1.JsonObjectConfigurationProvider(jsonCfg));
            }
            catch (e) {
                console.error(`Error parsing agent configuration ${e}`);
                //TODO: Log
            }
        }
        //3. Configuration from file
        agentCfg.loadConfiguration(new config_system_1.JsonConfigFileConfigurationProvider(configFileOrDir));
        //4. Env variables
        agentCfg.loadConfiguration(new config_system_1.EnvVariableConfigurationProvider('SL_'));
        //5. Overwrite file config with runtimeCfg provided by the user
        if (initialJsonConfig) {
            agentCfg.loadConfiguration(new config_system_1.JsonObjectConfigurationProvider(initialJsonConfig));
        }
        if (!agentCfg.token.hasValue && agentCfg.tokenFile.hasValue) {
            try {
                agentCfg.token.value = fs.readFileSync(agentCfg.tokenFile.value).toString();
            }
            catch (err) {
                //TODO: LOG
            }
        }
        //6. Load from token
        if (agentCfg.token.hasValue) {
            this.loadConfigFromToken(agentCfg, agentCfg.token.value);
        }
        this.printConfiguration(agentCfg);
        //Rest of configuration will be overridden by server cfg (after agent is loaded)
        return agentCfg;
    }
    printConfiguration(agentCfg) {
        if (!this.logger)
            return;
        this.logger.info('****************************************************');
        this.logger.info('Current config');
        this.logger.info('****************************************************');
        this.logger.info(agentCfg.toJsonObject());
    }
    loadConfigFromToken(agentCfg, token) {
        if (!token)
            return null;
        try {
            const tokenData = jwtDecode(token);
            if (!tokenData['x-sl-server']) {
                throw new Error('Token Is Invalid. Doesn\'t Contain Server');
            }
            if (!tokenData['subject']) {
                throw new Error('Token Is Invalid. Doesn\'t Contain Subject');
            }
            let customerId = tokenData['subject'];
            const subjectParts = tokenData['subject'].split('@');
            if (subjectParts.length >= 1) {
                customerId = subjectParts[0];
            }
            if (!agentCfg.server.hasValue) {
                agentCfg.server.value = tokenData['x-sl-server'];
            }
            agentCfg.customerId.value = customerId;
        }
        catch (err) {
            //TODO: LOG
        }
    }
}
exports.ConfigLoader = ConfigLoader;
//# sourceMappingURL=config-loader.js.map