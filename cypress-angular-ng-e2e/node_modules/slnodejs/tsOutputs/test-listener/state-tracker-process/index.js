"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateTrackerProcess = void 0;
const events = require("events");
const timers_1 = require("timers");
const sl_env_vars_1 = require("../../common/constants/sl-env-vars");
const INITIAL_COLOR = '00000000-0000-0000-0000-000000000000/__init';
class StateTrackerProcess extends events.EventEmitter {
    constructor(cfg, configProcess, stateTrackerProxy, checkTestStatusWatchdog, logger) {
        super();
        this.cfg = cfg;
        this.configProcess = configProcess;
        this.stateTrackerProxy = stateTrackerProxy;
        this.checkTestStatusWatchdog = checkTestStatusWatchdog;
        this.logger = logger;
        this.currentTestIdentifier = null;
        this._hasAnonymousMappingAtServer = false;
        this.isRunning = false;
        if (!cfg) {
            throw new Error('cfg is required');
        }
        if (!configProcess) {
            throw new Error('configProcess is required');
        }
        if (!stateTrackerProxy) {
            throw new Error('stateTrackerProxy is required');
        }
        if (!checkTestStatusWatchdog) {
            throw new Error('checkTestStatusWatchdog is required');
        }
        if (!logger) {
            throw new Error('logger is required');
        }
        if (this.cfg.useInitialColor.value && this.currentTestIdentifier == null) {
            this.switchToAnonFootprints();
        }
        configProcess.on('configuration_changed', (newCfg) => {
            if (newCfg.useInitialColor.value && this.currentTestIdentifier == null) {
                this.switchToAnonFootprints();
            }
            this.cfg = newCfg;
        });
        this.startCheckingTestStatusAtServer();
    }
    startCheckingTestStatusAtServer() {
        if (sl_env_vars_1.SlEnvVars.inProductionListenerMode()) {
            this.logger.debug('In production listener, no need to check test status in server');
            return;
        }
        this.checkTestStatusWatchdog.on('alarm', () => {
            this.checkTestStatusAtServer();
        });
        //Invoke it directly after the CTOR ends.
        (0, timers_1.setTimeout)(() => { this.checkTestStatusAtServer(); }, 0);
    }
    checkTestStatusAtServer() {
        if (this.currentTestIdentifier == INITIAL_COLOR) {
            //check if there is still a mapping
            this.stateTrackerProxy.checkMappingStatus((err, hasMapping) => {
                if (err) {
                    this.logger.warn(`Error while checking test execution status ${err}`);
                }
                else { //Agent was in "initial color" and now the server returns that the mapping is no longer active
                    this._hasAnonymousMappingAtServer = hasMapping;
                }
            });
        }
        else {
            this.logger.info('\'currentTestIdentifier\' is null. That means that footprints will not be sent.');
        }
    }
    hasAnonymousMappingAtServer() {
        return this._hasAnonymousMappingAtServer;
    }
    isAnonymousColor(testIdentifier) {
        return INITIAL_COLOR == testIdentifier;
    }
    switchToAnonFootprints() {
        this.logger.info('Switching to anonymous footprints.');
        this.setTestIdentifier(INITIAL_COLOR, false);
    }
    getCurrentTestIdentifier() {
        return this.currentTestIdentifier;
    }
    setTestIdentifier(newTestIdentifier, silent) {
        this.logger.info('setting test identifier: ' + newTestIdentifier);
        if ((this.currentTestIdentifier == null) && (newTestIdentifier != null) || (this.currentTestIdentifier != null && this.currentTestIdentifier != newTestIdentifier && newTestIdentifier != INITIAL_COLOR)) {
            const previousTestIdentifier = this.currentTestIdentifier;
            this.currentTestIdentifier = newTestIdentifier;
            if (this.isRunning) {
                if (!silent) {
                    this.emit('test_identifier_changed', this.currentTestIdentifier, previousTestIdentifier);
                }
                else {
                    this.logger.info('Test identifier changed, running in silent mode not enqueuing footprints');
                }
                this.checkTestStatusWatchdog.reset();
            }
        }
        else {
            this.logger.info('Not setting the color. newTestIdentifier is \'' + newTestIdentifier + '\' ' + 'and currentTestIdentifier is \'' + this.currentTestIdentifier + '\'');
        }
    }
    start() {
        if (this.isRunning) {
            return;
        }
        this.checkTestStatusWatchdog.start();
        this.isRunning = true;
    }
    stop(callback) {
        try {
            if (!this.isRunning) {
                return callback();
            }
            this.checkTestStatusWatchdog.stop();
            this.isRunning = false;
            callback();
        }
        catch (err) {
            //TODO: log
            return callback();
        }
    }
    static splitTestIdToExecutionAndTestName(testId) {
        testId = testId || '';
        const executionId = testId.split('/')[0];
        let testName = (testId.indexOf('/') == -1) ? '' : testId.substring(executionId.length + 1);
        if (!executionId) {
            testName = '';
        }
        return { executionId: executionId, testName: testName };
    }
    static combineExecutionIdAndTestName(executionId, testName) {
        testName = testName || '';
        if (!executionId) {
            return '';
        }
        return executionId + '/' + testName;
    }
}
exports.StateTrackerProcess = StateTrackerProcess;
//# sourceMappingURL=index.js.map