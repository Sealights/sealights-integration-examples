"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeJsAgent = void 0;
const uuid_1 = require("./uuid");
const wait_for_multiple_callbacks_1 = require("./wait-for-multiple-callbacks");
const readline_1 = require("readline");
const state_tracker_1 = require("../common/state-tracker");
const cockpit_notifier_1 = require("../common/agent-events/cockpit-notifier");
const events_contracts_1 = require("../common/events-process/events-contracts");
const system_date_1 = require("../common/system-date");
const version = process.env.npm_package_version;
class NodeJsAgent {
    constructor(_cfg, _footprintsProcess, eventsProcess, logsProcess, stateTracker, configProcess, flushCurrentTestFootprints, coloringProviders, _testRecommendationHandler, agentInstanceData, logger) {
        this._cfg = _cfg;
        this._footprintsProcess = _footprintsProcess;
        this.eventsProcess = eventsProcess;
        this.logsProcess = logsProcess;
        this.stateTracker = stateTracker;
        this.configProcess = configProcess;
        this.flushCurrentTestFootprints = flushCurrentTestFootprints;
        this.coloringProviders = coloringProviders;
        this._testRecommendationHandler = _testRecommendationHandler;
        this.agentInstanceData = agentInstanceData;
        this.logger = logger;
        this.isRunning = false;
        this.isStopping = false;
        if (!_cfg)
            throw new Error('cfg is required');
        if (!_footprintsProcess)
            throw new Error('footprintsProcess is required');
        if (!eventsProcess)
            throw new Error('eventsProcess is required');
        if (!logsProcess)
            throw new Error('logsProcess is required');
        if (!stateTracker)
            throw new Error('stateTracker is required');
        if (!configProcess)
            throw new Error('configProcess is required');
        if (!flushCurrentTestFootprints)
            throw new Error('flushCurrentTestFootprints is required');
        if (!coloringProviders)
            throw new Error('coloringProviders is required');
        if (!_testRecommendationHandler)
            throw new Error('testRecommendationHandler is required');
        if (!logger)
            throw new Error('logger is required');
        stateTracker.on('test_identifier_changed', this._footprintsProcess.handleTestIdChanged.bind(this._footprintsProcess));
        configProcess.on('configuration_changed', (updatedCfg) => {
            if (updatedCfg.enabled.value === false) {
                this.stop(() => { });
            }
            this.flushCurrentTestFootprints.setInterval(updatedCfg.footprintsCollectIntervalSecs.value);
        });
        flushCurrentTestFootprints.on('alarm', () => {
            this._footprintsProcess.flushCurrentFootprints();
        });
    }
    getLogger(component) {
        return this.logger.child({ component: component });
    }
    get testRecommendationHandler() {
        return this._testRecommendationHandler;
    }
    /**
     * Starts the Test Listener
     *
     * @param {(err: Error) => void} [callback] Optional callback that will be called if agent is either disabled, or finished loading (incl. remote config)
     * @returns
     *
     * @memberOf NodeJsAgent
     */
    start(callback, toolInfo) {
        this.logger.info('Agent is starting. process.argv: \'' + process.argv.join(' ') + '\'');
        if (this._cfg.enabled.value === false) {
            this.logger.warn('Agent is disabled');
            if (callback) {
                return callback(null);
            }
            return;
        }
        if (!this._cfg.token.hasValue) {
            this.logger.warn('Agent is disabled since token was not specified');
            if (callback) {
                return callback(null);
            }
            return;
        }
        if (this.isRunning) {
            this.logger.warn('Agent is already running');
            if (callback) {
                return callback(null);
            }
            return;
        }
        cockpit_notifier_1.CockpitNotifier.notifyStart(this._cfg, this.agentInstanceData, this.logger, system_date_1.getSystemOffset, {}, null, toolInfo);
        this.flushCurrentTestFootprints.start();
        this._footprintsProcess.start();
        this.eventsProcess.start();
        this.logsProcess.start();
        this.stateTracker.start();
        this.configProcess.start((err) => {
            if (callback) {
                return callback(null);
            } //Even if configuration failed to be loaded from the server, don't shut down the agent
        });
        this.coloringProviders.forEach((provider) => {
            provider.setup(this._cfg, this.stateTracker, this.logger);
        });
        this.registerGlobalAPI();
        this.registerShutdownEvents();
        this.isRunning = true;
        this.eventsProcess.enqueueEvent({
            type: events_contracts_1.EventTypes.AgentStarted,
            localTime: (0, system_date_1.getSystemDateValueOf)()
        });
        this.logger.info('Agent is now running');
    }
    stop(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isRunning) {
                return callback();
            }
            if (this.isStopping) {
                this.logger.error('Already stopping');
            }
            this.isStopping = true;
            this.logger.info('Agent is now stopping');
            this.stateTracker.setTestIdentifier(null);
            const waiter = new wait_for_multiple_callbacks_1.WaitForMultipleCallbacks();
            yield cockpit_notifier_1.CockpitNotifier.notifyShutdown();
            yield this.eventsProcess.stop();
            this.flushCurrentTestFootprints.stop();
            yield this._footprintsProcess.stop();
            this.stateTracker.stop();
            this.logsProcess.stop(waiter.getCallbackForProcess('logs'));
            this.logger.info('Agent is now stopped');
            return waiter.waitForAll(callback);
        });
    }
    //PUBLIC INTERFACE
    createExecutionId() {
        const now = (0, system_date_1.getSystemDateValueOf)().toString();
        const result = uuid_1.UUID.newGuid([now, this._cfg.customerId.value].join());
        return result;
    }
    //Deprecated
    createTestSuiteId() {
        return this.createExecutionId();
    }
    createTestId(executionId, testName) {
        return state_tracker_1.StateTracker.combineExecutionIdAndTestName(executionId, testName);
    }
    setCurrentTestIdentifier(testIdentifier) {
        this.logger.info('Agent.setCurrentTestIdentifier - testIdentifier:\'' + testIdentifier + '\'.');
        this.stateTracker.setTestIdentifier(testIdentifier, false);
    }
    static getVersion() {
        return version;
    }
    pushEvent(evt) {
        this.eventsProcess.enqueueEvent(evt);
    }
    startColoredExecution(executionId) {
        return this.stateTracker.startColoredExecution(executionId);
    }
    get cfg() {
        return this._cfg;
    }
    get footprintsProcess() {
        return this._footprintsProcess;
    }
    registerGlobalAPI() {
        const globalObject = global;
        const sealights = '$$SeaLights$$';
        if (globalObject[sealights])
            return;
        globalObject[sealights] = {
            setCurrentTestIdentifier: (testIdentifier, silent) => {
                this.stateTracker.setTestIdentifier(testIdentifier, silent);
            },
            getCurrentTestIdentifier: () => {
                return this.stateTracker.getCurrentTestIdentifier();
            },
            pushEvent: (event) => {
                this.pushEvent(event);
            },
            shutdown: (callback) => {
                if (!callback)
                    throw new Error('\'callback\' is required.');
                this.stop(callback);
            }
        };
    }
    registerShutdownEvents() {
        const dummyCallback = () => {
        };
        process.on('SIGTERM', () => this.stop(dummyCallback));
        process.on('SIGINT', () => this.stop(dummyCallback));
    }
    // Enable if your'e running on windows and want to test shutdown process
    registerShutdownEventsOnWindows() {
        const readLine = (0, readline_1.createInterface)({
            input: process.stdin,
            output: process.stdout
        });
        const windowsListener = () => {
            console.log('before exit');
            this.stop(() => {
                process.exit();
            });
        };
        readLine.on('SIGINT', () => { windowsListener(); });
        readLine.on('SIGTERM', () => { windowsListener(); });
    }
}
exports.NodeJsAgent = NodeJsAgent;
//# sourceMappingURL=agent.js.map