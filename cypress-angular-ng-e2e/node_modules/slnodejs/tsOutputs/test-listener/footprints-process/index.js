"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FootprintsProcess = void 0;
const queue_1 = require("../queue");
const system_date_1 = require("../../common/system-date");
class FootprintsProcess {
    constructor(
    /**
     * Initial configuration
     */
    cfg, 
    /**
     * Background thread that tells the footprints service to send footprints from the queue to the server
     */
    sendToServerWatchdog, 
    /**
     * Foreground thread that prevents the process from shutting down, and kept alive while there are items to submit to the server or items are currently being submitted
     */
    keepaliveWatchdog, 
    /**
     * Configuration process that periodically refreshes server-sent configuration
     */
    configProcess, 
    /**
     * Proxy to the server for footprints submission
     */
    footprintsServiceProxy, 
    /**
     * Environments service, used to get environmental data for submission (process id, machine data, etc.)
     */
    environmentDataService, agentInstanceData, istanbulToFootprints, logger) {
        this.cfg = cfg;
        this.sendToServerWatchdog = sendToServerWatchdog;
        this.keepaliveWatchdog = keepaliveWatchdog;
        this.configProcess = configProcess;
        this.footprintsServiceProxy = footprintsServiceProxy;
        this.environmentDataService = environmentDataService;
        this.agentInstanceData = agentInstanceData;
        this.istanbulToFootprints = istanbulToFootprints;
        this.logger = logger;
        this.isSubmittingFootprints = false;
        this.sequence = 0;
        this.isRunning = false;
        this.stopCallbacks = [];
        if (!cfg)
            throw new Error('cfg was not specified');
        if (!sendToServerWatchdog)
            throw new Error('sendToServerWatchdog was not specified');
        if (!keepaliveWatchdog)
            throw new Error('keepaliveWatchdog was not specified');
        if (!configProcess)
            throw new Error('configProcess was not specified');
        if (!footprintsServiceProxy)
            throw new Error('footprintsServiceProxy was not specified');
        if (!environmentDataService)
            throw new Error('environmentDataService was not specified');
        if (!agentInstanceData)
            throw new Error('agentInstanceData was not specified');
        if (!istanbulToFootprints)
            throw new Error('istanbulToFootprints was not specified');
        if (!logger) {
            throw new Error('logger was not specified');
        }
        this.footprintsQueue = new queue_1.Queue();
        sendToServerWatchdog.on('alarm', () => {
            this.logger.debug('Start submitting footprints, triggered by send to server watchdog.');
            this.submitQueuedFootprints();
        });
        configProcess.on('configuration_changed', (cfg) => {
            this.updateConfig(cfg);
        });
        this.footprintsQueue.on('full', () => {
            this.logger.debug('Start submitting footprints, queue is full.');
            this.submitQueuedFootprints();
        });
        keepaliveWatchdog.on('alarm', () => {
            //console.log('keepaliveWatchdog. isSubmittingFootprints:' + this.isSubmittingFootprints + ', queue size: ' + this.footprintsQueue.getQueueSize());
            if (!this.isSubmittingFootprints && this.footprintsQueue.getQueueSize() == 0) {
                keepaliveWatchdog.stop();
            }
        });
    }
    enqueueCurrentFootprints(executionId, testName) {
        const footprints = this.istanbulToFootprints.getCurrentFootprints();
        const hitModules = Object.keys(footprints);
        if (!hitModules || hitModules.length == 0) { //If no modules were hit at all, don't enqueue anything
            this.logger.info('No files were hit, not enqueuing footprints.');
            return;
        }
        this.logger.info(`Enqueuing footprints for ${hitModules.length} files.`);
        this.footprintsQueue.enqueue({
            executionId: executionId,
            testName: testName,
            footprints: footprints,
            localTime: (0, system_date_1.getSystemDateValueOf)()
        });
        if (this.isRunning && this.cfg.sendFootprints.value && this.cfg.enabled.value) {
            this.ensureKeepaliveThreadRunning();
            this.sendToServerWatchdog.start();
        }
    }
    ensureKeepaliveThreadRunning() {
        this.keepaliveWatchdog.start();
    }
    updateConfig(updatedCfg) {
        if (updatedCfg.sendFootprints.value === false || updatedCfg.enabled.value === false) {
            this.footprintsQueue.clear();
            this.stop(() => { });
        }
        this.cfg = updatedCfg;
        this.sendToServerWatchdog.setInterval(this.cfg.interval.value);
    }
    createFootprintsPacket(items) {
        const packet = this.istanbulToFootprints.createFootprintsPackageForSending(items, {
            customerId: this.cfg.customerId.value,
            environment: this.environmentDataService.getEnvDataForSubmission(),
            configurationData: this.cfg.toJsonObject(),
            meta: {
                sequence: ++this.sequence,
                generated: (0, system_date_1.getSystemDateValueOf)(),
                agentId: this.agentInstanceData.agentId
            },
            tests: [],
            apps: []
        });
        return packet;
    }
    submitQueuedFootprints() {
        if (!this.isRunning) {
            this.logger.info('Agent is not running, not sending footprints');
            return;
        }
        if (this.cfg.sendFootprints.value === false) {
            this.logger.info('Not sending footprints since agent is configured to not send.');
            return; //Can't start without server or token
        }
        if (this.isSubmittingFootprints) {
            this.logger.info('Not sending footprints since its already submitting.');
            return;
        }
        if (this.footprintsQueue.getQueueSize() == 0) {
            this.logger.info('Not sending footprints since queue size is 0');
            return;
        }
        this.logger.info('About to send footprints. Queue size:' + this.footprintsQueue.getQueueSize());
        const items = this.footprintsQueue.dequeue(/*this.cfg.maxFootprintsChunkSize ||*/ 1000);
        const packet = this.createFootprintsPacket(items);
        this.isSubmittingFootprints = true;
        this.footprintsServiceProxy.submitFootprints(packet, (err) => {
            this.isSubmittingFootprints = false;
            this.logger.info('Sent footprints. Queue size:' + this.footprintsQueue.getQueueSize() + ', err:' + err);
            if (err) {
                this.environmentDataService.setLastError(err.stack);
                this.footprintsQueue.requeue(items); //Requeue items for later submission
            }
            else if (this.footprintsQueue.getQueueSize() > 0) { //If there was an error, don't send now. Otherwise, if the queue still has items, send those now
                this.submitQueuedFootprints();
            }
            else
                this.fireQueueEmpty();
        });
    }
    fireQueueEmpty() {
        if (this.stopCallbacks.length > 0) {
            this.stopCallbacks.forEach((cb) => {
                try {
                    cb();
                }
                catch (err) {
                    this.environmentDataService.setLastError(err.stack);
                }
            });
        }
    }
    start() {
        if (this.isRunning)
            return; //Already started
        if (this.cfg.enabled.value == false)
            return; //Don't do anything if agent is completely disabled
        this.isRunning = true;
        this.sendToServerWatchdog.start();
        if (this.footprintsQueue.getQueueSize() > 0) {
            this.ensureKeepaliveThreadRunning();
        }
    }
    stop(callback) {
        try {
            this.sendToServerWatchdog.stop();
            if (this.cfg.enabled.value === false || this.cfg.sendFootprints.value === false) { //Footprints/Agent functionality is disabled. Return immediately
                this.isRunning = false;
                return callback();
            }
            this.logger.debug('Start submitting footprints, triggered by stop event.');
            this.submitQueuedFootprints(); //If footprints are being submitted, this has no effect. Otherwise, it will start submitting footprints if the queue is non-empty
            if (this.isSubmittingFootprints) {
                /*
                    Nothing to do right now, since footprints are being submitted
                    When the submission is over (successfully or not), if the queue is empty the next batch of footprints will be sent.
                    If after submission the queue is cleared, this callback will be called
                */
                this.stopCallbacks.push(() => {
                    this.isRunning = false;
                    this.keepaliveWatchdog.stop();
                    return callback();
                });
            }
            else {
                /*
                    Queue must be empty, and nothing is sent. submitQueuedFootprints() would have started sending footprints if the queue was non-empty
                */
                this.isRunning = false;
                this.keepaliveWatchdog.stop();
                return callback();
            }
        }
        catch (err) {
            //TODO: log
            return callback();
        }
    }
    getQueueSize() {
        return this.footprintsQueue.getQueueSize();
    }
}
exports.FootprintsProcess = FootprintsProcess;
//# sourceMappingURL=index.js.map