"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IstanbulToFootprintsV3 = void 0;
const istanbul_to_footprints_base_1 = require("./istanbul-to-footprints-base");
const fs = require("fs");
const path = require("path");
const sourceMap = require("source-map");
class IstanbulToFootprintsV3 extends istanbul_to_footprints_base_1.IstanbulToFootprintsBase {
    constructor(cfg, logger) {
        super(logger);
        this.cfg = cfg;
        this.totalTests = 0;
        if (!logger)
            throw new Error('logger is required');
        if (!cfg)
            throw new Error('cfg is required');
    }
    resetState() {
        this.totalTests = 0;
        //Holds the a mapping between a uniqueId for an element in a test, to an index in this elements 'hits' array.
        this.eidToHitsIndex = {};
        this.uniqueIdToElement = {};
        this.testNameToTestData = {};
        this.fileNameToAppFile = {};
        this.fileToSourceMapConsumer = {};
    }
    createFootprintsPackageForSending(queuedFootprints, extraData) {
        this.resetState();
        const result = this.createFootprintsFile(extraData);
        const app = result.apps[0]; //We assume single App for now.
        const istanbulMaps = this.getIstanbulCounters();
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const context = this;
        queuedFootprints.forEach(fp => {
            const test = this.getOrCreateTestData(fp.testName, fp.executionId, fp.localTime, result);
            for (const moduleName in fp.footprints) {
                const istanbulModule = fp.footprints[moduleName];
                const moduleWithMaps = istanbulMaps[moduleName];
                this.logger.debug('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~');
                this.logger.debug(`moduleName: ${moduleName}`);
                if (!moduleWithMaps) {
                    continue;
                }
                const relPath = this.getRelativeModulePath(moduleWithMaps);
                if (!context.fileToSourceMapConsumer[relPath]) {
                    context.fileToSourceMapConsumer[relPath] = this.readSourceMaps(relPath);
                    this.logger.debug('Read source maps for file\':' + relPath + '\'');
                }
                const sourceMap = this.fileToSourceMapConsumer[relPath];
                const file = this.getOrCreateFootprintsAppFile(relPath, app);
                if (istanbulModule.f) {
                    for (const funcId in istanbulModule.f) {
                        const hits = istanbulModule.f[funcId];
                        if (hits > 0) {
                            const funcInfo = moduleWithMaps.fnMap[funcId];
                            let start = funcInfo.loc.start;
                            if (funcInfo.decl) {
                                start = funcInfo.decl.start; //For NYC
                            }
                            const sourceMapData = this.readSourceMapData(sourceMap, start, relPath);
                            let filePath = relPath;
                            if (sourceMapData) {
                                filePath = sourceMapData.originalFilename;
                                start = sourceMapData.originalStart;
                            }
                            const uniqueId = filePath + '@' + this.formatLoc(start);
                            const methodElement = this.getOrCreateMethodElement(uniqueId, file);
                            if (this.cfg.extendedFootprints.value) {
                                methodElement.funcInfo = JSON.stringify(funcInfo);
                                methodElement.sourceMapData = JSON.stringify(sourceMapData);
                            }
                            this.addOrUpdateElementHits(test, uniqueId, methodElement, hits);
                        }
                    }
                }
                if (istanbulModule.b) {
                    for (const branchId in istanbulModule.b) {
                        const ifElseAndSwitchCasesArr = istanbulModule.b[branchId];
                        const expressionInfo = moduleWithMaps.branchMap[branchId];
                        for (let idx = 0; idx < ifElseAndSwitchCasesArr.length; idx++) {
                            const branchInfo = expressionInfo.locations[idx];
                            const hits = ifElseAndSwitchCasesArr[idx];
                            if (hits > 0) {
                                let start = branchInfo.start;
                                const sourceMapData = this.readSourceMapData(sourceMap, start, relPath);
                                let filePath = relPath;
                                if (sourceMapData) {
                                    filePath = sourceMapData.originalFilename;
                                    start = sourceMapData.originalStart;
                                }
                                const uniqueId = filePath + '|' + this.formatLoc(start) + '|' + idx;
                                const branchElement = this.getOrCreateBranchElement(uniqueId, file);
                                if (this.cfg.extendedFootprints.value) {
                                    branchElement.branchInfo = JSON.stringify(branchInfo);
                                    branchElement.sourceMapData = JSON.stringify(sourceMapData);
                                }
                                this.addOrUpdateElementHits(test, uniqueId, branchElement, hits);
                            }
                        }
                    }
                }
            }
        });
        return result;
    }
    addOrUpdateElementHits(testData, elementUniqueId, element, hits) {
        const HITS_INDEX = 1;
        const eid = elementUniqueId + '|' + testData.index;
        const index = this.eidToHitsIndex[eid];
        if (index != null) {
            const testIndexAndHits = element.hits[index];
            let elementHits = testIndexAndHits[HITS_INDEX];
            elementHits = elementHits + hits;
            testIndexAndHits[HITS_INDEX] = elementHits;
        }
        else {
            const testIndexAndHits = new Array();
            testIndexAndHits.push(testData.index);
            testIndexAndHits.push(hits);
            const length = element.hits.push(testIndexAndHits);
            this.eidToHitsIndex[eid] = length - 1;
        }
    }
    getOrCreateTestData(testName, executionId, localTime, result) {
        if (!this.testNameToTestData[testName]) {
            const test = {
                executionId: executionId,
                localTime: localTime,
                testName: testName
            };
            result.tests.push(test);
            this.testNameToTestData[testName] = {
                index: this.totalTests++,
                test: test
            };
        }
        return this.testNameToTestData[testName];
    }
    getOrCreateMethodElement(uniqueId, file) {
        if (!this.uniqueIdToElement[uniqueId]) {
            const x = {
                hits: new Array(),
                uniqueId: uniqueId
            };
            this.uniqueIdToElement[uniqueId] = x;
            file.methods.push(x);
        }
        return this.uniqueIdToElement[uniqueId];
    }
    getOrCreateBranchElement(uniqueId, file) {
        if (!this.uniqueIdToElement[uniqueId]) {
            const x = {
                hits: new Array(),
                uniqueId: uniqueId
            };
            this.uniqueIdToElement[uniqueId] = x;
            file.branches.push(x);
        }
        return this.uniqueIdToElement[uniqueId];
    }
    getOrCreateFootprintsAppFile(fileName, app) {
        if (this.fileNameToAppFile[fileName]) {
            return this.fileNameToAppFile[fileName];
        }
        //File doesn't exist in request.
        const file = {
            methods: new Array(),
            branches: new Array(),
            lines: new Array(),
            path: fileName
        };
        app.files.push(file);
        this.fileNameToAppFile[fileName] = file;
        return file;
    }
    createFootprintsFile(extraData) {
        //Supporting only one app right now
        const app = {
            appName: this.cfg.appName.value,
            branchName: this.cfg.branch.value,
            buildName: this.cfg.build.value,
            moduleName: null,
            files: new Array()
        };
        extraData.apps.push(app);
        return extraData;
    }
    readSourceMaps(fullFilename) {
        if (!fullFilename)
            return;
        const sourceMapsFilename = fullFilename + '.map';
        let contents, rawSourceMapJsonData, consumer;
        try {
            contents = fs.readFileSync(sourceMapsFilename).toString();
        }
        catch (e) {
            //Sourcemap file not found
            return null;
        }
        try {
            rawSourceMapJsonData = JSON.parse(contents);
        }
        catch (e) {
            console.error('[Sealights] Ignoring invalid source map: ' + sourceMapsFilename);
            return null;
        }
        try {
            //console.log('Procssing source maps from file: '+sourceMapsFilename);
            consumer = new sourceMap.SourceMapConsumer(rawSourceMapJsonData);
            return consumer;
        }
        catch (e) {
            console.error('[Sealights] Error processing source maps for file: ' + sourceMapsFilename);
            return null;
        }
    }
    readSourceMapData(sourceMaps, start, coveragePath) {
        if (!sourceMaps)
            return null;
        try {
            //console.log('Checking original position for '+name+' at'+JSON.stringify(start));
            const originalPosition = sourceMaps.originalPositionFor(start); //{ line: start.line, column: start[1] });
            //console.log('Original position: '+JSON.stringify(originalPosition));
            if (originalPosition && originalPosition.source && originalPosition.line !== null && originalPosition.column !== null) {
                let originalFilename = originalPosition.source;
                if (originalFilename.indexOf('webpack:///webpack/') === -1 &&
                    originalFilename.indexOf('webpack:///external') === -1) { //Ignore embedded and external module
                    if (originalFilename.indexOf('webpack:///') === 0) {
                        originalFilename = originalFilename.substring(11); //'webpack:///'.length
                    }
                    originalFilename = this.fixRelPath(coveragePath, originalFilename);
                    const originalStart = { line: originalPosition.line, column: originalPosition.column };
                    const result = { originalFilename: originalFilename, originalStart: originalStart };
                    return result;
                }
            }
        }
        catch (e) {
            console.error(e);
        }
        return null;
    }
    fixRelPath(p1, p2) {
        try {
            if (!p1 || p1.length == 0)
                return p1;
            if (!p2 || p2.length == 0)
                return p1;
            //Make sure both paths are unix-style
            p1 = this.adjustPathSlashes(p1);
            p2 = this.adjustPathSlashes(p2);
            if (p2[0] == '/')
                return p2; //Absolute path
            const parts1 = p1.split('/');
            parts1.pop(); //remove the filename
            const parts2 = p2.split('/');
            const p3 = parts1.concat(parts2);
            const finalPath = this.adjustPathSlashes(path.normalize(p3.join('/')));
            return finalPath;
        }
        catch (err) {
            //log.error("Failed to fix real path for source maps. Error: " + err + ". Original File Name: " + p1 + ". Function: " + p2);
            return p2;
        }
    }
    adjustPathSlashes(filePath) {
        filePath = (filePath || '').replace(/\\/g, '/');
        return filePath;
    }
}
exports.IstanbulToFootprintsV3 = IstanbulToFootprintsV3;
//# sourceMappingURL=istanbul-to-footprints-v3.js.map