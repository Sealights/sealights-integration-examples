"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IstanbulToFootprintsBase = void 0;
const path = require("path");
const messages_formatter_1 = require("../../common/messages-formatter");
const GLOBAL_ISTANBUL_CONTAINER_NAMES = ['__coverage__'];
function newNumberArray(length) {
    const arr = [];
    for (let i = 0; i < length; i++)
        arr.push(0);
    return arr;
}
class IstanbulToFootprintsBase {
    constructor(logger) {
        this.previousIstanbulCounters = {};
        this.relativeModulePaths = {};
        this.logger = logger;
    }
    getIstanbulCounters() {
        if (this.globalCoverageContainer)
            return this.globalCoverageContainer;
        const re = /^\$\$cov_[0-9]+\$\$$/;
        const keys = Object.keys(global);
        if (this.logger.isDebugEnabled()) {
            this.logger.debug('The \'global\' object contains the following keys:\n\t' + keys.join('\n\t'));
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (let i = 0; i < keys.length; i++) {
            const k = keys[i];
            if ((re.exec(k)) !== null || GLOBAL_ISTANBUL_CONTAINER_NAMES.indexOf(k) >= 0) {
                this.globalCoverageContainer = global[k];
                return this.globalCoverageContainer;
            }
        }
        return null;
    }
    getRelativeModulePath(module) {
        if (!this.relativeModulePaths[module.path]) {
            this.relativeModulePaths[module.path] = path.relative(process.cwd(), module.path).replace(/\\/g, '/');
        }
        return this.relativeModulePaths[module.path];
    }
    formatLoc(loc) {
        return loc.line + ',' + loc.column;
    }
    getCurrentFootprints() {
        const diff = this.getIstanbulCountersDiff(this.getIstanbulCounters());
        return diff;
    }
    getIstanbulCountersDiff(currentCounters) {
        if (!currentCounters) {
            this.logger.error('Couldn\'t get istanbul counters, return empty diff.');
            return {};
        }
        const diff = {};
        let diffModule = null;
        function createModuleForDiff(istanbulModule) {
            diffModule = diff[istanbulModule] = { b: {}, f: {}, s: {} };
            return diffModule;
        }
        const prevCounters = this.previousIstanbulCounters;
        for (const istanbulModule in currentCounters) {
            diffModule = null;
            if (!prevCounters[istanbulModule]) {
                prevCounters[istanbulModule] = { b: {}, f: {}, s: {} };
            }
            const prevModule = prevCounters[istanbulModule];
            for (const funcId in currentCounters[istanbulModule].f) {
                if (prevModule.f[funcId] === undefined) {
                    prevModule.f[funcId] = 0;
                }
                const currentFunctionHits = currentCounters[istanbulModule].f[funcId];
                const prevFunctionHits = prevModule.f[funcId] || 0;
                if (currentFunctionHits > prevFunctionHits) {
                    //this is a diff
                    diffModule = diffModule || createModuleForDiff(istanbulModule);
                    diffModule.f[funcId] = (currentFunctionHits - prevFunctionHits);
                    prevModule.f[funcId] = currentFunctionHits;
                }
            }
            for (const branchId in currentCounters[istanbulModule].b) {
                const currentBranchesHits = currentCounters[istanbulModule].b[branchId];
                const prevBranchHits = prevModule.b[branchId];
                if (prevBranchHits) {
                    for (let i = 0, j = currentBranchesHits.length; i < j; i++) {
                        const currentHits = currentBranchesHits[i], previousHits = prevBranchHits[i] || 0;
                        if (currentHits > previousHits) {
                            //this is a diff
                            diffModule = diffModule || createModuleForDiff(istanbulModule);
                            diffModule.b[branchId] = diffModule.b[branchId] || newNumberArray(currentBranchesHits.length);
                            diffModule.b[branchId][i] = currentHits - previousHits;
                            prevBranchHits[i] = currentHits;
                        }
                    }
                }
                else {
                    prevModule.b[branchId] = currentBranchesHits.slice();
                    let branchSetHasHits = false;
                    for (let i = 0, j = currentBranchesHits.length; i < j && !branchSetHasHits; i++) {
                        if (currentBranchesHits[i])
                            branchSetHasHits = true;
                    }
                    if (branchSetHasHits) {
                        diffModule = diffModule || createModuleForDiff(istanbulModule);
                        diffModule.b[branchId] = currentBranchesHits.slice();
                    }
                }
            }
        }
        this.logDiff(diff);
        return diff;
    }
    logDiff(diff) {
        if (!this.logger.isDebugEnabled()) {
            return;
        }
        const modules = Object.keys(diff);
        const formatter = new messages_formatter_1.MessagesFormatter();
        modules.forEach((module) => {
            const methods = diff[module].f || {};
            const branches = diff[module].b || {};
            const methodsSize = Object.keys(methods).length;
            const branchesSize = Object.keys(branches).length;
            formatter.addContent(`${module}: ${methodsSize} methods and ${branchesSize} branches`);
        });
        this.logger.debug(`Found coverage data for ${modules.length} files:\n ${formatter.content}`);
    }
}
exports.IstanbulToFootprintsBase = IstanbulToFootprintsBase;
//# sourceMappingURL=istanbul-to-footprints-base.js.map