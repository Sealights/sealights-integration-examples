"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TsNodeHitsCollector = void 0;
const files_utils_1 = require("../../common/utils/files-utils");
const IstanbulCoverage = require("istanbul-lib-coverage");
const IstanbulSourceMapStore = require("istanbul-lib-source-maps");
const hits_collector_1 = require("../../common/footprints-process-v6/hits-collector");
class TsNodeHitsCollector extends hits_collector_1.HitsCollector {
    constructor() {
        super(...arguments);
        this._transformedFilesOutput = {};
    }
    getHitElements() {
        const _super = Object.create(null, {
            getHitElements: { get: () => super.getHitElements }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const hitFilesData = yield _super.getHitElements.call(this);
            const transformed = yield this.transformJsCoverageToTs();
            return this.extractHitsFromTransformedCoverage(hitFilesData, transformed);
        });
    }
    transformJsCoverageToTs() {
        return __awaiter(this, void 0, void 0, function* () {
            const globalCoverageObject = this.getGlobalCoverageObject();
            const coverageMap = IstanbulCoverage.createCoverageMap(globalCoverageObject);
            for (const fileName of coverageMap.files()) {
                const transformedCoverageFile = this._transformedFilesOutput[fileName];
                if (transformedCoverageFile) {
                    continue;
                }
                let transformedCoverageMap = null;
                try {
                    const singleCoverageMap = IstanbulCoverage.createCoverageMap({
                        [fileName]: coverageMap.fileCoverageFor(fileName),
                    });
                    transformedCoverageMap = yield IstanbulSourceMapStore.createSourceMapStore().transformCoverage(singleCoverageMap);
                    const fileNameAfterTransform = transformedCoverageMap.files().find(f => files_utils_1.FilesUtils.adjustPathSlashes(f) === files_utils_1.FilesUtils.adjustPathSlashes(fileName));
                    this._transformedFilesOutput[fileName] = transformedCoverageMap.fileCoverageFor(fileNameAfterTransform);
                }
                catch (err) {
                    this.errors.push({
                        fileName,
                        transformedCoverageMapKeys: Object.keys(transformedCoverageMap || {}),
                    });
                    this.logger.error(`Failed during the coverage transform with error: ${err.message}`);
                }
            }
            this._transformedFilesMap = IstanbulCoverage.createCoverageMap(this._transformedFilesOutput);
            return this._transformedFilesMap;
        });
    }
    extractHitsFromTransformedCoverage(hits, transformed) {
        return hits.map(hitObj => {
            const fileCoverage = transformed.fileCoverageFor(hitObj.filename);
            const fnMap = Object.values(fileCoverage.fnMap);
            const hitMethods = [];
            hitObj.hitMethods.forEach(hitMethod => {
                const transformedMethod = fnMap.find(x => x.name === hitMethod.name);
                if (transformedMethod) {
                    hitMethods.push({
                        name: hitMethod.name,
                        decl: transformedMethod.decl,
                        loc: transformedMethod.loc,
                        line: transformedMethod.loc.start.line,
                    });
                }
            });
            return {
                filename: hitObj.filename,
                hitMethods,
                hitBranches: [],
                shouldResolveRelativePath: true
            };
        });
    }
    getHitBranches(currentHits, fileHitSnapshot) {
        return [];
    }
}
exports.TsNodeHitsCollector = TsNodeHitsCollector;
//# sourceMappingURL=ts-node-hits-collector.js.map