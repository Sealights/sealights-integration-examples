"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Watchdog = void 0;
const events = require("events");
/**
 * Wraps timers to fire an "alarm" alarm after a given interval. Supports
 *
 * @export
 * @class Watchdog
 * @extends {events.EventEmitter}
 */
class Watchdog extends events.EventEmitter {
    constructor(options, timers) {
        super();
        this.options = options;
        this.timers = timers;
        this.handle = null;
        this.pendingAlarmDuringSuspended = false;
        this.suspended = false;
        this.stopped = true;
        if (!options) {
            throw new Error('options is required');
        }
        if (!timers) {
            throw new Error('timers is required');
        }
    }
    abort() {
        if (this.handle) {
            this.timers.clearTimeout(this.handle);
            this.handle = null;
            this.pendingAlarmDuringSuspended = false;
        }
    }
    /**
     * Restarts the watchdog
     *
     * @memberOf Watchdog
     */
    reset() {
        this.abort();
        if (!this.stopped) {
            this.handle = this.timers.setTimeout(() => { this.fireAlarm(); }, this.options.interval);
            if (this.options.unref) {
                this.handle.unref(); // Don't hold the process alive if this timer is still pending
            }
        }
    }
    /**
     * Stops the watchdog
     *
     *
     * @memberOf Watchdog
     */
    stop() {
        this.stopped = true;
        this.abort();
    }
    /**
     * Starts the watchdog
     *
     * @memberOf Watchdog
     */
    start() {
        this.stopped = false;
        this.reset();
    }
    /**
     * Returns the current status of the watchdog
     * @returns
     *
     * @memberOf Watchdog
     */
    getStatus() {
        return {
            pendingAlarmDuringSuspended: this.pendingAlarmDuringSuspended,
            running: !this.stopped,
            suspended: this.suspended,
        };
    }
    /**
     * Suspends this watchdog, which prevents it from firing events.
     *
     * @memberOf Watchdog
     */
    suspend() {
        this.suspended = true;
    }
    /**
     * Resumes this watchdog from suspended mode. If an alarm was fired while suspended, it will be fired now.
     *
     * @memberOf Watchdog
     */
    resume() {
        this.suspended = false;
        if (this.pendingAlarmDuringSuspended) {
            this.pendingAlarmDuringSuspended = false;
            this.fireAlarm();
        }
    }
    fireAlarm() {
        this.handle = null;
        if (this.suspended) {
            this.pendingAlarmDuringSuspended = true; //raise this flag and quit
        }
        else {
            try {
                this.emit('alarm', this);
            }
            catch (err) {
                // TODO: Log?
            }
        }
        if (this.options.autoReset) {
            this.reset();
        }
    }
    setInterval(newInterval) {
        if (newInterval <= 0)
            throw new Error('Invalid value for interval: ' + newInterval);
        this.options.interval = newInterval;
    }
    getInterval() {
        return this.options.interval;
    }
}
exports.Watchdog = Watchdog;
//# sourceMappingURL=watchdog.js.map