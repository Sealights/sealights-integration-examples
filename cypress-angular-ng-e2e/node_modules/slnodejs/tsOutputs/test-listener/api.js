"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.externalReport = exports.uploadReports = exports.endExecution = exports.startExecution = exports.uploadNycReport = exports.getVersion = exports.initAsync = exports.initAsyncWithCallback = exports.init = void 0;
const factory_1 = require("./factory");
const agent_1 = require("./agent");
const nyc_report_executor_1 = require("./nyc-report-executor");
const logger_1 = require("../common/logger");
const upload_report_handler_1 = require("./upload-report-handler");
const nyc_report_executor_fpv6_1 = require("./nyc-report-executor-fpv6");
const config_loader_1 = require("../common/config-process/config-loader");
const backend_proxy_1 = require("../common/http/backend-proxy");
const util = require("util");
const LOGGER = logger_1.LoggerFactory.getCreateApplicationLogger();
function init(runtimeCfg) {
    return initAsyncWithCallback(runtimeCfg, undefined, () => {
    });
}
exports.init = init;
function initAsyncWithCallback(runtimeCfg, toolInfo, callback) {
    const configLoader = new config_loader_1.ConfigLoader();
    const agentCfg = configLoader.loadAgentConfiguration(runtimeCfg && runtimeCfg.toJsonObject && runtimeCfg.toJsonObject());
    const factory = new factory_1.NodeAgentFactory(agentCfg);
    const agent = factory.getCreateNodeJsAgent();
    agent.start((err) => {
        agent.footprintsProcess.loadSlMapping().then(() => {
            if (err) {
                agent.stop(() => {
                    callback(err, agent);
                });
            }
            else {
                callback(err, agent);
            }
        });
    }, toolInfo);
    return agent;
}
exports.initAsyncWithCallback = initAsyncWithCallback;
function initAsync(runtimeCfg, toolInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        const initAsyncPromisified = util.promisify(initAsyncWithCallback);
        return yield initAsyncPromisified(runtimeCfg, toolInfo);
    });
}
exports.initAsync = initAsync;
function getVersion() {
    return agent_1.NodeJsAgent.getVersion();
}
exports.getVersion = getVersion;
function uploadNycReport(reportFile, agentCfg, agentInstanceData) {
    if (agentCfg.footprintsEnableV6.value) {
        return uploadNycReportFPV6(reportFile, agentCfg);
    }
    return new nyc_report_executor_1.NycReportExecutor(reportFile, agentCfg, agentInstanceData).execute();
}
exports.uploadNycReport = uploadNycReport;
function uploadNycReportFPV6(reportFile, agentConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeAgentFactory = new factory_1.NodeAgentFactory(agentConfig);
        return yield new nyc_report_executor_fpv6_1.NycReportExecutorFpv6(nodeAgentFactory.getCreateBackendProxy(), nodeAgentFactory.getCreateHitsCollector(), nodeAgentFactory.getCreateHitsConverter(), nodeAgentFactory.getCreateFootprintsBuffer(), agentConfig, reportFile, LOGGER).execute();
    });
}
function startExecution(args, httpConfig, callback) {
    LOGGER.info('[EXECUTION SERVICE] about to send start execution request');
    LOGGER.debug(`[START EXECUTION] execution request params are: ${JSON.stringify(args)}`);
    const requestCallback = (err, body) => {
        if (err) {
            LOGGER.error(`[START EXECUTION] error while starting execution '${err}'`);
            callback(err);
        }
        else {
            LOGGER.info('[START EXECUTION] execution started successfully');
            callback(null);
        }
    };
    const backEndProxy = new backend_proxy_1.BackendProxy(factory_1.NodeAgentFactory.getAgentInstanceData(), httpConfig, LOGGER);
    backEndProxy.startExecution(args, requestCallback);
}
exports.startExecution = startExecution;
function endExecution(args, httpConfig, callback) {
    LOGGER.info('[EXECUTION SERVICE] about to send end execution request');
    LOGGER.debug(`[END EXECUTION] execution request params are: ${JSON.stringify(args)}`);
    const requestCallback = (err, body) => {
        if (err) {
            LOGGER.error(`[END EXECUTION] error while trying to end execution '${err}'`);
            callback(err);
        }
        else {
            LOGGER.info('[END EXECUTION] execution ended successfully');
            callback(null);
        }
    };
    const backEndProxy = new backend_proxy_1.BackendProxy(factory_1.NodeAgentFactory.getAgentInstanceData(), httpConfig, LOGGER);
    backEndProxy.endExecution(args, requestCallback);
}
exports.endExecution = endExecution;
function uploadReports(args, httpConfig, agentData, callback) {
    LOGGER.info('[UPLOAD REPORTS] about to upload reports');
    LOGGER.debug(`[UPLOAD REPORTS] request params are: ${JSON.stringify(args)}`);
    const requestCallback = (err) => {
        if (err) {
            LOGGER.error(`[UPLOAD REPORTS] error while trying to upload reports ${err}`);
            callback(err);
        }
        else {
            LOGGER.info('[UPLOAD REPORTS] reports uploaded successfully');
            callback(null);
        }
    };
    const backEndProxy = new backend_proxy_1.BackendProxy(factory_1.NodeAgentFactory.getAgentInstanceData(), httpConfig, LOGGER);
    const handler = new upload_report_handler_1.UploadReportHandler(args, backEndProxy, agentData);
    handler.upload(requestCallback);
}
exports.uploadReports = uploadReports;
function externalReport(args, httpConfig, agentData, callback) {
    LOGGER.info('[UPLOAD EXTERNAL REPORT] about to send end execution request');
    LOGGER.debug(`[UPLOAD EXTERNAL REPORT] request params are: ${JSON.stringify(args)}`);
    const requestCallback = (err, body) => {
        if (err) {
            LOGGER.error(`[UPLOAD EXTERNAL REPORT] error while trying to upload external report '${err}'`);
            callback(err);
        }
        else {
            LOGGER.info('[UPLOAD EXTERNAL REPORT] report uploaded successfully');
            callback(null);
        }
    };
    const backEndProxy = new backend_proxy_1.BackendProxy(factory_1.NodeAgentFactory.getAgentInstanceData(), httpConfig, LOGGER);
    backEndProxy.externalReport(agentData, requestCallback);
}
exports.externalReport = externalReport;
//# sourceMappingURL=api.js.map