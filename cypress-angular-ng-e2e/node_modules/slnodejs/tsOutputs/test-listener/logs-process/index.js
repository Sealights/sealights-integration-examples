"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogsProcess = void 0;
const system_date_1 = require("../../common/system-date");
class LogsProcess {
    constructor(cfg, bufferingLogger, logServiceProxy, 
    /**
     * Environments service, used to get environmental data for submission (process id, machine data, etc.)
     */
    environmentDataService, agentInstanceData, 
    /**
     * Background thread that tells the events process to send events from the queue to the server
     */
    sendToServerWatchdog, 
    /**
     * Foreground thread that prevents the process from shutting down, and kept alive while there are items to submit to the server or items are currently being submitted
     */
    keepaliveWatchdog, logger) {
        this.cfg = cfg;
        this.bufferingLogger = bufferingLogger;
        this.logServiceProxy = logServiceProxy;
        this.environmentDataService = environmentDataService;
        this.agentInstanceData = agentInstanceData;
        this.sendToServerWatchdog = sendToServerWatchdog;
        this.keepaliveWatchdog = keepaliveWatchdog;
        this.logger = logger;
        this.sequence = 0;
        this.isSubmittingLogs = false;
        this.isRunning = false;
        this.stopCallbacks = [];
        if (!cfg) {
            throw new Error('cfg is required');
        }
        if (!bufferingLogger) {
            throw new Error('bufferingLogger is required');
        }
        if (!logServiceProxy) {
            throw new Error('logServiceProxy is required');
        }
        if (!environmentDataService) {
            throw new Error('environmentDataService is required');
        }
        if (!agentInstanceData) {
            throw new Error('agentInstanceData is required');
        }
        if (!sendToServerWatchdog) {
            throw new Error('sendToServerWatchdog was not specified');
        }
        if (!keepaliveWatchdog) {
            throw new Error('keepaliveWatchdog was not specified');
        }
        bufferingLogger.on('log_buffer_full', (buffer) => {
            if (buffer.length) {
                this.submitLogBuffer(buffer);
            }
        });
        sendToServerWatchdog.on('alarm', () => {
            if (this.cfg.sendLogs.value)
                this.bufferingLogger.checkBuffer(true);
        });
    }
    createLogsPacket(items) {
        const packet = {
            customerId: this.cfg.customerId.value,
            appName: this.cfg.appName.value,
            environment: this.environmentDataService.getEnvDataForSubmission(),
            configurationData: this.cfg.toJsonObject(),
            logs: items.map(t => JSON.stringify(t)),
            meta: {
                sequence: ++this.sequence,
                generated: (0, system_date_1.getSystemDateValueOf)(),
                agentId: this.agentInstanceData.agentId
            },
        };
        return packet;
    }
    submitLogBuffer(items) {
        if (!items.length)
            return;
        const packet = this.createLogsPacket(items);
        if (this.isSubmittingLogs) {
            //drop logs packet
            return;
        }
        this.isSubmittingLogs = true;
        this.logServiceProxy.submitLogs(packet, (err) => {
            if (err) {
                //log?
            }
            this.isSubmittingLogs = false;
            this.callStopCallbacks();
        });
    }
    start() {
        this.isRunning = true;
        this.sendToServerWatchdog.start();
    }
    callStopCallbacks() {
        if (this.stopCallbacks.length > 0) {
            this.stopCallbacks.forEach((cb) => {
                try {
                    cb();
                }
                catch (err) {
                    this.environmentDataService.setLastError(err.stack);
                }
            });
        }
    }
    stop(callback) {
        this.sendToServerWatchdog.stop();
        try {
            if (this.cfg.enabled.value === false || this.cfg.sendLogs.value === false) { //Log sending/Agent functionality is disabled. Return immediately
                this.isRunning = false;
                return callback();
            }
            this.bufferingLogger.checkBuffer(true);
            this.bufferingLogger.stop();
            if (this.isSubmittingLogs) {
                this.stopCallbacks.push(() => {
                    this.isRunning = false;
                    this.keepaliveWatchdog.stop();
                    return callback();
                });
            }
            else {
                this.isRunning = false;
                this.keepaliveWatchdog.stop();
                return callback();
            }
        }
        catch (err) {
            return callback();
        }
    }
}
exports.LogsProcess = LogsProcess;
//# sourceMappingURL=index.js.map