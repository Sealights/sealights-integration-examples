"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WaitForMultipleCallbacks = void 0;
class WaitForMultipleCallbacks {
    constructor() {
        this.processStatuses = {};
    }
    waitForAll(callback) {
        if (this.checkCompletion())
            return callback(); //Already done (happens when all callbacks have been synchronously called)
        else {
            if (this.completionCallback) {
                throw new Error('callback already set');
            }
            this.completionCallback = callback; //Not done yet. This callback will be invoked later in checkCompletionAndFireCallback()
        }
    }
    /**
     * Creates a named callback and waits for it to finish (asynchronously)
     * @param {string} name
     * @returns
     *
     * @memberOf WaitForMultipleCallbacks
     */
    getCallbackForProcess(name) {
        if (this.processStatuses.hasOwnProperty(name))
            throw new Error('Duplicate process name: ' + name);
        this.processStatuses[name] = false;
        return () => {
            this.processStatuses[name] = true;
            this.checkCompletionAndFireCallback();
        };
    }
    checkCompletionAndFireCallback() {
        if (this.checkCompletion()) {
            if (this.completionCallback) {
                const cb = this.completionCallback;
                this.completionCallback = null;
                cb();
            }
        }
    }
    /**
     * Checks if all callbacks have been called
     *
     * @returns true if all processes have been completed, false if some callbacks have yet to be called
     *
     * @memberOf WaitForMultipleCallbacks
     */
    checkCompletion() {
        for (const name in this.processStatuses) {
            if (this.processStatuses[name] === false)
                return false;
        }
        return true; //All done
    }
}
exports.WaitForMultipleCallbacks = WaitForMultipleCallbacks;
//# sourceMappingURL=wait-for-multiple-callbacks.js.map