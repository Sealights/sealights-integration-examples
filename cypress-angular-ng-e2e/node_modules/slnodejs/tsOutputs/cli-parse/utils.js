"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commonPathPrefix = exports.resolvePath = exports.createAgentConfig = void 0;
const config_1 = require("../common/config-process/config");
const path_1 = require("path");
const fs_1 = require("fs");
const path_2 = require("path");
function createAgentConfig(cmd) {
    const agentConfig = new config_1.AgentConfig();
    const agentConfigKeys = agentConfig.getLowerCaseToKeyMap();
    Object.keys(cmd).forEach(key => {
        const property = agentConfigKeys[key.toLowerCase()];
        if (property) {
            agentConfig[property].value = cmd[key];
        }
    });
    return agentConfig;
}
exports.createAgentConfig = createAgentConfig;
function resolvePath(name, value) {
    const resolved = (0, path_1.resolve)(value);
    if (!(0, fs_1.existsSync)(resolved)) {
        throw (new Error(`Invalid '${name}'. '${resolved}' doesn't exist`));
    }
    try {
        (0, fs_1.accessSync)(resolved); // Will throws if no access to the file. (https://nodejs.org/api/fs.html#fs_fs_accesssync_path_mode)
        return resolved;
    }
    catch (e) {
        throw (new Error(`Failed to resolve path for ${name}. error ${e}`));
    }
}
exports.resolvePath = resolvePath;
const determineSeparator = (paths) => {
    for (const path of paths) {
        const match = /(\/|\\)/.exec(path);
        if (match !== null)
            return match[0];
    }
    return path_2.sep;
};
// Taken as is an re-written to TypeScript from npm module common-path-prefix
const commonPathPrefix = (paths, sep = determineSeparator(paths)) => {
    const [first = '', ...remaining] = paths;
    if (first === '' || remaining.length === 0)
        return '';
    const parts = first.split(sep);
    let endOfPrefix = parts.length;
    for (const path of remaining) {
        const compare = path.split(sep);
        for (let i = 0; i < endOfPrefix; i++) {
            if (compare[i] !== parts[i]) {
                endOfPrefix = i;
            }
        }
        if (endOfPrefix === 0)
            return '';
    }
    const prefix = parts.slice(0, endOfPrefix).join(sep);
    return prefix.endsWith(sep) ? prefix : prefix + sep;
};
exports.commonPathPrefix = commonPathPrefix;
//# sourceMappingURL=utils.js.map