"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseExecutor = void 0;
const contracts_1 = require("../contracts");
const token_data_builder_1 = require("../../common/utils/token-data-builder");
const backend_proxy_1 = require("../../common/http/backend-proxy");
const build_session_data_builder_1 = require("../../common/utils/build-session-data-builder");
const agent_instance_data_1 = require("../agent-instance-data");
const cockpit_notifier_1 = require("../../common/agent-events/cockpit-notifier");
const agent_events_contracts_1 = require("../../common/agent-events/agent-events-contracts");
const logger_1 = require("../../common/logger");
const config_loader_1 = require("../../common/config-process/config-loader");
const v8_utils_1 = require("../../common/v8-utils");
const agent_time_synchronizer_1 = require("../agent-time-synchronizer");
const system_date_1 = require("../../common/system-date");
const http_client_1 = require("../../common/http/http-client");
/**
 * Base class for executing all CLI commands.
 * Verify that buildSessionId and token params are correct.
 * Also download the node agent if needed.
 */
class BaseExecutor {
    constructor() {
        this.logger = logger_1.LoggerFactory.getCreateApplicationLogger();
    }
    execute(args, extraArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            this.printCommandWithAgentId();
            this.extraArgs = extraArgs;
            let result = true;
            try {
                result = this.validateArgs(args);
                if (result) {
                    yield this.resolveBaseData(args);
                    yield this.getRemoteConfigFromServer(this._baseData);
                    const { timeClock } = this.agentRemoteConfig;
                    if (timeClock === null || timeClock === void 0 ? void 0 : timeClock.enabled) {
                        yield agent_time_synchronizer_1.AgentTimeSynchronizer.getCreateAgentTimeSynchronizer(timeClock === null || timeClock === void 0 ? void 0 : timeClock.syncIntervalSec, this.logger, this._baseData, agent_instance_data_1.agentInstanceData).initiateClockSync();
                    }
                    yield this.notifyAgentStarted(agent_instance_data_1.agentInstanceData, args);
                    this.notifyConfigurationChanged(this._baseData);
                    result = yield this.innerExecute(args, extraArgs);
                    yield this.notifyAgentShutdown();
                }
            }
            catch (e) {
                this.logger.error(e.message);
                result = false;
            }
            finally {
                this.exitProcess(result, args.failbuild);
            }
        });
    }
    printCommandWithAgentId() {
        this.logger.info(`Starting sealights agent with command '${this.commandName}',  agentId: ${agent_instance_data_1.agentInstanceData.agentId}`);
    }
    printAgentVersionAndAgentId() {
        this.logger.lifecycle(`slnodejs agent version: ${agent_instance_data_1.agentInstanceData.agentVersion},  agentId: ${agent_instance_data_1.agentInstanceData.agentId}`);
    }
    resolveBaseData(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenData = new token_data_builder_1.TokenDataBuilder().build(args);
            if (!tokenData.isValid) {
                throw new Error('Invalid token. Skipping sealights integration. See log for more details');
            }
            const httpConfig = Object.assign(Object.assign({}, tokenData), { proxy: args.proxy });
            const backendProxy = new backend_proxy_1.BackendProxy(agent_instance_data_1.agentInstanceData, httpConfig, this.logger);
            const buildSessionData = yield this.getBuildSessionData(backendProxy, args);
            if (!buildSessionData) {
                throw new Error('Invalid build session data. Skipping sealights integration. See log for more details');
            }
            backendProxy.updateMetadata({
                buildSessionId: buildSessionData.buildSessionId
            });
            this._baseData = Object.assign(Object.assign(Object.assign({}, tokenData), buildSessionData), { proxy: args.proxy, labid: args.labid });
        });
    }
    exitProcess(result, failbuild) {
        result ? this.logSuccess() : this.logError('Additional data may be found by turning on logs via the NODE_DEBUG=sl environment variable');
        let statusCode = 0;
        const shouldFail = !result && failbuild;
        if (shouldFail) {
            statusCode = failbuild ? 1 : 0;
        }
        process.exit(statusCode);
    }
    /**
     * If some command needs to do some validation before downloading the agent, this method can be overridden.
     * @default true
     * @param args
     */
    validateArgs(args) {
        return true;
    }
    set baseData(value) {
        this._baseData = value;
    }
    get baseData() {
        return this._baseData;
    }
    getBuildSessionData(backendProxy, cmd) {
        return __awaiter(this, void 0, void 0, function* () {
            const buildSessionDataBuilder = new build_session_data_builder_1.BuildSessionDataBuilder(backendProxy);
            return yield buildSessionDataBuilder.build(cmd);
        });
    }
    logSuccess() {
        this.logger.lifecycle(`Command '${this.commandName}' finished successfully`);
    }
    logError(err) {
        this.logger.lifecycle(`Failed to run command '${this.commandName}'! ${err || ''}`);
    }
    notifyAgentStarted(agentInstanceData, cmdArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            agentInstanceData.AgentAllocatedMemoryInMb = yield v8_utils_1.V8Utils.heapSizeLimitMB();
            const agentConfig = this.createAgentConfig(cmdArgs);
            try {
                yield cockpit_notifier_1.CockpitNotifier.notifyStart(agentConfig, agentInstanceData, this.logger, system_date_1.getSystemOffset);
            }
            catch (e) {
                this.logger.error(`Failed to submit agent start event, Error: '${e}'`);
            }
        });
    }
    createAgentConfig(cmdArgs) {
        // We named build, branch and labId differently in base data vs config, this should be properly redesigned with bellow fix
        const cmd = Object.assign(Object.assign({}, this.baseData), { branch: this.baseData.branchName, build: this.baseData.buildName, labId: this.baseData.labid });
        if (cmdArgs[contracts_1.COMMAND_ARGS.INSTRUMENT_FOR_BROWSERS]) {
            cmd[contracts_1.COMMAND_ARGS.USE_OTEL] =
                cmdArgs[contracts_1.COMMAND_ARGS.ENABLE_OPEN_TELEMETRY];
        }
        const agentConfig = new config_loader_1.ConfigLoader().loadAgentConfiguration(cmd);
        if (this.agentRemoteConfig) {
            Object.keys(this.agentRemoteConfig).forEach(key => {
                if (agentConfig[key] !== undefined) {
                    agentConfig[key].value = this.agentRemoteConfig[key];
                }
            });
        }
        // Configuration process should be properly redesigned
        // this is just a temporary workaround
        if (agentConfig.httpAttemptInterval.hasValue) {
            backend_proxy_1.BackendProxy.DEFAULT_HTTP_ATTEMPT_INTERVAL = agentConfig.httpAttemptInterval.value;
        }
        if (agentConfig.httpMaxAttempts.hasValue) {
            backend_proxy_1.BackendProxy.DEFAULT_HTTP_MAX_ATTEMPTS = agentConfig.httpMaxAttempts.value;
        }
        if (agentConfig.httpTimeout.hasValue) {
            http_client_1.HttpClient.DEFAULT_HTTP_TIMEOUT = agentConfig.httpTimeout.value;
        }
        return agentConfig;
    }
    notifyAgentShutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield cockpit_notifier_1.CockpitNotifier.notifyShutdown();
            }
            catch (e) {
                this.logger.error(`Failed to submit agent shutdown event, Error: '${e}'`);
            }
        });
    }
    getRemoteConfigFromServer(agentBaseData) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const backendProxy = new backend_proxy_1.BackendProxy(agent_instance_data_1.agentInstanceData, agentBaseData, this.logger);
                const remoteConfig = yield backendProxy.getRemoteConfigPromise(agentBaseData);
                this.agentRemoteConfig = remoteConfig || {};
            }
            catch (e) {
                this.logger.warn(`Failed to receive remote config, error: '${e}'. Using init config from cmd args and env vars`);
                this.agentRemoteConfig = {};
            }
        });
    }
    notifyConfigurationChanged(cmdArgs) {
        if (Object.keys(this.agentRemoteConfig).length > 0) {
            const agentConfig = new config_loader_1.ConfigLoader().loadAgentConfiguration(cmdArgs);
            const eventData = {
                agentConfig: Object.assign(Object.assign({}, agentConfig.toJsonObject()), this.agentRemoteConfig),
            };
            cockpit_notifier_1.CockpitNotifier.sendEvent(agent_events_contracts_1.AgentEventCode.AGENT_CONFIG_CHANGED, eventData);
        }
    }
}
exports.BaseExecutor = BaseExecutor;
//# sourceMappingURL=base-executor.js.map