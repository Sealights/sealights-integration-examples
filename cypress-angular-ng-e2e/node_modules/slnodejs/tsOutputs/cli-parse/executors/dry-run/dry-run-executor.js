"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DryRunExecutor = void 0;
const base_executor_1 = require("../base-executor");
const dry_run_proxy_1 = require("../../../common/http/dry-run-proxy");
const utils_1 = require("../../utils");
const fs_1 = require("fs");
const Constants = require("../../constants/constants");
const cockpit_notifier_1 = require("../../../common/agent-events/cockpit-notifier");
const rimraf_1 = require("rimraf");
const path_1 = require("path");
const dry_run_validation_1 = require("./dry-run-validation");
const table_1 = require("table");
const chalk_1 = require("chalk");
const agent_events_contracts_1 = require("../../../common/agent-events/agent-events-contracts");
const flatMap = require("lodash.flatmap");
const build_args_dto_1 = require("../build-args-dto");
const build_mapping_data_1 = require("./build-mapping-data");
const footprints_data_1 = require("./footprints-data");
const helper_methods_1 = require("./helper-methods");
const logger_1 = require("../../../common/logger");
const interface_1 = require("../../../build-scanner/source-map-eraser/interface");
class DryRunExecutor extends base_executor_1.BaseExecutor {
    constructor() {
        super(...arguments);
        this.commandName = 'dryRun';
        this._validations = new Map();
    }
    execute(args, extraArgs) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.printAgentVersionAndAgentId();
                this.validateArgs(args);
                const dryRunProxy = new dry_run_proxy_1.DryRunProxy();
                this.init(dryRunProxy);
                this.printCommandWithAgentId();
                const buildArguments = this.mapArgs(args);
                const buildMappingData = yield build_mapping_data_1.BuildMappingData.run(dryRunProxy, buildArguments, this.logger);
                yield this.verifyBuildMappingData(buildMappingData);
                const footprintsData = yield footprints_data_1.FootprintsData.run(buildArguments, this.logger, dryRunProxy);
                this.validateIds(buildMappingData, footprintsData, buildArguments.depth);
                this.printResult(dryRunProxy, args, footprintsData, buildMappingData);
                if ((_a = buildMappingData.buildMappingResult) === null || _a === void 0 ? void 0 : _a.err) {
                    throw buildMappingData.buildMappingResult.err;
                }
            }
            catch (e) {
                console.log(chalk_1.default.red(`${Constants.DONE_WITH_ERROR_MSG} '${e}'`));
            }
        });
    }
    innerExecute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    verifyBuildMappingData(buildMappingData) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!buildMappingData.hasColumnInfo()) {
                this._validations.get(dry_run_validation_1.Validations.COLUMN_INFO).setFailure();
            }
            if (yield buildMappingData.hasGitPathDiff()) {
                this._validations.get(dry_run_validation_1.Validations.GIT_PATH).setFailure();
            }
            if ((_a = buildMappingData.rawThirdParties) === null || _a === void 0 ? void 0 : _a.length) {
                (0, helper_methods_1.saveArrayToFile)(Constants.THIRD_PARTY_RAW_FILES_FILENAME, buildMappingData.rawThirdParties);
                this.validations.get(dry_run_validation_1.Validations.RAW_THIRD_PARTY).setFailure(buildMappingData.rawThirdParties.toString());
            }
            if ((_b = buildMappingData.logicalThirdParties) === null || _b === void 0 ? void 0 : _b.length) {
                (0, helper_methods_1.saveArrayToFile)(Constants.THIRD_PARTY_LOGICAL_FILES_FILENAME, buildMappingData.logicalThirdParties);
                this.validations.get(dry_run_validation_1.Validations.LOGICAL_THIRD_PARTY).setFailure(buildMappingData.logicalThirdParties.toString());
            }
        });
    }
    init(dryRunProxy) {
        this.clearCreateDryRunOutputDir();
        this.initCheckMarks();
        (0, helper_methods_1.saveDataToFile)(Constants.PROCESS_ARGS_FILENAME, process.argv);
        this.logger = logger_1.LoggerFactory.getCreateDebugFileLogger((0, path_1.join)(Constants.DRY_RUN_OUTPUT, Constants.LOG_FILE));
        cockpit_notifier_1.CockpitNotifier.setDryRunMode(this.logger, dryRunProxy);
    }
    printResult(dryRunProxy, args, footprintsData, buildMappingData) {
        this.printCounters(buildMappingData.buildMapping);
        this.printCheckMarks();
        this.printAgentEvents(dryRunProxy.agentEvents);
        if (args.verbose) {
            buildMappingData.printVerbose();
            footprintsData.printVerbose();
        }
    }
    printAgentEvents(agentEvents) {
        (0, helper_methods_1.saveDataToFile)(Constants.AGENT_EVENTS_FILENAME, agentEvents);
        const eventsEntries = agentEvents.map(entry => entry.events);
        const warningsAndErrors = flatMap(eventsEntries).filter(this.isErrorOrWarning);
        if (warningsAndErrors.length > 0) {
            (0, helper_methods_1.saveDataToFile)(Constants.ERROR_WARNINGS_FILENAME, warningsAndErrors);
            console.log(chalk_1.default.yellow(` ${warningsAndErrors.length} ${Constants.AGENT_EVENTS_ERROR_MSG}\n`));
        }
    }
    /**
     * Warning are in range 3000 (3000-3999), errors are in range 4000 (4000-4999).
     * Checks if event is within those ranges
     * @param event
     * @private
     */
    isErrorOrWarning(event) {
        return event.type >= agent_events_contracts_1.AgentEventCode.WARN && event.type <= agent_events_contracts_1.AgentEventCode.FOOTPRINTS_LOSS;
    }
    get validations() {
        return this._validations;
    }
    mapArgs(args) {
        let excludeSourceMapFiles;
        if (args.excludeSourceMapFiles === undefined) {
            excludeSourceMapFiles = interface_1.SourceMapsEraserModes.None;
        }
        else if (args.excludeSourceMapFiles === true) {
            excludeSourceMapFiles = interface_1.SourceMapsEraserModes.SkipCopy;
        }
        else {
            excludeSourceMapFiles = args.excludeSourceMapFiles;
        }
        return Object.assign(Object.assign({}, build_args_dto_1.BuildArgsDTO.create(args)), { appname: 'app1', build: 'build1', branch: 'branch1', customerId: 'customer1', token: 't1', server: 'http://sealights.co/api', buildSessionId: 'bs1', workspacepath: (0, utils_1.resolvePath)('workspacepath', args.workspacepath), outputpath: (0, path_1.join)(Constants.DRY_RUN_OUTPUT, args.outputpath || Constants.INSTRUMENTATION_OUTPUT), folderDepth: parseInt(args.folderDepth), hasNycReport: args.hasNycReport, report: args.report, nycProjectRoot: args.nycProjectRoot, projectRoot: args.buildScanProjectRoot, sendContributors: true, instrumentationOnly: false, excludeSourceMapFiles, experimentalSizeReduction: process.env['SL_experimentalSizeReduction'] || false });
    }
    validateArgs(args) {
        if (!args.workspacepath) {
            throw '\'Workspace\' is mandatory, please use \'--help\' flag to see the usage';
        }
        return true;
    }
    validateIds(buildMappingData, footprintsData, depth) {
        this.validatePaths(buildMappingData, footprintsData);
        this.validatePositions(footprintsData.uniqueIdsByPath(), buildMappingData.uniqueIdsByPath());
    }
    validatePositions(footprintsPathToIds, buildScanPathToIds) {
        let footprintIds = [];
        let buildScanIds = [];
        Object.keys(footprintsPathToIds).forEach((path) => {
            if (buildScanPathToIds[path]) {
                footprintIds = footprintIds.concat(footprintsPathToIds[path]);
                buildScanIds = buildScanIds.concat(buildScanPathToIds[path]);
            }
        });
        const gap = (0, helper_methods_1.calculateDiffPercentage)(footprintIds, buildScanIds);
        if (isNaN(gap)) {
            this._validations.get(dry_run_validation_1.Validations.POSITION).setStatus(dry_run_validation_1.Status.NOT_APPLICABLE);
        }
        else if (gap >= Constants.POSITION_DIFF_PERCENT_TO_WARN) {
            this._validations.get(dry_run_validation_1.Validations.POSITION).setFailure(gap);
        }
    }
    validatePaths(buildMappingData, footprintsData) {
        const gap = (0, helper_methods_1.calculateDiffPercentage)(footprintsData.truncateFilesPathByDepth(), buildMappingData.truncateFilesPathByDepth());
        if (isNaN(gap)) {
            this._validations.get(dry_run_validation_1.Validations.NYC_PATH).setStatus(dry_run_validation_1.Status.NOT_APPLICABLE);
        }
        else if (gap >= Constants.PATH_DIFF_PERCENT_TO_WARN) {
            this._validations.get(dry_run_validation_1.Validations.NYC_PATH).setFailure(gap);
        }
    }
    clearCreateDryRunOutputDir() {
        if ((0, fs_1.existsSync)(Constants.DRY_RUN_OUTPUT)) {
            (0, rimraf_1.sync)(Constants.DRY_RUN_OUTPUT);
        }
        (0, fs_1.mkdirSync)(Constants.DRY_RUN_OUTPUT);
    }
    initCheckMarks() {
        this._validations.set(dry_run_validation_1.Validations.COLUMN_INFO, new dry_run_validation_1.NoColumnValidation());
        this._validations.set(dry_run_validation_1.Validations.GIT_PATH, new dry_run_validation_1.GitPathsValidation());
        this._validations.set(dry_run_validation_1.Validations.RAW_THIRD_PARTY, new dry_run_validation_1.RawThirdPartyValidation());
        this._validations.set(dry_run_validation_1.Validations.LOGICAL_THIRD_PARTY, new dry_run_validation_1.LogicalThirdPartyValidation());
        this._validations.set(dry_run_validation_1.Validations.NYC_PATH, new dry_run_validation_1.NycPathsValidation());
        this._validations.set(dry_run_validation_1.Validations.POSITION, new dry_run_validation_1.PositionValidation());
    }
    printCheckMarks() {
        console.log(chalk_1.default.blue('Analysis completed, found the following:\n'));
        console.log(chalk_1.default.blue(`${Constants.DRY_RUN_DOCUMENTATION_MSG}\n`));
        const headers = ['Name', 'Status', 'Message'];
        const checkMarksArr = [headers];
        this._validations.forEach(value => checkMarksArr.push(value.toPrintableArray()));
        const config = {
            columnDefault: {
                wrapWord: true,
            },
            columns: [
                { alignment: 'left' },
                { alignment: 'center' },
                { alignment: 'left', width: 120 }
            ],
        };
        console.log((0, table_1.table)(checkMarksArr, config));
    }
    printCounters(buildMapping) {
        console.log(chalk_1.default.blue(`Scanned ${buildMapping.counters.methods} methods and ${buildMapping.counters.branches} branches in ${buildMapping.files.length}  files.\n`));
    }
}
exports.DryRunExecutor = DryRunExecutor;
//# sourceMappingURL=dry-run-executor.js.map