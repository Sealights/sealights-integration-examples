"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildExecutor = void 0;
const base_executor_1 = require("./base-executor");
const contracts_1 = require("../contracts");
const cia_1 = require("../../build-scanner/cia");
const agent_instance_data_1 = require("../../common/agent-instance-data");
const agent_events_contracts_1 = require("../../common/agent-events/agent-events-contracts");
const utils_1 = require("../utils");
const build_args_dto_1 = require("./build-args-dto");
const cockpit_notifier_1 = require("../../common/agent-events/cockpit-notifier");
const interface_1 = require("../../build-scanner/source-map-eraser/interface");
const fs_1 = require("fs");
const path_1 = require("path");
const utils_2 = require("../utils");
class BuildExecutor extends base_executor_1.BaseExecutor {
    constructor() {
        super(...arguments);
        this.commandName = 'build';
    }
    innerExecute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            this.printAgentVersionAndAgentId();
            const mappedArgs = this.mapArgs(args);
            yield this.setConfigFromRemote(mappedArgs);
            return new Promise((resolve) => {
                new cia_1.CIA().run(mappedArgs, (err) => {
                    if (err) {
                        this.logError(err);
                    }
                    if (mappedArgs.awsConfigure && !err) {
                        this.logger.lifecycle('AWS Configure was enabled. Writing sl-config.json file to workspace sub-directories.');
                        this.writeSlConfigFileRecursive(mappedArgs, mappedArgs.workspacepath);
                    }
                    return resolve(err == null);
                });
            });
        });
    }
    writeSlConfigFile(args, filePath, commonSrcPrefix, slMapping) {
        const slConfig = {
            token: args.token,
            buildSessionId: args.buildSessionId,
            collectorUrl: args.collectorUrl,
            projectRoot: args.projectRoot,
            labId: args.labid,
            commonSrcPrefix,
            slMapping
        };
        const configFile = (0, path_1.join)(filePath, 'sl-config.json');
        (0, fs_1.writeFileSync)(configFile, JSON.stringify(slConfig, null, 2));
        this.logger.info(`sl-config.json file was written to ${filePath}`);
    }
    // This method will return all sub-directories of the workspace directory. We store the sl-config in each of them in order to make the config file always accessible for our Node Lambda layer
    getWorkspaceSubDirectories(directory) {
        const subDirectories = [];
        const filesAndDirectories = (0, fs_1.readdirSync)(directory);
        for (const item of filesAndDirectories) {
            const itemPath = (0, path_1.join)(directory, item);
            const stats = (0, fs_1.statSync)(itemPath);
            if (stats.isDirectory()) {
                subDirectories.push(itemPath);
                const subSubDirectories = this.getWorkspaceSubDirectories(itemPath);
                subDirectories.push(...subSubDirectories);
            }
        }
        return subDirectories;
    }
    writeSlConfigFileRecursive(args, directory) {
        // Get the project paths from project-files.json
        const { files, slMapping } = JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(process.cwd(), 'project-files.json'), 'utf8'));
        (0, fs_1.unlinkSync)((0, path_1.join)(process.cwd(), 'project-files.json'));
        const commonSrcPrefix = (0, utils_2.commonPathPrefix)(files);
        // Write the initial sl-config.json file
        this.writeSlConfigFile(args, directory, commonSrcPrefix, slMapping);
        const subDirectories = this.getWorkspaceSubDirectories(directory);
        // Write the sl-config.json file to all sub-directories
        subDirectories.forEach(subDirectory => {
            this.writeSlConfigFile(args, subDirectory, commonSrcPrefix, slMapping);
        });
    }
    setConfigFromRemote(mappedArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            mappedArgs.removeSensitiveData = this.agentRemoteConfig.removeSensitiveData || false;
            mappedArgs.useRelativeSlMapping = this.agentRemoteConfig.useRelativeSlMapping || false;
            mappedArgs.enableDiagnostic = !!this.agentRemoteConfig.enableDiagnostic;
            mappedArgs.experimentalSizeReduction = !!this.agentRemoteConfig.experimentalSizeReduction;
            mappedArgs.useBranchCoverage = !!this.agentRemoteConfig.useBranchCoverage;
            mappedArgs.newInstrumenter = mappedArgs.newInstrumenter || !!this.agentRemoteConfig.newInstrumenter;
            if (typeof mappedArgs.sourceHash === 'undefined') {
                mappedArgs.sourceHash = !!this.agentRemoteConfig.sourceHash;
            }
            mappedArgs.additionalGitDetails = !!this.agentRemoteConfig.additionalGitDetails || false;
            if (mappedArgs.useRelativeSlMapping) {
                cockpit_notifier_1.CockpitNotifier.sendGenericMessage('Relative sl-mapping feature was turned on');
                if (mappedArgs.useModulePrefix) {
                    const message = 'Both \'relativeSlMapping\' and \'useModulePrefix\' turned on, it might affects coverage correctness';
                    cockpit_notifier_1.CockpitNotifier.sendWarning(message);
                    this.logger.lifecycle(message);
                }
            }
        });
    }
    setAliasCommand(alias) {
        this.commandName = alias;
        return this;
    }
    validateArgs(args) {
        var _a;
        this.handleLegacyCommand(args);
        if ((args.workspacepath === args.outputpath) && args.outputpath) {
            this.logger.lifecycle('\'outputpath\' and \'workspacepath\' cannot be the same');
            return false;
        }
        if (((_a = args.allowCORS) === null || _a === void 0 ? void 0 : _a.length) && !args.enableOpenTelemetry) {
            this.logger.lifecycle(`--enableOpenTelemetry must be specified when using --allowCORS option.`);
            return false;
        }
        if (args.dependency || args.dependenciesFile) {
            if (args.workspacepath) {
                this.logger.lifecycle('\'workspacepath\' is ignored when submitting an integration build');
            }
            if (args.scm) {
                this.logger.lifecycle('\'scm\' is ignored when submitting an integration build');
            }
        }
        else {
            if (!args.workspacepath) {
                this.logger.lifecycle('\'workspacepath\' argument is required but was not specified');
                return false;
            }
            if (!args.scm) {
                this.logger.lifecycle('\'scm\' argument is required but was not specified');
                return false;
            }
        }
        this.resolvePathArgs(args);
        return true;
    }
    handleLegacyCommand(args) {
        var _a;
        const mainCommand = (_a = args === null || args === void 0 ? void 0 : args.args) === null || _a === void 0 ? void 0 : _a[0];
        if (mainCommand === contracts_1.COMMANDS.BUILD) {
            this.logger.lifecycle(`'build' command is deprecated and should be replaced by the 'scan' command `);
        }
    }
    notifyAgentStarted(agentInstanceData, cmd) {
        const _super = Object.create(null, {
            notifyAgentStarted: { get: () => super.notifyAgentStarted }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const buildScannerAgentInstanceData = new agent_instance_data_1.AgentInstanceData(agent_events_contracts_1.AgentTypes.BUILD_SCANNER, agent_events_contracts_1.AgentTechnologies.NODEJS);
            return _super.notifyAgentStarted.call(this, buildScannerAgentInstanceData, cmd);
        });
    }
    resolvePathArgs(args) {
        if (args.workspacepath) {
            args.workspacepath = (0, utils_1.resolvePath)('workspacepath', args.workspacepath);
        }
        if (args.dependenciesFile) {
            args.dependenciesFile = (0, utils_1.resolvePath)('dependenciesFile', args.dependenciesFile);
        }
    }
    /*
       The cia Receives parameters with different name/casing so as part of mapping those need to adjust.
       appName => appname.
       buildName => build.
       branchName => branch.
       customerId => customerid
     */
    mapArgs(args) {
        let excludeSourceMapFiles;
        if (args.excludeSourceMapFiles === undefined) {
            excludeSourceMapFiles = interface_1.SourceMapsEraserModes.None;
        }
        else if (args.excludeSourceMapFiles === true) {
            excludeSourceMapFiles = interface_1.SourceMapsEraserModes.SkipCopy;
        }
        else {
            excludeSourceMapFiles = args.excludeSourceMapFiles;
        }
        return Object.assign(Object.assign(Object.assign({}, build_args_dto_1.BuildArgsDTO.create(args)), this.baseData), { appname: this.baseData.appName, build: this.baseData.buildName, branch: this.baseData.branchName, customerId: this.baseData.customerid, excludeSourceMapFiles });
    }
}
exports.BuildExecutor = BuildExecutor;
//# sourceMappingURL=build-executor.js.map