/// <reference types="node" />
import events = require('events');
export interface ITimers {
    setTimeout(callback: any, time: any): any;
    clearTimeout(handle: any): void;
}
export interface IWatchdog {
    reset(): any;
    stop(): any;
    start(): any;
    getStatus(): any;
    startIfNotRunning(): any;
    on(event: string | symbol, listener: (...args: any[]) => void): any;
}
export declare class WatchdogOptions {
    interval: number;
    name?: string;
    /**
     * Makes the watchdog Auto-Reset, immediately restarting itself after firing the "alarm" event
     * Defaults to false
     *
     * @type {boolean}
     * @memberOf IWatchdogOptions
     */
    autoReset?: boolean;
    /**
     * Makes this timer run in the background by calling the unref() method on the timer handle.
     * Running in the foreground (default) prevents the process from exiting, while running background doesn't.
     * Defaults to false
     *
     * @type {boolean}
     * @memberOf IWatchdogOptions
     */
    unref?: boolean;
}
/**
 * Wraps timers to fire an "alarm" alarm after a given interval. Supports
 *
 * @export
 * @class Watchdog
 * @extends {events.EventEmitter}
 */
export declare class Watchdog extends events.EventEmitter implements IWatchdog {
    private options;
    private timers;
    private handle;
    private pendingAlarmDuringSuspended;
    private suspended;
    private stopped;
    constructor(options: WatchdogOptions, timers: ITimers);
    abort(): void;
    /**
     * Restarts the watchdog
     *
     * @memberOf Watchdog
     */
    reset(): void;
    /**
     * Stops the watchdog
     *
     *
     * @memberOf Watchdog
     */
    stop(): void;
    /**
     * Starts the watchdog
     *
     * @memberOf Watchdog
     */
    start(): void;
    startIfNotRunning(): void;
    /**
     * Returns the current status of the watchdog
     * @returns
     *
     * @memberOf Watchdog
     */
    getStatus(): {
        pendingAlarmDuringSuspended: boolean;
        running: boolean;
        suspended: boolean;
    };
    /**
     * Suspends this watchdog, which prevents it from firing events.
     *
     * @memberOf Watchdog
     */
    suspend(): void;
    /**
     * Resumes this watchdog from suspended mode. If an alarm was fired while suspended, it will be fired now.
     *
     * @memberOf Watchdog
     */
    resume(): void;
    private fireAlarm;
    setInterval(newInterval: number): void;
    getInterval(): number;
}
