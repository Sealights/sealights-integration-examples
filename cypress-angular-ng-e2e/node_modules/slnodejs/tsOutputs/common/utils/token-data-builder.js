"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenDataBuilder = void 0;
const jwtDecode = require("jwt-decode");
const abstract_data_builder_1 = require("./abstract-data-builder");
/**
 * Decode and validate token data.
 */
class TokenDataBuilder extends abstract_data_builder_1.AbstractDataBuilder {
    build(cmd) {
        if (!this.validateTokenArgs(cmd)) {
            return { isValid: false };
        }
        const rawToken = this.getRawToken(cmd);
        const decodedToken = this.getDecodedToken(rawToken);
        const customerId = this.getCustomerId(decodedToken);
        const server = decodedToken[TokenDataBuilder.SERVER_KEY];
        const isValid = this.isValidToken(decodedToken);
        let origin;
        try {
            origin = new URL(server).origin;
        }
        catch (e) {
            origin = undefined;
        }
        return { token: rawToken, customerid: customerId, server, isValid, origin };
    }
    /**
     * Added for testing only
     * @param rawToken
     */
    getDecodedToken(rawToken) {
        try {
            return jwtDecode(rawToken);
        }
        catch (e) {
            this.logger.warn(`Failed to decode token data. Error ${e}`);
            return {};
        }
    }
    getRawToken(cmd) {
        if (cmd.token) {
            return cmd.token;
        }
        else if (cmd.tokenfile) {
            return this.getFromFile(cmd, 'tokenfile');
        }
    }
    validateTokenArgs(cmd) {
        const missingKeys = !cmd.token && !cmd.tokenfile;
        if (missingKeys) {
            this.logger.error('CLI Error: \'token\' or \'tokenfile\' must be provided');
        }
        return !missingKeys;
    }
    getCustomerId(decodedToken) {
        const subject = decodedToken[TokenDataBuilder.SUBJECT_KEY] || '';
        return subject.split('@')[0];
    }
    isValidToken(decodedToken) {
        if (!decodedToken.hasOwnProperty(TokenDataBuilder.SUBJECT_KEY)) {
            this.logger.error('Token Is Invalid. Doesn\'t Contains customerId');
            return false;
        }
        if (!decodedToken.hasOwnProperty(TokenDataBuilder.SERVER_KEY)) {
            this.logger.error('Token Is Invalid. Doesn\'t Contains Server');
            return false;
        }
        if (!decodedToken.hasOwnProperty(TokenDataBuilder.ROLE_KEY)) {
            this.logger.error('Token Is Invalid. Doesn\'t Contains role');
            return false;
        }
        if (decodedToken[TokenDataBuilder.ROLE_KEY] != TokenDataBuilder.AGENT_ROLE) {
            this.logger.error(`Token Is Invalid. Expected role to be ${TokenDataBuilder.AGENT_ROLE} but got ${decodedToken[TokenDataBuilder.ROLE_KEY]}`);
            return false;
        }
        return true;
    }
}
exports.TokenDataBuilder = TokenDataBuilder;
TokenDataBuilder.SUBJECT_KEY = 'subject';
TokenDataBuilder.SERVER_KEY = 'x-sl-server';
TokenDataBuilder.ROLE_KEY = 'x-sl-role';
TokenDataBuilder.AGENT_ROLE = 'agent';
//# sourceMappingURL=token-data-builder.js.map