"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockServerProxy = void 0;
const request = require("sl-request");
const contracts_1 = require("./contracts");
/**
 * A proxy for interacting sealights mock server using promises
 */
class MockServerProxy {
    static getAllFootprints() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.executeSlRequest(this.GET_ALL_FOOTPRINTS, contracts_1.HttpVerb.GET);
        });
    }
    static setRecommendedVersion(requestParams) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(this.SET_RECOMMENDED_VERSION, contracts_1.HttpVerb.POST, null, requestParams);
        });
    }
    static createBuildSessionId(buildSessionParams) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(this.CREATE_BUILDSESSION_ID, contracts_1.HttpVerb.POST, false, buildSessionParams);
        });
    }
    static getBuildMapping() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.executeSlRequest(this.GET_BUILD_MAPPING, contracts_1.HttpVerb.GET);
        });
    }
    static resetState() {
        return this.executeSlRequest(this.RESET, contracts_1.HttpVerb.GET, false);
    }
    static getToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(this.GET_TOKEN, contracts_1.HttpVerb.GET, false);
        });
    }
    static setActiveBSID(buildSessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(`${this.SET_ACTIVE_BSID}/${buildSessionId}`, contracts_1.HttpVerb.POST, false);
        });
    }
    static getTestEvents() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(this.GET_TEST_EVENTS, contracts_1.HttpVerb.GET);
        });
    }
    static setTestExclusions(buildSessionId, testStage, setTestExclusionRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = `${this.SET_TEST_EXCLUSIONS}/${buildSessionId}/${testStage}`;
            return this.executeSlRequest(uri, contracts_1.HttpVerb.POST, false, setTestExclusionRequest);
        });
    }
    static getRetryCounters() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(this.GET_RETRY_COUNTERS, contracts_1.HttpVerb.GET);
        });
    }
    static getAgentEvents() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(this.GET_AGENT_EVENTS, contracts_1.HttpVerb.GET);
        });
    }
    static getBuildEndStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(this.GET_BUILD_END, contracts_1.HttpVerb.GET);
        });
    }
    static getLogs() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(this.GET_LOGS, contracts_1.HttpVerb.GET);
        });
    }
    static setDelay(duration_ms, requestToBeDelayed) {
        const requestData = { duration_ms, requestToBeDelayed };
        return this.executeRequest(MockServerProxy.SET_DELAY, contracts_1.HttpVerb.POST, null, requestData);
    }
    static setEnabled(enabled) {
        const requestData = { enabled };
        return this.executeRequest(MockServerProxy.SET_ENABLED, contracts_1.HttpVerb.POST, null, requestData);
    }
    static setConfig(config) {
        return this.executeSlRequest(MockServerProxy.SET_CONFIG, contracts_1.HttpVerb.POST, null, config);
    }
    static setRouteSettings(url, verb, status, requestsBeforeStatusExpires) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = {
                url,
                method: verb,
                settings: {
                    requestsBeforeStatusExpires,
                    status
                }
            };
            return this.executeSlRequest(this.SETTINGS, contracts_1.HttpVerb.PUT, false, [request]);
        });
    }
    static setTestExecution(execution) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(this.SET_TEST_EXECUTION, contracts_1.HttpVerb.POST, false, { execution });
        });
    }
    static getTestExecution(labid) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(`${this.GET_TEST_EXECUTION}${labid}`, contracts_1.HttpVerb.GET);
        });
    }
    static getSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executeSlRequest(this.SETTINGS, contracts_1.HttpVerb.GET);
        });
    }
    static executeSlRequest(uri, verb, shouldParse = true, requestData) {
        return this.executeRequest(this.SERVER_URL + uri, verb, shouldParse, requestData);
    }
    static executeRequest(url, verb, shouldParse = true, requestData) {
        return new Promise((resolve, reject) => {
            const options = {
                url,
                method: verb,
                headers: {
                    'content-type': 'application/json',
                },
                json: requestData
            };
            request(options, (err, resp, body) => {
                if (err) {
                    reject(err);
                }
                if (resp.statusCode > 299) {
                    reject(new Error('Unexpected status code received: ' + resp.statusCode));
                }
                if (shouldParse) {
                    try {
                        const parsedResponse = JSON.parse(body);
                        resolve(parsedResponse);
                    }
                    catch (err) {
                        reject(err);
                    }
                }
                resolve(body);
            });
        });
    }
}
exports.MockServerProxy = MockServerProxy;
//TODO: extract to external 'routes' file
MockServerProxy.SERVER_URL = 'http://localhost:9900';
MockServerProxy.GET_ALL_FOOTPRINTS = '/api/test/footprints';
MockServerProxy.GET_BUILD_MAPPING = '/api/test/buildmapping';
MockServerProxy.RESET = '/api/test/reset';
MockServerProxy.GET_TOKEN = '/api/test/token';
MockServerProxy.CREATE_BUILDSESSION_ID = '/api/v2/agents/buildsession';
MockServerProxy.SET_RECOMMENDED_VERSION = '/api/test/recommended';
MockServerProxy.SET_ACTIVE_BSID = '/api/test/lab-ids/build-sessions/active';
MockServerProxy.GET_TEST_EVENTS = '/api/test/agents/events';
MockServerProxy.SET_TEST_EXCLUSIONS = '/api/test/test-exclusions';
MockServerProxy.GET_RETRY_COUNTERS = '/api/test/retry-counters';
MockServerProxy.GET_AGENT_EVENTS = '/api/test/v3/agents/agent-events';
MockServerProxy.SETTINGS = '/settings';
MockServerProxy.TEST_EXCLUSION = '/api/v3/test-exclusions/:buildSessionId/:testStage';
MockServerProxy.GET_BUILD_END = '/api/test/buildend';
MockServerProxy.GET_LOGS = '/api/test/logs';
MockServerProxy.SET_DELAY = '/api/test/setDelay';
MockServerProxy.SET_ENABLED = '/api/test/setEnabled';
MockServerProxy.SET_CONFIG = '/api/test/config';
MockServerProxy.SET_BUILD_END = '/api/v3/agents/buildend';
MockServerProxy.SET_TEST_EXECUTION = '/api/test/testExecution';
MockServerProxy.GET_TEST_EXECUTION = '/api/v4/testExecution/';
MockServerProxy.FOOTPRINTS_V6 = '/api/v6/agents/:executionBsId/footprints/:testStage/:buildSessionId';
//# sourceMappingURL=mock-server-proxy.js.map