"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceMapHandler = void 0;
const path = require("path");
const validation_utils_1 = require("./utils/validation-utils");
const files_utils_1 = require("./utils/files-utils");
/**
 * Resolve the source data for method or branch.
 * Resolves the followingg:
 * Relative path of source file.
 * Absolute path of source file.
 * Start position in source file.
 * End position in source file.
 * The name of original methid (in case of method).
 */
class SourceMapHandler {
    constructor(consumer, generatedFileName, generatedStart, generatedEnd, projectRoot, logger) {
        this.consumer = consumer;
        this.generatedFileName = generatedFileName;
        this.projectRoot = projectRoot;
        this.logger = logger;
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(consumer, 'consumer');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(generatedFileName, 'generatedFileName');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(generatedStart, 'generatedStart');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(generatedEnd, 'generatedEnd');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(logger, 'logger');
        this.consumer = consumer;
        this.generatedFileName = generatedFileName;
        this.projectRoot = projectRoot;
        this.logger = logger;
        this._start = this.resolveOriginalPosition(generatedStart, false);
        this._end = this.resolveOriginalPosition(generatedEnd, true);
    }
    resolvePaths() {
        if (!this.isValidPositionObject(this._start)) {
            this.logger.debug(`Invalid original start position '${this._start}', skipping this method`);
            this._shouldSkipped = true;
            return;
        }
        this.originalName = this._start.name;
        let source = this.trimWebpackPrefix(this._start.source);
        if (this.isThirdPartyCode(source)) {
            this.logger.debug(`File '${source}' is a third party file, marked as skipped`);
            this._shouldSkipped = true;
            return;
        }
        if (process.env.SL_IS_REACT) {
            source = source.replace(SourceMapHandler.REACT_GENERATED_FOLDER, SourceMapHandler.REACT_SOURCE_FOLDER);
        }
        this.resolveAbsolutePath(source);
        if (this._shouldSkipped) {
            return;
        }
        this.resolveRelativePath();
    }
    // TODO: used only in GeneratedFileSignature that olso not in use
    setScmParams(scmFilesContainer, scmRootDir) {
        this.scmFilesContainer = scmFilesContainer;
        this.scmRootDir = scmRootDir;
    }
    get absolutePath() {
        return this._absolutePath;
    }
    get relativePath() {
        return this._relativePath;
    }
    get start() {
        return this._start;
    }
    get end() {
        return this._end;
    }
    get shouldSkipped() {
        return this._shouldSkipped;
    }
    resolveAbsolutePath(source) {
        source = files_utils_1.FilesUtils.adjustPathSlashes(source);
        let absolutePath;
        if (path.isAbsolute(source)) {
            this.logger.debug(`file '${source}' is absolute`);
            absolutePath = source;
        }
        else if (this.projectRoot) {
            if (source.indexOf(this.projectRoot) === 0) {
                this.logger.debug(`Given projectRoot '${this.projectRoot}' is already at the beginning of '${source}'`);
                absolutePath = source;
            }
            else {
                absolutePath = path.join(this.projectRoot, source);
            }
        }
        else if (this.scmFilesContainer) {
            absolutePath = this.resolvePathsByScm(source);
        }
        else {
            const dirname = path.dirname(this.generatedFileName);
            absolutePath = path.resolve(dirname, source);
        }
        this._absolutePath = files_utils_1.FilesUtils.adjustPathSlashes(absolutePath);
        this.logger.debug(`Absolute path for '${source}' resolved to be '${this._absolutePath}'`);
    }
    resolveRelativePath() {
        let prefixToTrim = this.projectRoot || this.scmRootDir || process.cwd();
        prefixToTrim = files_utils_1.FilesUtils.adjustPathSlashes(prefixToTrim);
        if (this._absolutePath.indexOf(prefixToTrim) === 0) {
            this._relativePath = this._absolutePath.replace(prefixToTrim, '');
            if (this._relativePath.indexOf('/') === 0) {
                this._relativePath = this._relativePath.substring(1);
            }
        }
        else {
            this.logger.warn(`Prefix '${this.projectRoot}' is not in the start of '${this._absolutePath}', could not resolve relative path`);
            this._relativePath = this._absolutePath;
        }
    }
    resolvePathsByScm(source) {
        const gitFiles = this.scmFilesContainer.getScmPath(source);
        if (!gitFiles) {
            this.logger.warn(`File '${source}' not found in git files, marked as skipped`);
            this._shouldSkipped = true;
            return null;
        }
        else if (gitFiles.length > 1) {
            // TODO: report to onboarding dashboard
            this.logger.warn(`File '${source}' match to multiple git files, absolute path resolved relative `);
            return path.join(this.scmRootDir, source);
        }
        else {
            return path.join(this.scmRootDir, gitFiles[0]);
        }
    }
    resolveOriginalPosition(generatedPosition, isEnd) {
        const originalPosition = this.consumer.originalPositionFor({
            line: generatedPosition[0],
            column: isEnd ? generatedPosition[1] - 1 : generatedPosition[1]
        });
        return new Position(originalPosition);
    }
    isValidPositionObject(position) {
        return position && position.source && position.line !== null && position.column !== null;
    }
    trimWebpackPrefix(source) {
        source = source.replace(SourceMapHandler.WEBPACK_PREFIX, '');
        return source;
    }
    isThirdPartyCode(source) {
        return SourceMapHandler.THIRD_PARTIES_FOLDERS.some(folder => source.indexOf(folder) > -1);
    }
}
exports.SourceMapHandler = SourceMapHandler;
SourceMapHandler.WEBPACK_PREFIX = /^webpack:\/+/;
SourceMapHandler.REACT_GENERATED_FOLDER = 'build/static/js';
SourceMapHandler.REACT_SOURCE_FOLDER = 'src';
SourceMapHandler.WEBPACK_BOOTSTRAP_FILE = 'webpack/bootstrap';
SourceMapHandler.WEBPACK_LAZY_FILE = '$_lazy';
SourceMapHandler.WEBPACK_SRC_ASYNC = 'src async';
SourceMapHandler.WEBPACK_SRC_LAZY = 'src lazy';
SourceMapHandler.WEBPACK_RESOURCE_SIGN = '~'; // Webpack replace 'node_modules' with '~'
SourceMapHandler.NODE_MODULES = 'node_modules';
SourceMapHandler.THIRD_PARTIES_FOLDERS = [
    SourceMapHandler.WEBPACK_BOOTSTRAP_FILE,
    SourceMapHandler.WEBPACK_LAZY_FILE,
    SourceMapHandler.WEBPACK_RESOURCE_SIGN,
    SourceMapHandler.NODE_MODULES,
    SourceMapHandler.WEBPACK_SRC_ASYNC,
    SourceMapHandler.WEBPACK_SRC_LAZY
];
// TODO: expose and reuse
class Position {
    constructor(position) {
        this.column = position.column;
        this.line = position.line;
        this.name = position.name;
        this.source = position.source;
    }
    asFormatArray() {
        return [this.line, this.column];
    }
}
//# sourceMappingURL=source-map-handler.js.map