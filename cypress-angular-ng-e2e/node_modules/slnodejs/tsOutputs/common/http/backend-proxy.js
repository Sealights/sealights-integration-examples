"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackendProxy = void 0;
const contracts_1 = require("./contracts");
const http_client_1 = require("./http-client");
const sl_routes_1 = require("./sl-routes");
const validation_utils_1 = require("../utils/validation-utils");
const entities_mapper_1 = require("./entities-mapper");
const constants_1 = require("../constants/constants");
const timer_utils_1 = require("../utils/timer-utils");
class BackendProxy {
    get httpMaxAttemps() {
        return this.config.httpMaxAttemps || BackendProxy.DEFAULT_HTTP_MAX_ATTEMPTS;
    }
    get httpAttemptInterval() {
        return this.config.httpAttemptInterval || BackendProxy.DEFAULT_HTTP_ATTEMPT_INTERVAL;
    }
    // TODO: get httpClient in constructor always
    constructor(agentInstanceData, config, logger, httpClient) {
        this.agentInstanceData = agentInstanceData;
        this.config = config;
        this.logger = logger;
        const metadata = {
            labId: config.labId,
            appName: config.appName,
            branchName: config.branchName,
            buildName: config.buildName,
            agentId: agentInstanceData.agentId,
            buildSessionId: config.buildSessionId,
            agentType: agentInstanceData.agentType,
            agentTechnology: agentInstanceData.technology,
        };
        this.client = httpClient || new http_client_1.HttpClient(this.config, metadata, this.logger);
    }
    getBuildSession(buildSessionId, callback) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(buildSessionId, constants_1.Constants.BUILD_SESSION_ID);
        const url = sl_routes_1.SLRoutes.buildSessionV2(buildSessionId);
        this.client.get(url, (err, body) => {
            this.invokeCallback(callback, err, body);
        });
    }
    createBuildSessionId(request, callback) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(request, constants_1.Constants.REQUEST);
        const url = sl_routes_1.SLRoutes.buildSessionV2();
        this.client.post(request, url, (err, body) => {
            this.invokeCallback(callback, err, body, entities_mapper_1.EntitiesMapper.toCreateBuildSessionIdResponse);
        });
    }
    createBuildSessionIdPromise(request) {
        return __awaiter(this, void 0, void 0, function* () {
            validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(request, constants_1.Constants.REQUEST);
            const url = constants_1.Constants.PULL_REQUEST_PARAMS in request ? sl_routes_1.SLRoutes.prBuildSession() : sl_routes_1.SLRoutes.buildSessionV2();
            return new Promise((resolve, reject) => {
                this.client.post(request, url, (err, body) => {
                    if (err) {
                        return reject(err);
                    }
                    return resolve(body);
                });
            });
        });
    }
    getRecommendedVersion(request) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(request, constants_1.Constants.REQUEST);
        const url = sl_routes_1.SLRoutes.recommendedAgentV2(request.componentName, request.customerId, request.appName, request.branchName, request.testStage);
        return new Promise((resolve, reject) => {
            this.client.get(url, (err, body) => {
                if (err) {
                    return reject(err);
                }
                else if (body && body.agent && body.agent) {
                    return resolve(body.agent);
                }
                else {
                    return reject(new Error('Failed to get recommended version due to unexpected response from the server.'));
                }
            });
        });
    }
    submitBuildMapping(request) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(request, constants_1.Constants.REQUEST);
        const url = sl_routes_1.SLRoutes.buildMappingV4();
        return this.submitPostRequestWithRetries(request, url);
    }
    submitLogs(request, callback) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(request, constants_1.Constants.REQUEST);
        const url = sl_routes_1.SLRoutes.logSubmissionV2();
        this.client.post(request, url, (err, body) => {
            this.invokeCallback(callback, err, body);
        });
    }
    getRemoteConfig(request, callback) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(request, constants_1.Constants.REQUEST);
        const url = sl_routes_1.SLRoutes.configV3(this.agentInstanceData, request.appName, request.branch, request.build, request.testStage, request.labId);
        this.client.get(url, (err, body) => {
            this.invokeCallback(callback, err, body);
        });
    }
    getRemoteConfigPromise(request) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(request, constants_1.Constants.REQUEST);
        return new Promise((resolve, reject) => {
            const url = sl_routes_1.SLRoutes.configV3(this.agentInstanceData, request.appName, request.branch, request.build, request.testStage, request.labId);
            this.client.get(url, (err, body) => {
                if (err) {
                    reject(err);
                }
                resolve(body);
            });
        });
    }
    startExecution(request, callback) {
        const url = sl_routes_1.SLRoutes.testExecution();
        this.client.post(request, url, (err, body) => {
            this.invokeCallback(callback, err, body);
        });
    }
    startColoredExecution(request) {
        return new Promise((resolve, reject) => {
            const url = sl_routes_1.SLRoutes.testExecution();
            this.client.post(request, url, (err) => {
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
    }
    testExecutionV4(labId, async = true, executionId) {
        return new Promise((resolve, reject) => {
            const url = sl_routes_1.SLRoutes.testExecutionV4(labId);
            this.client.get(url, (err, body) => {
                if (err) {
                    reject(err);
                }
                resolve(body);
            }, false, async);
        });
    }
    uploadReport(request, callback) {
        const url = sl_routes_1.SLRoutes.externalData();
        this.client.postMultipart(request, url, (err, body) => {
            this.invokeCallback(callback, err, body);
        });
    }
    externalReport(request, callback) {
        const url = sl_routes_1.SLRoutes.externalReport();
        this.client.post(request, url, (err, body) => {
            this.invokeCallback(callback, err, body);
        });
    }
    endExecution(request, callback) {
        const url = sl_routes_1.SLRoutes.endExecution(request.customerId, request.appName, request.buildName, request.branchName, request.environment);
        const body = request.executionIds ? { executionIds: request.executionIds } : null;
        this.client.delete(body, url, (err, body) => {
            this.invokeCallback(callback, err, body);
        });
    }
    endExecutionPromise(request) {
        const url = sl_routes_1.SLRoutes.endExecution(request.customerId, request.appName, request.buildName, request.branchName, request.environment);
        const body = request.executionIds ? { executionIds: request.executionIds } : null;
        return new Promise((resolve, reject) => {
            this.client.delete(body, url, (err) => {
                err ? reject(err) : resolve();
            });
        });
    }
    submitEvents(packetToSend, callback, async = true) {
        const url = sl_routes_1.SLRoutes.eventsV2();
        this.client.post(packetToSend, url, callback);
    }
    submitEventsPromise(packetToSend) {
        return new Promise((resolve, reject) => {
            const url = sl_routes_1.SLRoutes.eventsV2();
            this.client.post(packetToSend, url, err => {
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
    }
    submitBlobAsync(body, buildSessionId, blobId, blobType = 'unspecified') {
        const url = sl_routes_1.SLRoutes.blobs(buildSessionId, blobId, blobType);
        return new Promise((resolve, reject) => {
            this.client.post(body, url, (error, statusCode) => {
                this.logger.debug(`Blob ${blobId} uploaded with status code ${statusCode}`);
                if (error) {
                    this.logger.error(`Error while submitting a blob, '${error}'`);
                    return reject(error);
                }
                else {
                    this.logger.info('blob submitted successfully');
                    return resolve({});
                }
            }, true, contracts_1.ContentType.OCTET_STREAM);
        });
    }
    submitBlob(body, buildSessionId, blobId, callback) {
        const url = sl_routes_1.SLRoutes.blobs(buildSessionId, blobId);
        this.client.post(body, url, callback, true, contracts_1.ContentType.OCTET_STREAM);
    }
    getBlobsAsJson(buildSessionId, blobType = 'unspecified') {
        return __awaiter(this, void 0, void 0, function* () {
            let slMapping = [];
            try {
                const url = sl_routes_1.SLRoutes.blobsForBsidAsJson(buildSessionId, blobType);
                slMapping = yield this.submitGetRequestWithRetries(url);
            }
            catch (e) {
                this.logger.error(e);
            }
            return slMapping;
        });
    }
    getSlMappingFromServer(buildSessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getBlobsAsJson(buildSessionId, 'unspecified');
        });
    }
    submitAgentEvent(body) {
        const url = sl_routes_1.SLRoutes.agentEvents();
        return new Promise((resolve, reject) => {
            this.client.post(body, url, (error, response) => {
                if (error) {
                    return reject(error);
                }
                return resolve();
            });
        });
    }
    getTestsRecommendation(buildSessionId, stage, testGroupId) {
        const url = sl_routes_1.SLRoutes.testsRecommendations(buildSessionId, stage, testGroupId);
        return this.submitGetRequestWithRetries(url, null, null, [400, 404], false);
    }
    addOrUpdateIntegrationBuildComponents(buildSessionId, components, agentId) {
        const url = sl_routes_1.SLRoutes.integrationBuildComponents(buildSessionId);
        return this.submitPutRequestWithRetries({ components, agentId }, url);
    }
    deleteIntegrationBuildComponents(buildSessionId, components, agentId) {
        const url = sl_routes_1.SLRoutes.integrationBuildComponents(buildSessionId);
        return this.submitDelRequestWithRetries({ components, agentId }, url);
    }
    buildEnd(data) {
        return this.submitPostRequestWithRetries(data, sl_routes_1.SLRoutes.buildEnd());
    }
    submitFootprintsV6(footprintsPacket, executionBsid, testStage, buildSessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(footprintsPacket, constants_1.Constants.FOOTPRINTS_PACKET);
            validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(executionBsid, constants_1.Constants.EXECUTION_BSID);
            validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(testStage, constants_1.Constants.TEST_STAGE);
            validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(buildSessionId, constants_1.Constants.BUILD_SESSION_ID);
            const url = sl_routes_1.SLRoutes.footprintsV6(executionBsid, testStage, buildSessionId);
            return this.submitPostRequestWithRetries(footprintsPacket, url, null, null, true, contracts_1.ContentType.OCTET_STREAM);
        });
    }
    submitFootprintsToCollector(footprintsPacket, buildSessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(footprintsPacket, constants_1.Constants.FOOTPRINTS_PACKET);
            validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(buildSessionId, constants_1.Constants.BUILD_SESSION_ID);
            const url = sl_routes_1.SLRoutes.footprintsToCollector(buildSessionId);
            return this.submitPostRequestWithRetries(footprintsPacket, url, null, null, true, contracts_1.ContentType.JSON);
        });
    }
    getBuildSessionData(buildSessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.getBuildSession(buildSessionId, (err, response) => {
                    err ? reject(err) : resolve(response);
                });
            });
        });
    }
    getRecommendedAgent(configuration) {
        return __awaiter(this, void 0, void 0, function* () {
            return {};
        });
    }
    getBuildSessionDataFromLabId(labid) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = sl_routes_1.SLRoutes.activeBuildSessionId(labid);
            return this.submitGetRequestWithRetries(url);
        });
    }
    updateMetadata(metadata) {
        this.client.updateMetadata(metadata);
    }
    invokeCallback(callback, err, body, map) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(callback, constants_1.Constants.CALLBACK);
        if (err != null) {
            return callback(err, body);
        }
        if (map == null) {
            return callback(null, body);
        }
        const apiResponse = map(body);
        return callback(null, apiResponse);
    }
    submitPostRequestWithRetries(body, url, retries, delayBetweenRetires, async, contentType) {
        return this.makeRequestWithRetries((callback) => { this.client.post(body, url, callback, async, contentType); }, retries, delayBetweenRetires);
    }
    submitPutRequestWithRetries(body, url, retries, delayBetweenRetires) {
        return this.makeRequestWithRetries((callback) => { this.client.put(body, url, callback); }, retries, delayBetweenRetires);
    }
    submitDelRequestWithRetries(body, url, retries, delayBetweenRetires) {
        return this.makeRequestWithRetries((callback) => { this.client.delete(body, url, callback); }, retries, delayBetweenRetires);
    }
    submitGetRequestWithRetries(url, retries, delayBetweenRetires, statusesForRetry, isNotFoundAcceptable = true) {
        return this.makeRequestWithRetries((callback) => { this.client.get(url, callback, isNotFoundAcceptable); }, retries, delayBetweenRetires, statusesForRetry);
    }
    makeRequestWithRetries(doSingleRequest, retries, delayBetweenRetires, statusesForRetry) {
        return __awaiter(this, void 0, void 0, function* () {
            let retriesLeft = retries || this.httpMaxAttemps;
            const intervalBetweenRetries = delayBetweenRetires || this.httpAttemptInterval;
            let lastError = undefined;
            do {
                try {
                    retriesLeft--;
                    const bodyAndStatusCode = yield new Promise((resolve, reject) => {
                        doSingleRequest((err, body, statusCode) => {
                            err ? reject({ err, statusCode }) : resolve({ body, statusCode }); //Always return status code
                        });
                    });
                    return bodyAndStatusCode.body;
                }
                catch (errAndStatusCode) {
                    this.logger.info(errAndStatusCode);
                    lastError = errAndStatusCode.err;
                    if (!this.shouldRetryRequest(errAndStatusCode.statusCode, statusesForRetry)) {
                        break; //Non-retriable error, break do..while loop and
                    }
                }
                yield timer_utils_1.TimerUtils.sleep(intervalBetweenRetries);
            } while (retriesLeft > 0);
            throw lastError;
        });
    }
    shouldRetryRequest(statusCode, statusesForRetry = []) {
        if (statusCode >= 500 || statusCode && statusesForRetry.includes(statusCode))
            return true;
        return false;
    }
    getSyncedTime(currentTime) {
        return new Promise((resolve, reject) => {
            const url = sl_routes_1.SLRoutes.syncTypeRoute(currentTime);
            this.client.get(url, (err, body) => {
                if (err) {
                    return reject(err);
                }
                return resolve(body);
            });
        });
    }
}
exports.BackendProxy = BackendProxy;
BackendProxy.DEFAULT_HTTP_MAX_ATTEMPTS = 6;
BackendProxy.DEFAULT_HTTP_ATTEMPT_INTERVAL = 5 * 1000;
//# sourceMappingURL=backend-proxy.js.map