"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = exports.getSystemDateValueOf = void 0;
const contracts_1 = require("./contracts");
const request = require("sl-request");
const zlib = require("zlib");
const http_verb_1 = require("./http-verb");
const validation_utils_1 = require("../utils/validation-utils");
const system_date_1 = require("../../common/system-date");
var system_date_2 = require("../../common/system-date");
Object.defineProperty(exports, "getSystemDateValueOf", { enumerable: true, get: function () { return system_date_2.getSystemDateValueOf; } });
class HttpClient {
    constructor(cfg, metadata, logger) {
        this.cfg = cfg;
        this.metadata = metadata;
        this.logger = logger;
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(cfg, 'cfg');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(logger, 'logger');
    }
    get(urlPath, callback, isNotFoundAcceptable = true) {
        this.invokeHttpRequest(http_verb_1.HttpVerb.GET, urlPath, callback, null, null, null, isNotFoundAcceptable);
    }
    delete(body, urlPath, callback) {
        this.invokeHttpRequest(http_verb_1.HttpVerb.DELETE, urlPath, callback, null, body);
    }
    put(requestData, urlPath, callback, async, contentType) {
        return this.submitRequestWithBody(http_verb_1.HttpVerb.PUT, requestData, urlPath, callback, async, contentType);
    }
    post(requestData, urlPath, callback, async, contentType) {
        return this.submitRequestWithBody(http_verb_1.HttpVerb.POST, requestData, urlPath, callback, async, contentType);
    }
    postMultipart(requestData, urlPath, callback) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(requestData, 'requestData');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(requestData.agentData, 'requestData.agentData');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(requestData.reportFile, 'requestData.reportFile');
        const agentData = requestData.agentData;
        const reportFile = requestData.reportFile;
        try {
            const opts = this.createDefaultOptions(urlPath);
            const requestStarted = (0, system_date_1.getSystemDateValueOf)();
            const onRequestCallback = this.createOnRequestCallback({
                httpVerb: http_verb_1.HttpVerb.POST,
                url: opts.url,
                requestStarted,
                callback,
            });
            this.logger.info(`Sending ${http_verb_1.HttpVerb.POST} request. Url: '${opts.url}'`);
            const req = request.post(opts, onRequestCallback);
            const form = req.form();
            form.append('file', JSON.stringify(agentData), {
                filename: 'agentData',
                contentType: 'multipart/form-data'
            });
            form.append('file', reportFile.buffer.toString(), {
                filename: 'report',
                contentType: 'multipart/form-data'
            });
        }
        catch (err) {
            this.logger.error(`Failed sending Http ${http_verb_1.HttpVerb.POST} request to:'${urlPath}'. Error: '${err}'`);
            return callback(err, null, null);
        }
    }
    updateMetadata(metadata) {
        this.metadata = Object.assign(Object.assign({}, this.metadata), metadata);
    }
    submitRequestWithBody(verb, requestData, urlPath, callback, async, contentType) {
        var _a, _b;
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(requestData, 'requestData');
        const bufferToSend = Buffer.from(JSON.stringify(requestData));
        const shouldZip = this.cfg.compressRequests != null ? this.cfg.compressRequests : true;
        const messageTypeHeader = { [contracts_1.SealightsHeaderNames.MESSAGE_TYPE]: (_b = (_a = requestData === null || requestData === void 0 ? void 0 : requestData.events) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.type };
        this.logger.debug('Sending buffer:' + bufferToSend.toString());
        if (shouldZip) {
            zlib.gzip(bufferToSend, (err, compressedBuf) => {
                if (err) {
                    //Fallback to sending data uncompressed
                    this.logger.warn('Failed while trying to compress the request data. Sending uncompressed data instead. Error: ', err);
                    this.invokeHttpRequest(verb, urlPath, callback, messageTypeHeader, bufferToSend, contentType);
                }
                else {
                    this.invokeHttpRequest(verb, urlPath, callback, Object.assign({ 'Content-Encoding': 'gzip' }, messageTypeHeader), compressedBuf, contentType);
                }
            });
        }
        else {
            this.invokeHttpRequest(verb, urlPath, callback, messageTypeHeader, bufferToSend, contentType); //Submit buffer as-is
        }
    }
    invokeHttpRequest(httpVerb, urlPath, callback, additionalHeaders, buffer, contentType, isNotFoundAcceptable = true) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(httpVerb, 'httpVerb');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(urlPath, 'urlPath');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(callback, 'callback');
        try {
            const opts = this.createDefaultOptions(urlPath, contentType);
            if (additionalHeaders) {
                for (const header in additionalHeaders) { //Copy additional headers
                    opts.headers[header] = additionalHeaders[header];
                }
            }
            const requestStarted = (0, system_date_1.getSystemDateValueOf)();
            const onRequestCallback = this.createOnRequestCallback({
                httpVerb,
                url: opts.url,
                requestStarted,
                callback,
                isNotFoundAcceptable,
            });
            this.logger.info(`Sending ${httpVerb} request. Url: '${opts.url}'`);
            if (httpVerb === http_verb_1.HttpVerb.GET) {
                opts.json = true;
                request.get(opts, onRequestCallback);
            }
            else if (httpVerb === http_verb_1.HttpVerb.DELETE) {
                if (buffer)
                    opts.body = buffer;
                opts.json = true;
                request.delete(opts, onRequestCallback);
            }
            else if (httpVerb === http_verb_1.HttpVerb.POST) {
                opts.body = buffer;
                request.post(opts, onRequestCallback);
            }
            else if (httpVerb === http_verb_1.HttpVerb.PUT) {
                opts.body = buffer;
                request.put(opts, onRequestCallback);
            }
            else {
                new Error(`${httpVerb} is not implemented yet.`);
            }
        }
        catch (err) {
            this.logger.error(`Failed sending Http ${httpVerb} request to:'${urlPath}'. Error: '${err}'`);
            return callback(err, null, null);
        }
    }
    createOnRequestCallback({ httpVerb, url, requestStarted, callback, isNotFoundAcceptable, }) {
        const handler = (err, requestResponse, body) => {
            const txId = requestResponse && requestResponse.headers && requestResponse.headers['x-sl-txid'];
            const requestEnded = (0, system_date_1.getSystemDateValueOf)();
            const requestTime = requestEnded - requestStarted;
            const requestDescription = `'${httpVerb} ${url}' ${txId ? 'TxId:' + txId : ''} (${requestTime}ms)`;
            if (err || ((requestResponse != null) && (requestResponse.statusCode < 200 || requestResponse.statusCode >= 400))) {
                let statusCode = -1;
                if (requestResponse != null) {
                    statusCode = requestResponse.statusCode;
                    this.logger.warn(`Got ${statusCode} from ${requestDescription}`);
                }
                if (err) {
                    err = new Error(`HttpClient failed for ${requestDescription}. Error: ${err.message}, StatusCode: ${statusCode}, Stack: ${err.stack}`);
                }
                else if (statusCode === 404 && isNotFoundAcceptable) {
                    //404 is valid since in REST we have situations in which 404 represents an empty collection
                    err = null;
                }
                else {
                    let errorMessage = `Server returned: ${statusCode} status code from ${requestDescription}`;
                    // Make server response object more readable
                    try {
                        if (body)
                            errorMessage += Object.entries(JSON.parse(body)).map(([key, val]) => `\n\t${key}: ${val}`).join('');
                    }
                    catch (e) {
                        errorMessage += `Parsing of server response failed for ${requestDescription}, body: ${body}', error: ${e}`;
                    }
                    err = new Error(errorMessage);
                }
                return callback(err, body, statusCode);
            }
            this.logger.debug(`'${httpVerb}' request ${requestDescription} completed. StatusCode: ${requestResponse.statusCode}. Body: ${body}`);
            if (body && body.length > 0 && typeof body == 'string') {
                try {
                    body = JSON.parse(body);
                }
                catch (e) {
                    this.logger.error(`An error occurred parsing the body: [${body}], error: ${e}`);
                }
            }
            return callback(null, body, requestResponse.statusCode);
        };
        return handler;
    }
    allowUntrustedCertificates() {
        //For more information: https://stackoverflow.com/questions/17383351/how-to-capture-http-messages-from-request-node-library-with-fiddler/22996076#22996076
        process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
    }
    createDefaultOptions(urlPath, contentType = contracts_1.ContentType.JSON) {
        //get
        const opts = {
            url: this.cfg.server + urlPath,
            headers: {
                [contracts_1.SealightsHeaderNames.CONTENT_TYPE]: contentType,
                [contracts_1.SealightsHeaderNames.AUTHOTIZARTION]: 'Bearer ' + this.cfg.token,
                [contracts_1.SealightsHeaderNames.META_DATA]: JSON.stringify(this.metadata),
                [contracts_1.SealightsHeaderNames.LAB_ID]: this.metadata.labId,
                [contracts_1.SealightsHeaderNames.APP_NAME]: this.metadata.appName,
                [contracts_1.SealightsHeaderNames.BRANCH_NAME]: this.metadata.branchName,
                [contracts_1.SealightsHeaderNames.BUILD_NAME]: this.metadata.buildName,
                [contracts_1.SealightsHeaderNames.BSID]: this.metadata.buildSessionId,
                [contracts_1.SealightsHeaderNames.EXECUTION_ID]: this.metadata.executionId,
                [contracts_1.SealightsHeaderNames.AGENT_ID]: this.metadata.agentId,
            },
            timeout: this.defaultTimeout,
            compressed: true
        };
        if (this.cfg.proxy != null) { //http://user:pass@proxy.server.com:3128
            opts.proxy = this.cfg.proxy;
            this.allowUntrustedCertificates();
        }
        return opts;
    }
    get defaultTimeout() {
        return this.cfg.defaultTimeout || HttpClient.DEFAULT_HTTP_TIMEOUT;
    }
}
exports.HttpClient = HttpClient;
HttpClient.DEFAULT_HTTP_TIMEOUT = 60 * 1000 * 2;
//# sourceMappingURL=http-client.js.map