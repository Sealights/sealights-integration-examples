import { FindPosition, MappedPosition } from 'source-map';
import { AgentTechnologies, AgentTypes } from '../agent-events/agent-events-contracts';
export declare class IHttpClientConfigData {
    token: string;
    proxy: string;
    server: string;
    buildSessionId?: string;
    defaultTimeout?: number;
    compressRequests?: boolean;
    labId?: string;
    appName?: string;
    branchName?: string;
    buildName?: string;
}
export interface IBackendProxyConfig extends IHttpClientConfigData {
    httpMaxAttemps?: number;
    httpAttemptInterval?: number;
}
export declare class SlAgentMetadata {
    labId?: string;
    appName?: string;
    branchName?: string;
    buildName?: string;
    executionId?: string;
    agentId?: string;
    buildSessionId?: string;
    agentType?: AgentTypes;
    agentTechnology?: AgentTechnologies;
    messageType?: string;
}
export interface BuildSessionData {
    appName: string;
    buildName: string;
    branchName: string;
    buildSessionId: string;
    additionalArguments?: string;
}
export declare class CreateBuildSessionIdResponse {
    buildSessionId: string;
}
export interface IPullRequestParams {
    repositoryUrl: string;
    pullRequestNumber: number;
    latestCommit: string;
    targetBranch: string;
}
export interface IPRConfigRequest extends BuildSessionData {
    pullRequestParams: IPullRequestParams;
}
export declare class GetVersionRequest {
    customerId: string;
    appName: string;
    testStage: string;
    branchName: string;
    componentName: string;
    buildName: string;
}
export declare class GetVersionResponse {
    agent: AgentInfo;
    meta: VersionMeta;
}
export declare class AgentInfo {
    date: number;
    name: string;
    url: string;
    version: string;
}
export declare class VersionMeta {
    generated: number;
    requestUrl: string;
    query: VersionMetaQuery;
}
export declare class VersionMetaQuery {
    agentType: string;
    isDefault: boolean;
}
export declare class BuildMappingRequest {
    meta: any;
    files: FileData[];
    dependencies: DependencyData[];
}
export interface IDryRunBuildMappingRequest extends BuildMappingRequest {
    excludedFiles: string[];
    includedFiles: string[];
    counters: {
        methods: number;
        branches: number;
    };
}
export declare class DependencyData {
    appName: string;
    branch: string;
    build: string;
}
export declare class FileData {
    logicalPath: string;
    physicalPath: string;
    methods: MethodInfo[];
    branches: any[];
    lines: any[];
    hash: string;
    absolutePath?: string;
    fromSourceMaps?: boolean;
    positionToMethod: {
        [key: string]: number;
    };
    positionToBranch: {
        [key: string]: number;
    };
    endPositionToMethod?: {
        [key: string]: number;
    };
    commitIndexes?: number[];
}
export interface ISourceMapConsumer {
    originalPositionFor(generatedPosition: FindPosition): MappedPosition;
}
export interface MappingResult {
    fileName: string;
    methods: MethodInfo[];
    branches?: BranchInfo[];
}
export interface BranchInfo extends CodeItem {
    filename: string;
    type: string;
    endPosition: number[];
    hash: string;
    index: number;
    parentPosition: number[];
    enclosingMethodIdx: number;
}
export interface CodeItem {
    position: number[];
    techSpecificInfo: TechSpecificInfo;
    meta?: Meta;
    uniqueId?: string;
    uniqueIdKey?: string;
}
export interface MethodInfo extends CodeItem {
    endPosition: number[];
    displayName: string;
    hash: string;
    sigHash: string;
    idxInMapping: number;
    oldHash?: string;
    oldSigHash?: string;
}
export interface Meta {
    anonymous: boolean;
    identifierPosition?: number[];
}
export interface TechSpecificInfo {
    isAsync: boolean;
    isComputed: boolean;
    isExpression: boolean;
    isGenerator: boolean;
    isStatic: boolean;
    isAnonymous: boolean;
    autoGenerated?: boolean;
    isDecorated?: boolean;
}
export interface GeneratedData {
    position: number[];
    endPosition: number[];
    displayName: string;
    hash: string;
    sigHash: string;
    relativeFilename: string;
    absoluteFilename: string;
    identifierPosition: any[];
}
export interface SignatureMethod {
    meta: Meta;
    techSpecificInfo: TechSpecificInfo;
    type?: any;
    srcData: GeneratedData;
    generatedData: GeneratedData;
    uniqueId: string;
    idxInMapping: number;
    uniqueIdKey: string;
}
export declare class GetRemoteConfigRequest {
    appName?: string;
    branch?: string;
    build?: string;
    testStage?: string;
    labId?: string;
}
export declare class SubmitLogsRequest {
    appName: string;
    customerId: string;
    testStage: string;
    log: string;
    creationTime: number;
}
export declare class BaseRequest {
    customerId: string;
    appName: string;
    server: string;
    proxy: string;
    isValidToken: boolean;
}
export declare class StartExecutionRequest extends BaseRequest {
    testStage: string;
    source?: string;
    testGroupId?: string;
    labId: string;
    buildName: string;
    branchName: string;
    newEnvironment: string;
    environment: string;
}
export declare class EndExecutionRequest extends BaseRequest {
    environment: string;
    buildName: string;
    branchName: string;
    executionIds?: string[];
}
export declare class UploadReportRequest extends BaseRequest {
    environmentName: string;
    reportFile: string[];
    reportFilesFolder: string[];
    labId: string;
    build: string;
    branch: string;
    source: string;
    type: string;
    hasMoreRequests: boolean;
}
export declare class AgentData {
    customerId: string;
    appName: string;
    type: string;
    source: string;
    hasMoreRequests: boolean;
    buildName?: string;
    branchName?: string;
    environment: EnvironmentData;
}
export declare class EnvironmentData {
    labId: string;
    environmentName: string;
}
export declare class UploadReportsBody {
    agentData: AgentData;
    reportFile: any;
}
export interface IHttpClient {
    get<T>(urlPath: string, callback: (err: Error, response: T, statusCode: number) => void, isNotFoundAcceptable?: boolean, async?: boolean): any;
    delete<T>(body: any, urlPath: string, callback: (err: Error, data: T, statusCode: number) => void): any;
    put(requestData: any, urlPath: string, callback: (err: Error, body: any, statusCode: number) => void, async?: boolean, contentType?: string): any;
    post(requestData: any, urlPath: string, callback: (err: Error, body: any, statusCode: number) => void, async?: boolean, contentType?: ContentType): any;
    postMultipart(requestData: any, urlPath: string, callback: (err: Error, body: any, statusCode: number) => void): any;
    updateMetadata(metadata: Partial<SlAgentMetadata>): void;
}
export interface ITestsRecommendationResponse {
    excludedTests: IExcludedTest[];
    recommendationSetStatus: RecommendationSetStatus;
    testSelectionEnabled: boolean;
}
export interface IExcludedTest {
    name: string;
    universalTestId: string;
    testFramework: string;
}
export declare enum RecommendedTestReason {
    PINNED = "pinned",
    IMPACTED = "impacted",
    FAILED = "failed"
}
export declare enum RecommendationSetStatus {
    NOT_READY = "notReady",
    READY = "ready",
    NO_HISTORY = "noHistory",
    ERROR = "error",
    WONT_BE_READY = "wontBeReady"
}
export interface IBuildEndData {
    appName: string;
    build: string;
    branch: string;
    status: IBuildEndStatus;
}
export interface IBuildEndStatus {
    success: boolean;
}
export declare enum ContentType {
    OCTET_STREAM = "application/octet-stream",
    JSON = "application/json"
}
export declare enum SealightsHeaderNames {
    CONTENT_TYPE = "Content-Type",
    AUTHOTIZARTION = "Authorization",
    MODE = "X-Sealights-Agent-Mode",
    META_DATA = "sl-metadata",
    LAB_ID = "x-sl-labId",
    APP_NAME = "x-sl-appName",
    BRANCH_NAME = "x-sl-branchName",
    BUILD_NAME = "x-sl-buildName",
    BSID = "x-sl-bsid",
    EXECUTION_ID = "x-sl-executionId",
    AGENT_ID = "x-sl-agentId",
    MESSAGE_TYPE = "x-sl-messageType"
}
export declare enum SealightsHaderValues {
    LIGHT_AGENT_MODE = "light"
}
export interface IColoredExecutionRequest {
    executionId: string;
    appName: string;
    buildName: string;
    branchName: string;
    labId: string;
    testStage: string;
    testGroupId?: string;
}
export interface IBuildSessionResponse {
    customerId: string;
    appName: string;
    branchName: string;
    buildName: string;
    buildSessionType: string;
    created: number;
    trackingId: string;
    additionalParams: object;
    buildSessionId: string;
}
