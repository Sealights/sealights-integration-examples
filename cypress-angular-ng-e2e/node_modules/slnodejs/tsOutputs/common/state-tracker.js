"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateTracker = void 0;
const events = require("events");
const sl_env_vars_1 = require("./constants/sl-env-vars");
const validation_utils_1 = require("./utils/validation-utils");
const cockpit_notifier_1 = require("./agent-events/cockpit-notifier");
const agent_events_contracts_1 = require("./agent-events/agent-events-contracts");
const INITIAL_COLOR = '00000000-0000-0000-0000-000000000000/__init';
class StateTracker extends events.EventEmitter {
    constructor(cfg, configProcess, checkTestStatusWatchdog, backendProxy, logger) {
        super();
        this.cfg = cfg;
        this.configProcess = configProcess;
        this.checkTestStatusWatchdog = checkTestStatusWatchdog;
        this.backendProxy = backendProxy;
        this.logger = logger;
        this.currentTestIdentifier = null;
        this.isRunning = false;
        this._openExecutionFoundOnce = false;
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(cfg, 'agentConfig');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(configProcess, 'configProcess');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(checkTestStatusWatchdog, 'watchdog');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(backendProxy, 'backendProxy');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(logger, 'logger');
        if (this.cfg.useInitialColor.value && this.currentTestIdentifier == null) {
            this.switchToAnonFootprints();
        }
        configProcess.on('configuration_changed', (newCfg) => {
            if (newCfg.useInitialColor.value && this.currentTestIdentifier == null) {
                this.switchToAnonFootprints();
            }
            this.cfg = newCfg;
            this.checkTestStatusWatchdog.setInterval(newCfg.executionQueryIntervalSecs.value);
        });
        this.startCheckingTestStatusAtServer();
    }
    startCheckingTestStatusAtServer() {
        if (sl_env_vars_1.SlEnvVars.inProductionListenerMode()) {
            this.logger.debug('In production listener, no need to check test status in server');
            return;
        }
        this.checkTestStatusWatchdog.on('alarm', () => {
            this.checkTestStatusAtServer();
        });
        //Invoke it directly after the CTOR ends when needed.
        if (this.cfg.shouldCheckForActiveExecutionOnStartUp.value) {
            this.checkTestStatusAtServer(false);
        }
    }
    checkTestStatusAtServer(async = true) {
        if (!this.currentTestIdentifier) {
            this.logger.info('\'currentTestIdentifier\' is null. That means that footprints will not be sent.');
        }
        else {
            this.getActiveExecution(async).then((response) => {
                this.fireExecutionEvents(response.execution);
                this.notifyCockpit(response.execution);
                this._currentExecution = response.execution;
            }).catch(err => {
                this.logger.warn(`Error while checking test execution status ${err}`);
            });
        }
    }
    loadExecutionSync() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const executionResponse = yield this.getActiveExecution();
                this.fireExecutionEvents(executionResponse.execution);
                this.notifyCockpit(executionResponse.execution);
                this._currentExecution = executionResponse.execution;
            }
            catch (err) {
                this.logger.warn(`Error while checking test execution status ${err}`);
            }
        });
    }
    getActiveExecution(async = true) {
        return this.backendProxy.testExecutionV4(this.cfg.labId.value, async, this.getExecutionIdForQuery());
    }
    getExecutionIdForQuery() {
        if (this.isAnonymousColor(this.currentTestIdentifier) || !this.currentExecution) {
            return null;
        }
        return this.currentExecution.executionId;
    }
    hasMappingAtServer() {
        return this._currentExecution != null;
    }
    getCollectHitsState() {
        var _a;
        const NO_EXECUTION_HITS_DATA = {
            shouldCollectHits: false,
            reason: StateTracker.NO_ACTIVE_EXECUTION,
            message: 'State tracker has no active execution, agent will not collect hits.',
        };
        const PENDING_EXECUTION_DELETE_DATA = {
            shouldCollectHits: false,
            reason: StateTracker.EXECUTION_STATUS_PENDING_DELETE,
            message: 'State tracker active execution is currently pending for delete, agent will not collect hits.',
        };
        if (!this.hasMappingAtServer()) {
            return NO_EXECUTION_HITS_DATA;
        }
        else if (((_a = this.currentExecution) === null || _a === void 0 ? void 0 : _a.executionId) === this.pendingDeleteExecId) {
            return PENDING_EXECUTION_DELETE_DATA;
        }
        return { shouldCollectHits: true };
    }
    get currentExecution() {
        return this._currentExecution;
    }
    set currentExecution(value) {
        this._currentExecution = value;
    }
    get openExecutionFoundOnce() {
        return this._openExecutionFoundOnce;
    }
    isAnonymousColor(testIdentifier) {
        return INITIAL_COLOR == testIdentifier;
    }
    switchToAnonFootprints() {
        this.logger.info('Switching to anonymous footprints.');
        this.setTestIdentifier(INITIAL_COLOR, false);
    }
    getCurrentTestIdentifier() {
        return this.currentTestIdentifier;
    }
    setTestIdentifier(newTestIdentifier, silent) {
        this.logger.info('setting test identifier: ' + newTestIdentifier);
        if ((this.currentTestIdentifier == null) && (newTestIdentifier != null) || (this.currentTestIdentifier != null && this.currentTestIdentifier != newTestIdentifier && newTestIdentifier != INITIAL_COLOR)) {
            const previousTestIdentifier = this.currentTestIdentifier;
            this.currentTestIdentifier = newTestIdentifier;
            if (this.isRunning) {
                if (!silent) {
                    this.emit('test_identifier_changed', this.currentTestIdentifier, previousTestIdentifier);
                }
                else {
                    this.logger.info('Test identifier changed, running in silent mode not enqueuing footprints');
                }
                this.checkTestStatusWatchdog.reset();
            }
        }
        else {
            this.logger.info('Not setting the color. newTestIdentifier is \'' + newTestIdentifier + '\' ' + 'and currentTestIdentifier is \'' + this.currentTestIdentifier + '\'');
        }
    }
    // Added for backward compatibility with browser agent
    setCurrentTestIdentifier(newTestIdentifier) {
        this.setTestIdentifier(newTestIdentifier);
    }
    start() {
        if (!this.isRunning) {
            this.checkTestStatusWatchdog.start();
            this.isRunning = true;
        }
    }
    stop() {
        try {
            if (!this.isRunning) {
                return;
            }
            this.checkTestStatusWatchdog.stop();
            this.isRunning = false;
        }
        catch (err) {
            this.logger.error(`Error while stopping StateTracker. '${err}'`);
            return;
        }
    }
    getTestStage() {
        var _a;
        return (_a = this.currentExecution) === null || _a === void 0 ? void 0 : _a.testStage;
    }
    static splitTestIdToExecutionAndTestName(testId) {
        testId = testId || '';
        const executionId = testId.split('/')[0];
        let testName = (testId.indexOf('/') == -1) ? '' : testId.substring(executionId.length + 1);
        if (!executionId) {
            testName = '';
        }
        return { executionId: executionId, testName: testName };
    }
    static combineExecutionIdAndTestName(executionId, testName) {
        testName = testName || '';
        if (!executionId) {
            return '';
        }
        return executionId + '/' + testName;
    }
    startColoredExecution(executionId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const request = {
                    appName: this.cfg.appName.value,
                    branchName: this.cfg.branch.value,
                    buildName: this.cfg.build.value,
                    labId: this.cfg.labId.value,
                    testStage: this.cfg.testStage.value,
                    executionId: executionId,
                };
                if (this.cfg.testGroupId.value) {
                    request.testGroupId = this.cfg.testGroupId.value;
                }
                yield this.backendProxy.startColoredExecution(request);
                this.currentExecution = Object.assign(Object.assign({}, request), { buildSessionId: this.cfg.buildSessionId.value, status: StateTracker.EXECUTION_STATUS_CREATED });
            }
            catch (e) {
                this.logger.error(`Failed to create execution, error '${e}'. Footprints will not be sent`);
            }
        });
    }
    fireExecutionEvents(executionData) {
        // No active execution on the server
        if (!executionData) {
            return;
        }
        if (executionData.status == StateTracker.EXECUTION_STATUS_PENDING_DELETE) {
            if (executionData.executionId !== this.pendingDeleteExecId) {
                this.currentExecution = executionData;
                this.emit(StateTracker.EXECUTION_STATUS_PENDING_DELETE, executionData);
                this.pendingDeleteExecId = executionData.executionId;
            }
            return;
        }
        // First time got response from server
        if (!this.currentExecution) {
            return;
        }
        if (this.currentExecution.buildSessionId != executionData.buildSessionId) {
            this.emit(StateTracker.EXECUTION_BSID_CHANGED, this.currentExecution, executionData.buildSessionId);
            return;
        }
        if (this.currentExecution.executionId != executionData.executionId) {
            this.emit(StateTracker.EXECUTION_ID_CHANGED, this.currentExecution, executionData.buildSessionId);
            return;
        }
        if (this.currentExecution.testStage != executionData.testStage) {
            this.emit(StateTracker.TEST_STAGE_CHANGED, this.currentExecution, executionData.testStage);
            return;
        }
    }
    notifyCockpit(execution) {
        if (!execution) {
            cockpit_notifier_1.CockpitNotifier.sendEventOnce(agent_events_contracts_1.AgentEventCode.FIRST_TIME_NO_EXECUTION);
        }
        else {
            cockpit_notifier_1.CockpitNotifier.sendEventOnce(agent_events_contracts_1.AgentEventCode.FIRST_TIME_HAS_EXECUTION);
            this._openExecutionFoundOnce = true;
        }
    }
}
exports.StateTracker = StateTracker;
StateTracker.EXECUTION_ENDS = 'executionEnds';
StateTracker.EXECUTION_BSID_CHANGED = 'executionBsidChanged';
StateTracker.EXECUTION_ID_CHANGED = 'executionIdChanged';
StateTracker.TEST_STAGE_CHANGED = 'testStageChanged';
StateTracker.EXECUTION_STATUS_CREATED = 'created';
StateTracker.EXECUTION_STATUS_PENDING_DELETE = 'pendingDelete';
StateTracker.NO_ACTIVE_EXECUTION = 'noActiveExecution';
//# sourceMappingURL=state-tracker.js.map