"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IstanbulUniqueIdConverter = void 0;
const contracts_1 = require("./contracts");
const unique_id_converter_1 = require("./unique-id-converter");
/*
    this class create uniqueId's in new format but the input is from istanbul.
 */
class IstanbulUniqueIdConverter extends unique_id_converter_1.UniqueIdConverter {
    constructor(filename, logger) {
        super(filename, logger);
    }
    createElementsArray(file) {
        file.fnMap = file.fnMap || {};
        file.branchMap = file.branchMap || {};
        const methodsArr = Object.keys(file.fnMap).map((key) => this.formatMethod(file.fnMap[key]));
        const branchesArr = this.createBranchElements(file.branchMap);
        this.fillFileElementsArray(methodsArr, this.methodsArray, contracts_1.ElementType.METHOD);
        this.fillFileElementsArray(branchesArr, this.branchesArray, contracts_1.ElementType.BRANCH);
    }
    createElementPosition(position) {
        return position;
    }
    createBranchElements(branchesMap) {
        const branchesMapArr = Object.keys(branchesMap).map((key) => branchesMap[key]);
        let branchesArr = [];
        for (const branch of branchesMapArr) {
            branchesArr = branchesArr.concat(this.extractBranchParts(branch));
        }
        return branchesArr;
    }
    /*
        in istanbul data branches has 'locations' array which described all parts of current condition,
        for example: if/else statement will take 2 locations one for the 'if' and one for the 'else'
     */
    extractBranchParts(branch) {
        const formattedBranches = [];
        const locations = branch.locations;
        for (let i = 0; i < locations.length; i++) {
            const element = {};
            element.position = locations[i].start;
            element.endPosition = locations[i].end;
            element.uniqueId = this.filename + '|' + this.formatLoc(element.position) + '|' + i;
            formattedBranches.push(element);
        }
        return formattedBranches;
    }
    formatMethod(method) {
        const element = {};
        element.position = method.loc.start;
        element.endPosition = method.loc.end;
        element.uniqueId = this.filename + '@' + this.formatLoc(method.loc.start);
        if (method.decl && method.decl.start) {
            element.uniqueId_decl = this.filename + '@' + this.formatLoc(method.decl.start);
            /*
                if method body located in different row from declaration we want to align with build scanner so we take
                the declaration as position.
                i.e: function a()
                {
                    do something...
                }
                in that case the 'decl' object will point one line before 'loc' object.
                but in the following example 'decl' and 'loc' points the same line:
                function a(){
                    do something...
                }
             */
            if (method.decl.start.line < method.loc.start.line) {
                element.position = method.decl.start;
            }
        }
        return element;
    }
    formatLoc(loc) {
        return loc.line + ',' + loc.column;
    }
}
exports.IstanbulUniqueIdConverter = IstanbulUniqueIdConverter;
//# sourceMappingURL=istanbul-unique-id-converter.js.map