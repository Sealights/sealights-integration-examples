"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniqueIdConverter = void 0;
const contracts_1 = require("./contracts");
const file_element_1 = require("./file-element");
const METHOD_DELIMITER = '@';
const BRANCH_DELIMITER = '|';
const NULL_PARAM_MESSAGE = 'cannot be null or undefined';
/*
    this class create uniqueId's in new format for build mapping input.
 */
class UniqueIdConverter {
    constructor(filename, logger) {
        if (!filename) {
            throw new Error('\'filename\' ' + NULL_PARAM_MESSAGE);
        }
        if (!logger) {
            throw new Error('\'logger\' ' + NULL_PARAM_MESSAGE);
        }
        this._filename = filename;
        this.logger = logger;
        this._uniqueIdsMap = {};
        this._methodsArray = [];
        this._branchesArray = [];
    }
    sortElements() {
        this._methodsArray = this._methodsArray.sort(this.comparePosition);
        this._branchesArray = this._branchesArray.sort(this.comparePosition);
    }
    createElementsArray(file) {
        file.methods = file.methods || [];
        file.branches = file.branches || [];
        this.fillFileElementsArray(file.methods, this._methodsArray, contracts_1.ElementType.METHOD);
        this.fillFileElementsArray(file.branches, this._branchesArray, contracts_1.ElementType.BRANCH);
    }
    createFileElement(element, filename, type) {
        const startPosition = this.createElementPosition(element.position);
        const endPosition = this.createElementPosition(element.endPosition);
        const fileElement = new file_element_1.FileElement(type, startPosition, endPosition, element.uniqueId, filename);
        if (element.uniqueId_decl) {
            fileElement.uniqueIdKey_decl = element.uniqueId_decl;
        }
        /*
         Istanbul reports 'if' and 'else' in same position. old uniqueId is based on parent position (equal to the 'if'
         location). so here we consider the parent position as start position, but to keep branches order we add the
         'index' value to column.
         */
        if (element.parentPosition) {
            const index = element.index || 0;
            fileElement.startPosition = this.createElementPosition(element.parentPosition);
            fileElement.index = index;
        }
        return fileElement;
    }
    process() {
        this.removeDuplicateElements(this._methodsArray);
        this.removeDuplicateElements(this._branchesArray);
        this.sortElements();
        this.logger.debug(`sorted ${this._branchesArray.length} branches`);
        this.logger.debug(`sorted ${this._methodsArray.length} methods`);
        this.fillUniqueIdsMap();
    }
    setAndInitFile(file) {
        this.createElementsArray(file);
    }
    createElementPosition(position) {
        let line;
        let column;
        if (Array.isArray(position) && position.length === 2) {
            line = parseInt(position[0]);
            column = parseInt(position[1]);
        }
        else {
            throw new Error('element has no correct startPosition array, cannot resolve startPosition');
        }
        return {
            column,
            line,
        };
    }
    fillFileElementsArray(elements, array, type) {
        for (const element of elements) {
            array.push(this.createFileElement(element, this._filename, type));
        }
    }
    fillUniqueIdsMap() {
        this.createNewUniqueIds(this._methodsArray, METHOD_DELIMITER);
        this.createNewUniqueIds(this._branchesArray, BRANCH_DELIMITER);
    }
    createNewUniqueIds(array, delimiter) {
        const aggregatedByLine = this.aggregateElementsByLine(array);
        const lines = Object.keys(aggregatedByLine);
        for (const line of lines) {
            const indexesArray = aggregatedByLine[line];
            for (let i = 0; i < indexesArray.length; i++) {
                const currentIndex = indexesArray[i];
                const currentElement = array[currentIndex];
                currentElement.uniqueId = currentElement.filename + delimiter + line + ',' + i;
                this.logger.debug(`[UniqueIdConverter] uniqueId ${currentElement.uniqueIdKey} converted to 
                               ${currentElement.uniqueId}`);
                this._uniqueIdsMap[currentElement.uniqueIdKey] = currentElement.uniqueId;
                if (currentElement.uniqueIdKey_decl) {
                    this._uniqueIdsMap[currentElement.uniqueIdKey_decl] = currentElement.uniqueId;
                }
            }
        }
    }
    comparePosition(elm1, elm2) {
        if (elm1.startPosition.line < elm2.startPosition.line) {
            return -1;
        }
        if (elm1.startPosition.line > elm2.startPosition.line) {
            return 1;
        }
        if (elm1.startPosition.column < elm2.startPosition.column) {
            return -1;
        }
        if (elm1.startPosition.column > elm2.startPosition.column) {
            return 1;
        }
        if (elm1.index < elm2.index) {
            return -1;
        }
        if (elm1.index > elm2.index) {
            return 1;
        }
        return 0;
    }
    get uniqueIdsMap() {
        return this._uniqueIdsMap;
    }
    get methodsArray() {
        return this._methodsArray;
    }
    set methodsArray(value) {
        this._methodsArray = value;
    }
    get branchesArray() {
        return this._branchesArray;
    }
    set branchesArray(value) {
        this._branchesArray = value;
    }
    get filename() {
        return this._filename;
    }
    removeDuplicateElements(elementsArray) {
        const existedKeys = {};
        elementsArray = elementsArray.filter((element) => {
            return this.filterDuplicates(element, existedKeys);
        });
    }
    filterDuplicates(element, existedKeys) {
        if (existedKeys[element.uniqueIdKey] ||
            (element.uniqueIdKey_decl && existedKeys[element.uniqueIdKey_decl])) {
            return false;
        }
        existedKeys[element.uniqueIdKey] = true;
        if (element.uniqueIdKey_decl) {
            existedKeys[element.uniqueIdKey_decl] = true;
        }
        return true;
    }
    removeBranchesOutOfMethods() {
        const validBranches = [];
        let methodsIndex = 0;
        for (const branch of this._branchesArray) {
            for (let i = methodsIndex; i < this._methodsArray.length; i++) {
                const currentMethod = this._methodsArray[i];
                const branchPosition = this.checkBranchPosition(branch, currentMethod);
                if (branchPosition === 0) {
                    validBranches.push(branch);
                    break;
                }
                if (branchPosition === 1) {
                    methodsIndex++;
                }
            }
        }
        this._branchesArray = validBranches.sort(this.comparePosition);
    }
    /*
        this method checks if specific branch is inside specific method
        if inside method returns: 0
        if after method returns: 1
        if before method returns: -1
     */
    checkBranchPosition(branch, method) {
        if (branch.isStartsAfter(method) && branch.isEndsBefore(method)) {
            return 0;
        }
        if (branch.isStartsBefore(method) && branch.isEndsBefore(method)) {
            return -1;
        }
        if (branch.isStartsAfter(method) && branch.isEndsAfter(method)) {
            return 1;
        }
        this.logger.warn(`branch started at '${branch.startPosition.line},${branch.startPosition.column}' in file '${this._filename}' located across methods, probably some error`);
        return 0;
    }
    aggregateElementsByLine(elements) {
        const aggregated = {};
        for (let i = 0; i < elements.length; i++) {
            const element = elements[i];
            const lineNumber = element.startPosition.line;
            if (!aggregated[lineNumber]) {
                aggregated[lineNumber] = [];
            }
            aggregated[lineNumber].push(i);
        }
        return aggregated;
    }
}
exports.UniqueIdConverter = UniqueIdConverter;
//# sourceMappingURL=unique-id-converter.js.map