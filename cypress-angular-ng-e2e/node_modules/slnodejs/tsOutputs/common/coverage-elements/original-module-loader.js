"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OriginalModuleLoader = void 0;
const validation_utils_1 = require("../utils/validation-utils");
const files_utils_1 = require("../utils/files-utils");
const source_maps_utils_1 = require("../source-maps-utils");
/*
    This class iterate over all elements in istanbul coverage data and checks if they are generated from other files.
    if so we read source maps data and load the original module into istanbul modules.
    use cases:
        1. retrieve '.ts' files from generated '.js' files.
        2. retrieve '.js' files from 'bundle.js' that generated using webpack.
 */
const BRANCHES_MAP_KEY = 'branchMap';
const METHODS_MAP_KEY = 'fnMap';
class OriginalModuleLoader {
    constructor(coverageObject, logger) {
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(coverageObject, 'coverageObject');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(logger, 'logger');
        this.coverageObject = coverageObject;
        this.logger = logger;
        this._fileToSourceMapConsumer = {};
    }
    load() {
        const modules = Object.keys(this.coverageObject);
        modules.map(moduleName => this.tryLoadOriginalModule(moduleName));
    }
    tryLoadOriginalModule(istanbulModule) {
        if (!this.getSourceMapForFile(istanbulModule)) {
            // No source maps for file, nothing to load.
            return;
        }
        this.readOriginalModule(istanbulModule);
    }
    readOriginalModule(moduleName) {
        const sourceMapsReader = this.getSourceMapForFile(moduleName);
        const module = this.coverageObject[moduleName];
        Object.keys(module.branchMap).forEach(key => this.resolveAndAddBranch(module.branchMap[key], sourceMapsReader, moduleName));
        Object.keys(module.fnMap).map(key => this.resolveAndAddMethod(module.fnMap[key], sourceMapsReader, moduleName));
    }
    resolveAndAddMethod(method, sourceMapsReader, moduleName) {
        const originalMethod = this.createEmptyMethodObject();
        originalMethod.name = method.name;
        const originalModuleName = this.loadOriginalDataForElement(sourceMapsReader, method, moduleName, originalMethod);
        if (originalModuleName) {
            this.addElementToModule(originalModuleName, originalMethod, METHODS_MAP_KEY);
        }
    }
    resolveAndAddBranch(branch, sourceMapsReader, moduleName) {
        const originalBranch = this.createEmptyBranchObject();
        originalBranch.type = branch.type;
        const originalModuleName = this.loadOriginalDataForElement(sourceMapsReader, branch, moduleName, originalBranch);
        if (originalModuleName) {
            const originalLocations = branch.locations.map(locationElement => this.createElementSourceData(locationElement, sourceMapsReader, moduleName));
            originalBranch.locations = originalLocations;
            this.addElementToModule(originalModuleName, originalBranch, BRANCHES_MAP_KEY);
        }
    }
    loadOriginalDataForElement(sourceMapsReader, element, moduleName, originalElement) {
        const sourceMapDataForStart = this.readSourceMapData(sourceMapsReader, element.loc.start, moduleName);
        const sourceMapDataForEnd = this.readSourceMapData(sourceMapsReader, element.loc.end, moduleName);
        if (!sourceMapDataForStart) {
            // current method has no source data
            return;
        }
        originalElement.loc.start = sourceMapDataForStart.originalPosition;
        originalElement.line = sourceMapDataForStart.originalPosition.line;
        const originalModuleName = sourceMapDataForStart.originalFilename;
        if (sourceMapDataForEnd) {
            originalElement.loc.end = sourceMapDataForEnd.originalPosition;
        }
        if (element.decl) {
            originalElement.decl = {};
            const sourceMapDataForDeclStart = this.readSourceMapData(sourceMapsReader, element.decl.start, moduleName);
            const sourceMapDataForDeclEnd = this.readSourceMapData(sourceMapsReader, element.decl.end, moduleName);
            if (sourceMapDataForDeclStart) {
                originalElement.decl.start = sourceMapDataForDeclStart.originalPosition;
            }
            if (sourceMapDataForDeclEnd) {
                originalElement.decl.end = sourceMapDataForDeclEnd.originalPosition;
            }
        }
        return originalModuleName;
    }
    addElementToModule(moduleName, element, mapObjectKey) {
        const module = this.getOrCreateIstanbulModule(moduleName);
        const key = this.createElementKey(element);
        if (!module[mapObjectKey][key]) {
            module[mapObjectKey][key] = element;
        }
    }
    createElementSourceData(locationElement, sourceMapsReader, moduleName) {
        const sourceMapDataForStart = this.readSourceMapData(sourceMapsReader, locationElement.start, moduleName);
        const sourceMapDataForEnd = this.readSourceMapData(sourceMapsReader, locationElement.end, moduleName);
        if (!sourceMapDataForStart && !sourceMapDataForEnd) {
            return {};
        }
        const sourceLocationElement = {
            start: sourceMapDataForStart.originalPosition,
            end: sourceMapDataForEnd.originalPosition,
        };
        return sourceLocationElement;
    }
    getOrCreateIstanbulModule(moduleName) {
        let module = this.coverageObject[moduleName];
        if (!module) {
            module = this.createIstanbulModule(moduleName);
            this.coverageObject[moduleName] = module;
        }
        return module;
    }
    getSourceMapForFile(fullPath) {
        if (!this._fileToSourceMapConsumer[fullPath]) {
            this._fileToSourceMapConsumer[fullPath] = source_maps_utils_1.SourceMapsUtils.readSourceMaps(fullPath);
            this.logger.debug('Read source maps for file\':' + fullPath + '\'');
        }
        const sourceMap = this._fileToSourceMapConsumer[fullPath];
        return sourceMap;
    }
    readSourceMapData(sourceMaps, start, fullPath) {
        if (!sourceMaps)
            return null;
        try {
            const originalPosition = sourceMaps.originalPositionFor(start); //{ line: start.line, column: start[1] });
            if (originalPosition && originalPosition.source && originalPosition.line !== null && originalPosition.column !== null) {
                let originalFilename = originalPosition.source;
                if (originalFilename.indexOf('webpack:///webpack/') === -1 &&
                    originalFilename.indexOf('webpack:///external') === -1) { //Ignore embedded and external module
                    if (originalFilename.indexOf('webpack:///') === 0) {
                        originalFilename = originalFilename.substring(11); //'webpack:///'.length
                    }
                    originalFilename = files_utils_1.FilesUtils.resolveOriginalFullFileName(fullPath, originalFilename);
                    const originalPositionObj = { line: originalPosition.line, column: originalPosition.column };
                    const result = { originalFilename: originalFilename, originalPosition: originalPositionObj };
                    return result;
                }
            }
        }
        catch (e) {
            console.log(e);
        }
        return null;
    }
    createElementKey(element) {
        return element.loc.start.line + ':' + element.loc.start.column;
    }
    createEmptyBranchObject() {
        return {
            loc: {},
            locations: [],
            type: '',
            line: null
        };
    }
    createEmptyMethodObject() {
        return {
            loc: {},
            name: '',
            line: null
        };
    }
    createIstanbulModule(path) {
        return {
            s: {},
            f: {},
            b: {},
            fnMap: {},
            statementMap: {},
            branchMap: {},
            path: path,
            uniqueIdsMap: null
        };
    }
    get fileToSourceMapConsumer() {
        return this._fileToSourceMapConsumer;
    }
    set fileToSourceMapConsumer(value) {
        this._fileToSourceMapConsumer = value;
    }
}
exports.OriginalModuleLoader = OriginalModuleLoader;
//# sourceMappingURL=original-module-loader.js.map