"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Git = void 0;
const child_process_1 = require("child_process");
const git_format_builder_1 = require("./git-format-builder");
const cockpit_notifier_1 = require("../agent-events/cockpit-notifier");
const agent_events_contracts_1 = require("../agent-events/agent-events-contracts");
const git_log_parser_1 = require("./git-log-parser");
const GIT_ROOT_DIR_COMMAND = 'rev-parse --show-toplevel';
const GIT_LS_FILES_COMMAND = 'ls-tree --full-tree -r --name-only HEAD';
const MAX_BUFFER_VALUE = 1024 * 1024 * 200; //200 Mb, instead of 200Kb
class Git {
    constructor(buildArgs) {
        this.buildArgs = buildArgs;
    }
    detectCommitVersion(handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = logger.child({ methodName: 'detectCommitVersion' });
            const commit = yield this.executeGit('log -n 1 --pretty=format:%H', handlerParams, log);
            return commit;
        });
    }
    getBranchHistory(handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const buildArgs = this.getBuildArgs();
            const log = logger.child({ methodName: 'getBranchHistory' });
            const historyLength = this.getHistoryLength(buildArgs, log);
            const { keyValueSeparator, recordSeparator } = git_format_builder_1.GitFormatBuilder.generateSeparators();
            const format = new git_format_builder_1.GitFormatBuilder(false, keyValueSeparator, recordSeparator).withCommit().withAuthorName().withAuthorEmail().withCommiterName().withCommiterEmail()
                .withAuthorDate().withCommiterDate().withTitle().build();
            const stdout = yield this.executeGit(`log -n ${historyLength} --format='${format}'`, handlerParams, log);
            return this.parseBranchHistoryOutput(stdout, handlerParams, log, keyValueSeparator, recordSeparator);
        });
    }
    getCommitsPerFile(handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const buildArgs = this.getBuildArgs();
            const log = logger.child({ methodName: 'getCommitsPerFile' });
            const historyLength = this.getHistoryLength(buildArgs, log);
            const commitToIndexMap = handlerParams.commitToIndexMap;
            if (!commitToIndexMap) {
                logger.error('Cannot get commits for file, Commits log map is null or undefined');
                return {};
            }
            const stdout = yield this.executeGit('log -' + historyLength + ' --name-only --pretty=format:hash:%H', handlerParams, log);
            return this.parseCommitsPerFileOutput(stdout, commitToIndexMap, log);
        });
    }
    getRepositoryUrl(handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = logger.child({ methodName: 'getRepositoryUrl' });
            const stdout = yield this.executeGit('remote -v', handlerParams, log);
            let repositoryUrl = '';
            if (stdout.toString()) {
                const parsedLog = this.logParse(stdout.toString());
                //NOTE: If there are multiple (fetch) remotes, it would be best to pick the line with that has "origin" as the first column (before the \t), if one exists.
                //Anyway we should also warn that there were multiple remotes detected
                repositoryUrl = parsedLog[0].split('\t').map(function (l) { return l.trim(); })[1].replace(' (fetch)', '');
            }
            return repositoryUrl;
        });
    }
    getRootDirectory(handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = logger.child({ methodName: 'getRootDirectory' });
            const stdout = yield this.executeGit(GIT_ROOT_DIR_COMMAND, handlerParams, log);
            return stdout.toString().trim();
        });
    }
    getCurrentGitBranch(handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = logger.child({ methodName: 'getCurrentGitBranch' });
            try {
                const stdout = yield this.executeGit('rev-parse --abbrev-ref HEAD', handlerParams, log);
                return stdout.toString().trim();
            }
            catch (e) {
                log.error('Git get current branch error: ' + e);
            }
        });
    }
    getOpenGitBranches(handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = logger.child({ methodName: 'getOpenGitBranches' });
            try {
                const stdout = yield this.executeGit('show-ref', handlerParams, log);
                return this.logParse(stdout.toString());
            }
            catch (e) {
                log.error('Git get open branches error: ' + e);
            }
        });
    }
    getGitSubmodules(handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = logger.child({ methodName: 'getGitSubmodules' });
            try {
                const stdout = yield this.executeGit('submodule', handlerParams, log);
                const submoduleList = this.logParse(stdout.toString());
                if (submoduleList.length) {
                    cockpit_notifier_1.CockpitNotifier.sendEvent(agent_events_contracts_1.AgentEventCode.GIT_SUBMODULES_DETECTED, submoduleList);
                }
                return submoduleList;
            }
            catch (e) {
                log.error('Git get submodules error: ' + e);
            }
        });
    }
    getFiles(handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = logger.child({ methodName: 'getFiles' });
            const stdout = yield this.executeGit(GIT_LS_FILES_COMMAND, handlerParams, log);
            return stdout.trim().split('\n').map(file => file.trim()).filter(file => file.length > 0);
        });
    }
    getContributors(handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const buildArgs = this.getBuildArgs();
            const log = logger.child({ methodName: 'getContributors' });
            const historyLength = this.getHistoryLength(buildArgs, log);
            const format = new git_format_builder_1.GitFormatBuilder().withAuthorName('contributorName').withAuthorEmail('contributorEmail').build();
            const stdout = yield this.executeGit('log -n ' + historyLength + ' --all --format=' + format, handlerParams, log);
            return this.parseContributorsOutput(stdout, log);
        });
    }
    getGitDiffs(refCommit, handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = logger.child({ methodName: 'getGitDiffs' });
            const stdout = yield this.executeGit('diff ' + refCommit + ' --name-status -M100', handlerParams, log);
            const parsedLog = this.parseGitDiffs(stdout.toString()).filter(d => d.op != 'unknown' && d.path);
            return parsedLog;
        });
    }
    getCommitOnlyHistory(historyLength, handlerParams, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            if (historyLength < 1)
                historyLength = 1;
            const log = logger.child({ methodName: 'getCommitOnlyHistory' });
            const format = new git_format_builder_1.GitFormatBuilder().withCommit();
            const stdout = yield this.executeGit('log -n ' + historyLength + ' --format=' + format, handlerParams, log);
            return this.logParse(stdout.toString());
        });
    }
    /**
     *
     * @param gitArgs full git command, without the 'git' prefix, e.g. log -n 1
     * @param handlerParams
     * @param log
     */
    executeGit(gitArgs, handlerParams, log) {
        const gitPath = this.getGitPath();
        return new Promise((resolve, reject) => {
            try {
                log.info('GIT: invoking git ' + gitArgs);
                log.info('GIT PATH: ' + gitPath);
                const cmd = gitPath + ' ' + gitArgs;
                (0, child_process_1.exec)(cmd, {
                    cwd: handlerParams.buildArguments.workspacepath,
                    maxBuffer: MAX_BUFFER_VALUE
                }, (error, stdout, stderr) => {
                    if (error !== null) {
                        log.error('GIT log error: ' + error);
                        return reject(error);
                    }
                    return resolve(stdout.toString().trim());
                });
            }
            catch (e) {
                log.error('GIT execution error: ' + e);
                reject(e);
            }
        });
    }
    parseContributorsOutput(stdout, logger) {
        const contributors = [];
        const emailToIndexMap = {};
        const lines = stdout.toString().split('\n');
        let contributorIndex = 0;
        lines.forEach((line, lineIndex) => {
            if (!line || line.trim().length == 0) {
                return;
            }
            line = line.trim();
            try {
                line = this.fixUnSupportedJsonCharacters(line);
                const contributorData = JSON.parse(line);
                if (!emailToIndexMap.hasOwnProperty(contributorData.contributorEmail)) {
                    contributors.push(contributorData);
                    emailToIndexMap[contributorData.contributorEmail] = contributorIndex++;
                }
            }
            catch (err) {
                this.logJsonParseError(logger, line, 'contributor', err);
            }
        });
        const contributorsLog = {
            contributors: contributors,
            emailToIndexMap: emailToIndexMap
        };
        return contributorsLog;
    }
    getGitPath() {
        return (this.getBuildArgs() || {}).gitPath || 'git';
    }
    getBuildArgs() { return this.buildArgs; }
    createCommitLogEntryWithContributorRef(commit, handlerParams) {
        const authorIndex = handlerParams.emailToIndexMap[commit.authorEmail];
        return {
            commit: commit.commit,
            contributorIndex: authorIndex,
            authorDate: commit.authorDate,
            commiterDate: commit.commiterDate,
            title: commit.title,
        };
    }
    logParseError(logger, line, err) {
        logger.warn(`Failed to parse git output - ${line}`);
        logger.debug(`Error: ${err}`);
    }
    logJsonParseError(logger, line, field, err) {
        logger.warn(`Unsupported string format "${line}". '${field}'  may not be shown in dashboard`);
        logger.debug(`Error: ${err}`);
    }
    parseBranchHistoryOutput(stdout, handlerParams, logger, keyValueSeparator, recordSeparator) {
        const commitHistory = [];
        const commitLog = [];
        const commitToIndexMap = {};
        const shouldSendContributors = handlerParams.buildArguments.sendContributors;
        const shouldSendCommitTitles = handlerParams.buildArguments.sendCommitTitles;
        const gitLogParser = new git_log_parser_1.GitLogParser(keyValueSeparator, recordSeparator);
        try {
            const commits = gitLogParser.parseMany(stdout);
            commits.forEach((commit, index) => {
                let commitToSave = Object.assign(Object.assign({}, commit), { authorDate: parseInt(commit.authorDate), commiterDate: parseInt(commit.commiterDate) });
                if (shouldSendContributors) {
                    commitToSave = this.createCommitLogEntryWithContributorRef(commitToSave, handlerParams);
                }
                if (!shouldSendCommitTitles && commit.title) {
                    commitToSave.title = '';
                }
                commitHistory.push(commitToSave.commit);
                commitLog.push(commitToSave);
                commitToIndexMap[commitToSave.commit] = index.toString();
            });
        }
        catch (err) {
            this.logParseError(logger, stdout, err);
        }
        const gitLog = {
            commitHistory,
            commitLog,
            commitToIndexMap: undefined
        };
        if (shouldSendContributors) {
            gitLog.commitToIndexMap = commitToIndexMap;
        }
        return gitLog;
    }
    parseCommitsPerFileOutput(stdout, commitToIndexMap, log) {
        const fileToCommitMap = {};
        const commits = stdout.toString().split('hash:');
        try {
            commits.forEach((currCommit) => {
                currCommit = currCommit.trim();
                const commitData = currCommit.split('\n');
                if (commitData.length < 2) {
                    return;
                }
                const commitHash = commitData[0];
                for (let i = 1; i < commitData.length; i++) {
                    if (fileToCommitMap[commitData[i]]) {
                        fileToCommitMap[commitData[i]].push(commitToIndexMap[commitHash]);
                    }
                    else {
                        fileToCommitMap[commitData[i]] = [commitToIndexMap[commitHash]];
                    }
                }
            });
        }
        catch (e) {
            log.error('File to commit map error: ' + e);
        }
        return fileToCommitMap;
    }
    getHistoryLength(cfg, log) {
        let historyLength = 100;
        if (cfg.branchHistoryLength) {
            const v = parseInt(cfg.branchHistoryLength);
            if (v < 1 || Number.isNaN(v)) {
                log.error('An invalid value was specified for branchHistoryLength in sealights.json: ' + cfg.branchHistoryLength + '. Valid values are positive integers. Defaulting to ' + historyLength);
            }
            else {
                historyLength = v;
            }
        }
        return historyLength;
    }
    fixUnSupportedJsonCharacters(entry) {
        // Backslashes ar not supported by json format so we replace it to double slashes.
        // For more info please see 'http://json.org/' (the string schema).
        return entry.replace(/\\/g, '\\\\');
    }
    logParse(stdout) {
        //git output contains exactly one hash per line, so little processing is required.
        return stdout.split('\n').map(function (l) { return l.trim(); });
    }
    //Parse git log output from 'git diff [revision] --name-status -M100
    parseGitDiffs(stdout) {
        return stdout.split('\n').map(function (l) {
            const parts = l.trim().split('\t');
            const fileStatus = parts[0];
            const path = parts[1];
            const newPath = parts[2];
            const diffEntry = { op: 'unknown', path };
            switch (fileStatus[0]) {
                case 'A':
                    diffEntry.op = 'added';
                    break;
                case 'D':
                    diffEntry.op = 'deleted';
                    break;
                case 'M':
                    diffEntry.op = 'modified';
                    break;
                case 'R': //file renamed and possibly modified, depending on the rank (3 digits that follow the 'R'). rank = 100 means "renamed", otherwise renamed-modified
                    {
                        const rank = parseInt(fileStatus.substr(1));
                        diffEntry.op = (rank == 100) ? 'renamed' : 'renamed-modified';
                        diffEntry.newPath = newPath;
                    }
                    break;
            }
            return diffEntry;
        });
    }
}
exports.Git = Git;
//# sourceMappingURL=git.js.map