"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FootprintsServiceProxy = void 0;
const http_client_1 = require("../http/http-client");
const sl_routes_1 = require("../http/sl-routes");
const messages_formatter_1 = require("../messages-formatter");
class FootprintsServiceProxy {
    constructor(cfg, agentInstanceData, logger) {
        this.initHttpConfig(cfg);
        this.logger = logger;
        const httpClientMetadata = {
            agentId: agentInstanceData.agentId,
            buildSessionId: cfg.buildSessionId.value,
            agentType: agentInstanceData.agentType,
            agentTechnology: agentInstanceData.technology,
        };
        this.httpClient = new http_client_1.HttpClient(this.httpConfig, httpClientMetadata, logger);
    }
    handleFootprints(footprintsPacket, callback) {
        if (!footprintsPacket) {
            this.logger.info('Submit footprints - got null or empty packet. Skip submitting.');
            callback(null);
            return;
        }
        const hitFiles = this.getHitFiles(footprintsPacket);
        this.logger.debug(`Submitting footprints, tests: ${JSON.stringify(footprintsPacket.tests)}`);
        this.logger.debug(`Submitting footprints, files: ${hitFiles}`);
        const url = sl_routes_1.SLRoutes.footprintsV5();
        this.httpClient.post(footprintsPacket, url, callback);
    }
    submitFootprints(footprintsPacket, callback) {
        this.handleFootprints(footprintsPacket, callback);
    }
    initHttpConfig(cfg) {
        const config = {
            token: cfg.token.value,
            server: cfg.server.value,
            proxy: cfg.proxy.value,
            compressRequests: cfg.gzip.hasValue ? cfg.gzip.value : true,
            buildSessionId: cfg.buildSessionId.value,
        };
        this.httpConfig = config;
    }
    getHitFiles(packetToSend) {
        if (!this.logger.isDebugEnabled()) {
            return;
        }
        const formatter = new messages_formatter_1.MessagesFormatter();
        if (packetToSend && packetToSend.apps && packetToSend.apps[0] && packetToSend.apps[0].files) {
            packetToSend.apps[0].files.forEach((file) => {
                formatter.addContent(file.path);
            });
        }
        return formatter.content;
    }
}
exports.FootprintsServiceProxy = FootprintsServiceProxy;
//# sourceMappingURL=footprints-service-proxy.js.map