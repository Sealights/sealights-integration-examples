"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IstanbulToFootprints = void 0;
const messages_formatter_1 = require("../messages-formatter");
const original_module_loader_1 = require("../coverage-elements/original-module-loader");
const source_maps_utils_1 = require("../source-maps-utils");
const sl_env_vars_1 = require("../constants/sl-env-vars");
const source_map_handler_1 = require("../source-map-handler");
const new_id_resolver_1 = require("../coverage-elements/new-id-resolver");
const GLOBAL_ISTANBUL_CONTAINER_NAMES = ['__coverage__'];
class IstanbulToFootprints {
    constructor(cfg, logger) {
        this.cfg = cfg;
        this.totalTests = 0;
        this.previousIstanbulCounters = {};
        this.relativeModulePaths = {};
        if (!logger)
            throw new Error('logger is required');
        if (!cfg)
            throw new Error('cfg is required');
        this.logger = logger;
    }
    resetState() {
        this.totalTests = 0;
        //Holds the a mapping between a uniqueId for an element in a test, to an index in this elements 'hits' array.
        this.eidToHitsIndex = {};
        this.uniqueIdToElement = {};
        this.testNameToTestData = {};
        this.fileNameToAppFile = {};
        this.fileToSourceMapConsumer = {};
    }
    createFootprintsPackageFromQueue(queuedFootprints, extraData) {
        this.resetState();
        const result = this.createFootprintsAppData(extraData);
        const istanbulMaps = this.getIstanbulCounters();
        if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
            this.loadOriginalModules();
        }
        queuedFootprints.forEach(fp => {
            this.convertIstanbulDataToFootprints(fp, result, istanbulMaps);
        });
        return result;
    }
    createFootprintsPackageFromRawData(rawData, extraData) {
        this.resetState();
        this.nycFinalReportData = rawData.footprints;
        const result = this.createFootprintsAppData(extraData);
        if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
            this.loadOriginalModules();
        }
        this.convertIstanbulDataToFootprints(rawData, result);
        return result;
    }
    convertIstanbulDataToFootprints(footprintsElement, result, istanbulMaps) {
        const test = this.getOrCreateTestData(footprintsElement, result);
        const app = result.apps[0]; // We assume single App for now.
        const fullIstanbulData = istanbulMaps || footprintsElement.footprints;
        for (const moduleName in footprintsElement.footprints) {
            let istanbulModule = footprintsElement.footprints[moduleName];
            let moduleWithMaps = fullIstanbulData[moduleName];
            if (!istanbulModule.f && istanbulModule.data) {
                istanbulModule = istanbulModule.data;
                moduleWithMaps = moduleWithMaps.data;
            }
            this.logger.debug('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~');
            this.logger.debug(`moduleName: ${moduleName}`);
            if (!moduleWithMaps) {
                this.logger.info(`Cannot find full istanbul data for ${moduleName}`);
                continue;
            }
            const relativePath = this.getRelativeModulePath(moduleWithMaps);
            const sourceMap = this.getSourceMapForModule(moduleName);
            const file = this.getOrCreateFootprintsAppFile(relativePath, app);
            if (istanbulModule.f) {
                this.handleFunctionsData(istanbulModule, moduleWithMaps, sourceMap, relativePath, moduleWithMaps.path, file, test);
            }
            if (istanbulModule.b) {
                this.handleBranchesData(istanbulModule, moduleWithMaps, sourceMap, relativePath, moduleWithMaps.path, file, test);
            }
        }
    }
    handleBranchesData(istanbulModule, moduleWithMaps, sourceMap, relPath, fullPath, file, test) {
        for (const branchId in istanbulModule.b) {
            const ifElseAndSwitchCasesArr = istanbulModule.b[branchId];
            const expressionInfo = moduleWithMaps.branchMap[branchId];
            for (let idx = 0; idx < ifElseAndSwitchCasesArr.length; idx++) {
                const branchInfo = expressionInfo.locations[idx];
                const hits = ifElseAndSwitchCasesArr[idx];
                if (hits > 0) {
                    let start = branchInfo.start;
                    const sourceMapData = this.readSourceMapData(sourceMap, start, relPath, fullPath);
                    let filePath = relPath;
                    let fullFilePath = fullPath;
                    if (sourceMapData) {
                        filePath = sourceMapData.relativePath;
                        start = sourceMapData.originalStart;
                        fullFilePath = sourceMapData.absolutePath;
                    }
                    let uniqueId = filePath + '|' + this.formatLoc(start) + '|' + idx;
                    if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
                        const uniqueIdKey = filePath + '|' + this.formatLoc(start) + '|' + idx;
                        uniqueId = (0, new_id_resolver_1.resolveNewId)(uniqueIdKey, fullFilePath, filePath, this.getCoverageObject(), this.logger);
                    }
                    if (!uniqueId) {
                        continue;
                    }
                    const branchElement = this.getOrCreateBranchElement(uniqueId, file);
                    if (this.cfg.extendedFootprints.value) {
                        branchElement.branchInfo = JSON.stringify(branchInfo);
                        branchElement.sourceMapData = JSON.stringify(sourceMapData);
                    }
                    this.addOrUpdateElementHits(test, uniqueId, branchElement, hits);
                }
            }
        }
    }
    handleFunctionsData(istanbulModule, moduleWithMaps, sourceMap, relativePath, fullPath, file, test) {
        for (const funcId in istanbulModule.f) {
            const hits = istanbulModule.f[funcId];
            if (hits > 0) {
                const funcInfo = moduleWithMaps.fnMap[funcId];
                let start = funcInfo.loc.start;
                const sourceMapData = this.readSourceMapData(sourceMap, start, relativePath, fullPath);
                let filePath = relativePath;
                let fullFilePath = fullPath;
                if (sourceMapData) {
                    filePath = sourceMapData.relativePath;
                    start = sourceMapData.originalStart;
                    fullFilePath = sourceMapData.absolutePath;
                }
                let uniqueId = filePath + '@' + this.formatLoc(start);
                if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
                    const uniqueIdKey = filePath + '@' + this.formatLoc(start);
                    uniqueId = (0, new_id_resolver_1.resolveNewId)(uniqueIdKey, fullFilePath, filePath, this.getCoverageObject(), this.logger);
                }
                if (!uniqueId) {
                    continue;
                }
                const methodElement = this.getOrCreateMethodElement(uniqueId, file);
                if (this.cfg.extendedFootprints.value) {
                    methodElement.funcInfo = JSON.stringify(funcInfo);
                    methodElement.sourceMapData = JSON.stringify(sourceMapData);
                }
                this.addOrUpdateElementHits(test, uniqueId, methodElement, hits);
                if (funcInfo.decl) {
                    this.addDeclarationFootprints(funcInfo, sourceMap, relativePath, file, fullPath, test, hits);
                }
            }
        }
    }
    addDeclarationFootprints(funcInfo, sourceMap, relativePath, file, fullpath, test, hits) {
        let declStart = funcInfo.decl.start; //For NYC
        const sourceMapData = this.readSourceMapData(sourceMap, declStart, relativePath, fullpath);
        if (sourceMapData) {
            relativePath = sourceMapData.relativePath;
            declStart = sourceMapData.originalStart;
        }
        let declUniqueId = relativePath + '@' + this.formatLoc(declStart);
        /*
            There is some edge case where 'loc' object of one method is same as 'decl' object of another method, and
            this can lead to missing coverage for first method when using new uniqueIds. because declaration key of
            second method already points to the first method so we add declaration footprints also.
            The cost effect is that hit of every method will doubled. (one for 'loc' and one for 'decl').
         */
        if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
            const uniqueIdKey = relativePath + '@' + this.formatLoc(declStart);
            declUniqueId = (0, new_id_resolver_1.resolveNewId)(uniqueIdKey, fullpath, relativePath, this.getCoverageObject(), this.logger);
        }
        if (!declUniqueId) {
            return;
        }
        const declMethodElement = this.getOrCreateMethodElement(declUniqueId, file);
        this.addOrUpdateElementHits(test, declUniqueId, declMethodElement, hits);
    }
    getSourceMapForModule(relPath) {
        if (!this.fileToSourceMapConsumer[relPath]) {
            this.fileToSourceMapConsumer[relPath] = source_maps_utils_1.SourceMapsUtils.readSourceMaps(relPath);
            this.logger.debug('Read source maps for file\':' + relPath + '\'');
        }
        const sourceMap = this.fileToSourceMapConsumer[relPath];
        return sourceMap;
    }
    addOrUpdateElementHits(testData, elementUniqueId, element, hits) {
        const HITS_INDEX = 1;
        const eid = elementUniqueId + '|' + testData.index;
        const index = this.eidToHitsIndex[eid];
        if (index != null) {
            const testIndexAndHits = element.hits[index];
            let elementHits = testIndexAndHits[HITS_INDEX];
            elementHits = elementHits + hits;
            testIndexAndHits[HITS_INDEX] = elementHits;
        }
        else {
            const testIndexAndHits = new Array();
            testIndexAndHits.push(testData.index);
            testIndexAndHits.push(hits);
            const length = element.hits.push(testIndexAndHits);
            this.eidToHitsIndex[eid] = length - 1;
        }
    }
    getOrCreateTestData(footprintsElement, result) {
        if (!this.testNameToTestData[footprintsElement.testName]) {
            const test = {
                executionId: footprintsElement.executionId,
                localTime: footprintsElement.localTime,
                testName: footprintsElement.testName,
                collectionInterval: footprintsElement.collectionInterval
            };
            result.tests.push(test);
            this.testNameToTestData[footprintsElement.testName] = {
                index: this.totalTests++,
                test: test
            };
        }
        return this.testNameToTestData[footprintsElement.testName];
    }
    getOrCreateMethodElement(uniqueId, file) {
        if (!this.uniqueIdToElement[uniqueId]) {
            const x = {
                hits: new Array(),
                uniqueId: uniqueId
            };
            this.uniqueIdToElement[uniqueId] = x;
            file.methods.push(x);
        }
        return this.uniqueIdToElement[uniqueId];
    }
    getOrCreateBranchElement(uniqueId, file) {
        if (!this.uniqueIdToElement[uniqueId]) {
            const x = {
                hits: new Array(),
                uniqueId: uniqueId
            };
            this.uniqueIdToElement[uniqueId] = x;
            file.branches.push(x);
        }
        return this.uniqueIdToElement[uniqueId];
    }
    getOrCreateFootprintsAppFile(fileName, app) {
        if (this.fileNameToAppFile[fileName]) {
            return this.fileNameToAppFile[fileName];
        }
        //File doesn't exist in request.
        const file = {
            methods: new Array(),
            branches: new Array(),
            lines: new Array(),
            path: fileName
        };
        app.files.push(file);
        this.fileNameToAppFile[fileName] = file;
        return file;
    }
    createFootprintsAppData(extraData) {
        //Supporting only one app right now
        const app = {
            appName: this.cfg.appName.value,
            branchName: this.cfg.branch.value,
            buildName: this.cfg.build.value,
            buildSessionId: this.cfg.buildSessionId.value,
            moduleName: null,
            files: new Array()
        };
        extraData.apps.push(app);
        return extraData;
    }
    readSourceMapData(sourceMaps, start, coveragePath, fullPath) {
        if (sourceMaps) {
            const startPositionArr = [start.line, start.column];
            const handler = new source_map_handler_1.SourceMapHandler(sourceMaps, fullPath, startPositionArr, [], this.cfg.projectRoot.value, this.logger);
            handler.resolvePaths();
            if (!handler.shouldSkipped) {
                const result = {
                    relativePath: handler.relativePath,
                    originalStart: handler.start,
                    absolutePath: handler.absolutePath
                };
                return result;
            }
        }
        return null;
    }
    adjustPathSlashes(filePath) {
        filePath = (filePath || '').replace(/\\/g, '/');
        return filePath;
    }
    getIstanbulCounters() {
        if (this.globalCoverageContainer)
            return this.globalCoverageContainer;
        const re = /^\$\$cov_[0-9]+\$\$$/;
        const keys = Object.keys(global);
        for (let i = 0; i < keys.length; i++) {
            const k = keys[i];
            if ((re.exec(k)) !== null || GLOBAL_ISTANBUL_CONTAINER_NAMES.indexOf(k) >= 0) {
                this.globalCoverageContainer = global[k];
                return this.globalCoverageContainer;
            }
        }
        return null;
    }
    getCoverageObject() {
        return this.nycFinalReportData || this.getIstanbulCounters();
    }
    getRelativeModulePath(module) {
        // Sometimes istanbul holds the 'path' under 'data' object. see coverage final attached in 'https://sealights.atlassian.net/browse/SLDEV-4421'
        if (typeof (module.path) !== 'string' && module.data.path && typeof (module.data.path) === 'string') {
            this.logger.debug(`Not extracting relative path for '${module.data.path}'. Using the same path as is.`);
            return module.data.path;
        }
        if (!this.relativeModulePaths[module.path]) {
            const absolutePath = this.adjustPathSlashes(module.path);
            let relativePath = absolutePath.replace(this.resolveProjectRoot(), '');
            if (relativePath.indexOf('/') === 0) {
                relativePath = relativePath.substring(1);
            }
            this.relativeModulePaths[module.path] = relativePath;
        }
        return this.relativeModulePaths[module.path];
    }
    formatLoc(loc) {
        return loc.line + ',' + loc.column;
    }
    getCurrentFootprints() {
        const diff = this.getIstanbulCountersDiff(this.getIstanbulCounters());
        return diff;
    }
    getIstanbulCountersDiff(currentCounters) {
        if (!currentCounters) {
            this.logger.error('Couldn\'t get istanbul counters, return empty diff.');
            return {};
        }
        const diff = {};
        let diffModule = null;
        function createModuleForDiff(istanbulModule) {
            diffModule = diff[istanbulModule] = { b: {}, f: {}, s: {} };
            return diffModule;
        }
        const prevCounters = this.previousIstanbulCounters;
        for (const istanbulModule in currentCounters) {
            diffModule = null;
            if (!prevCounters[istanbulModule]) {
                prevCounters[istanbulModule] = { b: {}, f: {}, s: {} };
            }
            const prevModule = prevCounters[istanbulModule];
            for (const funcId in currentCounters[istanbulModule].f) {
                if (prevModule.f[funcId] === undefined) {
                    prevModule.f[funcId] = 0;
                }
                const currentFunctionHits = currentCounters[istanbulModule].f[funcId];
                const prevFunctionHits = prevModule.f[funcId] || 0;
                if (currentFunctionHits > prevFunctionHits) {
                    //this is a diff
                    diffModule = diffModule || createModuleForDiff(istanbulModule);
                    diffModule.f[funcId] = (currentFunctionHits - prevFunctionHits);
                    prevModule.f[funcId] = currentFunctionHits;
                }
            }
            for (const branchId in currentCounters[istanbulModule].b) {
                const currentBranchesHits = currentCounters[istanbulModule].b[branchId];
                const prevBranchHits = prevModule.b[branchId];
                if (prevBranchHits) {
                    for (let i = 0, j = currentBranchesHits.length; i < j; i++) {
                        const currentHits = currentBranchesHits[i], previousHits = prevBranchHits[i] || 0;
                        if (currentHits > previousHits) {
                            //this is a diff
                            diffModule = diffModule || createModuleForDiff(istanbulModule);
                            diffModule.b[branchId] = diffModule.b[branchId] || this.newNumberArray(currentBranchesHits.length);
                            diffModule.b[branchId][i] = currentHits - previousHits;
                            prevBranchHits[i] = currentHits;
                        }
                    }
                }
                else {
                    prevModule.b[branchId] = currentBranchesHits.slice();
                    let branchSetHasHits = false;
                    for (let i = 0, j = currentBranchesHits.length; i < j && !branchSetHasHits; i++) {
                        if (currentBranchesHits[i])
                            branchSetHasHits = true;
                    }
                    if (branchSetHasHits) {
                        diffModule = diffModule || createModuleForDiff(istanbulModule);
                        diffModule.b[branchId] = currentBranchesHits.slice();
                    }
                }
            }
        }
        this.logDiff(diff);
        return diff;
    }
    logDiff(diff) {
        if (!this.logger.isDebugEnabled()) {
            return;
        }
        const modules = Object.keys(diff);
        const formatter = new messages_formatter_1.MessagesFormatter();
        modules.forEach((module) => {
            const methods = diff[module].f || {};
            const branches = diff[module].b || {};
            const methodsSize = Object.keys(methods).length;
            const branchesSize = Object.keys(branches).length;
            formatter.addContent(`${module}: ${methodsSize} methods and ${branchesSize} branches`);
        });
        this.logger.debug(`Found coverage data for ${modules.length} files:\n ${formatter.content}`);
    }
    newNumberArray(length) {
        const arr = [];
        for (let i = 0; i < length; i++)
            arr.push(0);
        return arr;
    }
    loadOriginalModules() {
        const loader = new original_module_loader_1.OriginalModuleLoader(this.getCoverageObject(), this.logger);
        loader.load();
    }
    resolveProjectRoot() {
        return (this.cfg.projectRoot.value || process.cwd()).replace(/\\/g, '/');
    }
}
exports.IstanbulToFootprints = IstanbulToFootprints;
//# sourceMappingURL=istanbul-to-footprints.js.map