"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FootprintsProcess = void 0;
const queue_1 = require("../queue");
const collection_interval_1 = require("./collection-interval");
const system_date_1 = require("../system-date");
const state_tracker_1 = require("../state-tracker");
const sl_env_vars_1 = require("../constants/sl-env-vars");
const cockpit_notifier_1 = require("../agent-events/cockpit-notifier");
const agent_events_contracts_1 = require("../agent-events/agent-events-contracts");
class FootprintsProcess {
    constructor(
    /**
     * Initial configuration
     */
    cfg, 
    /**
     * Background thread that tells the footprints service to send footprints from the queue to the server
     */
    sendToServerWatchdog, 
    /**
     * Foreground thread that prevents the process from shutting down, and kept alive while there are items to submit to the server or items are currently being submitted
     */
    keepaliveWatchdog, 
    /**
     * Proxy to the server for footprints submission
     */
    footprintsServiceProxy, 
    /**
     * Environments service, used to get environmental data for submission (process id, machine data, etc.)
     */
    environmentDataService, agentInstanceData, istanbulToFootprints, stateTracker, logger) {
        this.cfg = cfg;
        this.sendToServerWatchdog = sendToServerWatchdog;
        this.keepaliveWatchdog = keepaliveWatchdog;
        this.footprintsServiceProxy = footprintsServiceProxy;
        this.environmentDataService = environmentDataService;
        this.agentInstanceData = agentInstanceData;
        this.istanbulToFootprints = istanbulToFootprints;
        this.stateTracker = stateTracker;
        this.logger = logger;
        this.isSubmittingFootprints = false;
        this.sequence = 0;
        this.isRunning = false;
        this.stopCallbacks = [];
        if (!cfg)
            throw new Error('cfg was not specified');
        if (!sendToServerWatchdog)
            throw new Error('sendToServerWatchdog was not specified');
        if (!keepaliveWatchdog)
            throw new Error('keepaliveWatchdog was not specified');
        if (!footprintsServiceProxy)
            throw new Error('footprintsServiceProxy was not specified');
        if (!environmentDataService)
            throw new Error('environmentDataService was not specified');
        if (!agentInstanceData)
            throw new Error('agentInstanceData was not specified');
        if (!istanbulToFootprints)
            throw new Error('istanbulToFootprints was not specified');
        if (!logger) {
            throw new Error('logger was not specified');
        }
        this.collectionInterval = new collection_interval_1.CollectionInterval(cfg.interval.value);
        this.footprintsQueue = new queue_1.Queue();
        sendToServerWatchdog.on('alarm', () => {
            this.logger.debug('Start submitting footprints, triggered by send to server watchdog.');
            this.submitQueuedFootprints();
        });
        this.footprintsQueue.on('full', () => {
            this.logger.debug('Start submitting footprints, queue is full.');
            this.submitQueuedFootprints();
        });
        keepaliveWatchdog.on('alarm', () => {
            //console.log('keepaliveWatchdog. isSubmittingFootprints:' + this.isSubmittingFootprints + ', queue size: ' + this.footprintsQueue.getQueueSize());
            if (!this.isSubmittingFootprints && this.footprintsQueue.getQueueSize() == 0) {
                keepaliveWatchdog.stop();
            }
        });
    }
    enqueueCurrentFootprints(executionId, testName) {
        this.collectionInterval.next();
        const footprints = this.istanbulToFootprints.getCurrentFootprints();
        const hitModules = Object.keys(footprints);
        if (!hitModules || hitModules.length == 0) { //If no modules were hit at all, don't enqueue anything
            this.logger.info('No files were hit, not enqueuing footprints.');
            return;
        }
        this.logger.info(`Enqueuing footprints for ${hitModules.length} files`);
        this.footprintsQueue.enqueue({
            executionId: executionId,
            testName: testName,
            footprints: footprints,
            localTime: (0, system_date_1.getSystemDateValueOf)(),
            collectionInterval: this.collectionInterval.toJson(),
        });
        if (this.isRunning && this.cfg.sendFootprints.value && this.cfg.enabled.value) {
            this.ensureKeepaliveThreadRunning();
            this.sendToServerWatchdog.start();
        }
    }
    ensureKeepaliveThreadRunning() {
        this.keepaliveWatchdog.start();
    }
    updateConfig(updatedCfg) {
        if (updatedCfg.sendFootprints.value === false || updatedCfg.enabled.value === false) {
            cockpit_notifier_1.CockpitNotifier.sendEvent(agent_events_contracts_1.AgentEventCode.AGENT_MUTED);
            this.footprintsQueue.clear();
            this.stop(() => { });
        }
        this.cfg = updatedCfg;
        this.sendToServerWatchdog.setInterval(this.cfg.interval.value);
    }
    createFootprintsPacket(items) {
        const packet = this.istanbulToFootprints.createFootprintsPackageFromQueue(items, {
            customerId: this.cfg.customerId.value,
            environment: this.environmentDataService.getEnvDataForSubmission(),
            configurationData: this.cfg.toJsonObject(),
            meta: {
                sequence: ++this.sequence,
                generated: (0, system_date_1.getSystemDateValueOf)(),
                agentId: this.agentInstanceData.agentId,
            },
            tests: [],
            apps: []
        });
        return packet;
    }
    submitQueuedFootprints() {
        if (!this.isRunning) {
            this.logger.info('Agent is not running, not sending footprints');
            return;
        }
        if (this.cfg.sendFootprints.value === false) {
            this.logger.info('Not sending footprints since agent is configured to not send.');
            return; //Can't start without server or token
        }
        if (this.isSubmittingFootprints) {
            this.logger.info('Not sending footprints since its already submitting.');
            return;
        }
        if (this.footprintsQueue.getQueueSize() == 0) {
            this.logger.info('Not sending footprints since queue size is 0');
            return;
        }
        this.logger.info('About to send footprints. Queue size:' + this.footprintsQueue.getQueueSize());
        const items = this.footprintsQueue.dequeue(/*this.cfg.maxFootprintsChunkSize ||*/ 1000);
        const packet = this.createFootprintsPacket(items);
        this.isSubmittingFootprints = true;
        this.footprintsServiceProxy.handleFootprints(packet, (err) => {
            this.isSubmittingFootprints = false;
            this.logger.info('Sent footprints. Queue size:' + this.footprintsQueue.getQueueSize() + ', err:' + err);
            if (err) {
                this.environmentDataService.setLastError(err.stack);
                this.footprintsQueue.requeue(items); //Requeue items for later submission
            }
            else if (this.footprintsQueue.getQueueSize() > 0) { //If there was an error, don't send now. Otherwise, if the queue still has items, send those now
                this.submitQueuedFootprints();
            }
            else
                this.fireQueueEmpty();
        });
    }
    fireQueueEmpty() {
        if (this.stopCallbacks.length > 0) {
            this.stopCallbacks.forEach((cb) => {
                try {
                    cb();
                }
                catch (err) {
                    this.environmentDataService.setLastError(err.stack);
                }
            });
        }
    }
    start() {
        if (this.isRunning)
            return; //Already started
        if (this.cfg.enabled.value == false)
            return; //Don't do anything if agent is completely disabled
        this.isRunning = true;
        this.sendToServerWatchdog.start();
        if (this.footprintsQueue.getQueueSize() > 0) {
            this.ensureKeepaliveThreadRunning();
        }
    }
    stop(callback) {
        try {
            this.sendToServerWatchdog.stop();
            if (this.cfg.enabled.value === false || this.cfg.sendFootprints.value === false) { //Footprints/Agent functionality is disabled. Return immediately
                this.isRunning = false;
                return callback();
            }
            this.logger.debug('Start submitting footprints, triggered by stop event.');
            this.submitQueuedFootprints(); //If footprints are being submitted, this has no effect. Otherwise, it will start submitting footprints if the queue is non-empty
            if (this.isSubmittingFootprints) {
                /*
                    Nothing to do right now, since footprints are being submitted
                    When the submission is over (successfully or not), if the queue is empty the next batch of footprints will be sent.
                    If after submission the queue is cleared, this callback will be called
                */
                this.stopCallbacks.push(() => {
                    this.isRunning = false;
                    this.keepaliveWatchdog.stop();
                    return callback();
                });
            }
            else {
                /*
                    Queue must be empty, and nothing is sent. submitQueuedFootprints() would have started sending footprints if the queue was non-empty
                */
                this.isRunning = false;
                this.keepaliveWatchdog.stop();
                return callback();
            }
        }
        catch (err) {
            this.logger.error(err);
            return callback();
        }
    }
    handleTestIdChanged(newTestIdentifier, previousTestIdentifier) {
        if (previousTestIdentifier != null) {
            if (!this.stateTracker.hasMappingAtServer() && this.stateTracker.isAnonymousColor(previousTestIdentifier)) {
                this.logger.info('Test identifier changed, couldn\'t find active execution for anonymous footprints. Skip enqueuing footprints process.');
                return;
            }
            this.logger.debug('Test identifier changed, start enqueuing footprints process.');
            const prevTestIdentifierParts = state_tracker_1.StateTracker.splitTestIdToExecutionAndTestName(previousTestIdentifier);
            this.enqueueCurrentFootprints(prevTestIdentifierParts.executionId, prevTestIdentifierParts.testName);
        }
        else {
            this.logger.info('Test identifier changed, previous identifier wasn\'t set, meaning that we didn\'t have active test. Skip enqueuing footprints process.');
        }
    }
    flushCurrentFootprints() {
        const currentTestIdentifier = this.stateTracker.getCurrentTestIdentifier();
        const testIdentifierParts = state_tracker_1.StateTracker.splitTestIdToExecutionAndTestName(currentTestIdentifier);
        if (sl_env_vars_1.SlEnvVars.inProductionListenerMode()) {
            this.logger.debug('Enqueue footprints for production listener');
            this.enqueueCurrentFootprints(testIdentifierParts.executionId, testIdentifierParts.testName);
            return;
        }
        if (currentTestIdentifier != null) {
            if (!this.stateTracker.hasMappingAtServer() && this.stateTracker.isAnonymousColor(currentTestIdentifier)) {
                this.logger.info(`Enqueue footprints interval - couldn\'t find active execution for anonymous footprints. skip enqueue footprints process. currentTestIdentifier: '${currentTestIdentifier}'`);
                return;
            }
            this.logger.debug(`Enqueue footprints interval - start enqueuing process. currentTestIdentifier: '${currentTestIdentifier}'`);
            this.enqueueCurrentFootprints(testIdentifierParts.executionId, testIdentifierParts.testName);
        }
        else {
            this.logger.info('Enqueue footprints interval - no test identifier. skip enqueuing process. ');
        }
    }
    getQueueSize() {
        return this.footprintsQueue.getQueueSize();
    }
    loadSlMapping() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
}
exports.FootprintsProcess = FootprintsProcess;
//# sourceMappingURL=index.js.map