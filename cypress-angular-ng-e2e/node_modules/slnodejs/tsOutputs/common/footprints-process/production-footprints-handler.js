"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductionFootprintsHandler = void 0;
const fs = require("fs");
const os = require("os");
const sl_env_vars_1 = require("../constants/sl-env-vars");
const path = require("path");
const http_client_1 = require("../http/http-client");
const messages_formatter_1 = require("../messages-formatter");
const sl_routes_1 = require("../http/sl-routes");
const validation_utils_1 = require("../utils/validation-utils");
const system_date_1 = require("../system-date");
const FILE_NOT_FOUND_CODE = 'ENOENT';
class ProductionFootprintsHandler {
    constructor(cfg, agentInstanceData, logger) {
        this.validateConfig(cfg);
        this.agentConfig = cfg;
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(logger, 'logger');
        this.logger = logger;
        this.metaData = new MetaData(cfg.buildSessionId.value, cfg.labId.value);
        this.filename = this.createFilePath(cfg); //Todo: remove or make saving to file configurable
        this.collectionStartDate = (0, system_date_1.getSystemDateValueOf)();
        this.methodIdToHits = {};
        this.initHttpConfig(cfg);
        const httpClientMetadata = {
            agentId: agentInstanceData.agentId,
            buildSessionId: cfg.buildSessionId.value,
            agentType: agentInstanceData.agentType,
            agentTechnology: agentInstanceData.technology,
        };
        this.httpClient = new http_client_1.HttpClient(this.httpConfig, httpClientMetadata, logger);
        this.setupProdListenerModes();
    }
    setupProdListenerModes() {
        const prodListenerModes = sl_env_vars_1.SlEnvVars.getProductionListenerModes();
        if (prodListenerModes.length == 0 || (prodListenerModes.length == 1 && prodListenerModes[0] == 'true')) {
            //Defaults in case the production listener env var is not present or is set to 'true'
            this.sendToServer = true;
            this.saveToFile = false;
        }
        else {
            this.sendToServer = prodListenerModes.indexOf('server') > -1;
            this.saveToFile = prodListenerModes.indexOf('file') > -1;
        }
        this.logger.info('Production listener send to server: ' + this.sendToServer + ', save to file: ' + this.saveToFile);
    }
    initHttpConfig(cfg) {
        const config = {
            token: cfg.token.value,
            server: cfg.server.value,
            proxy: cfg.proxy.value,
            compressRequests: cfg.gzip.hasValue ? cfg.gzip.value : true,
            buildSessionId: cfg.buildSessionId.value,
        };
        this.httpConfig = config;
    }
    handleFootprints(footprintsPacket, callback) {
        if (!footprintsPacket) {
            this.logger.info('Handle footprints - got null or empty packet. Skip saving.');
            callback(null);
            return;
        }
        if (!footprintsPacket || !footprintsPacket.apps || !footprintsPacket.apps[0] || !footprintsPacket.apps[0].files) {
            this.logger.info('Handle footprints - no footprints data. Skip saving.');
            callback(null);
            return;
        }
        this.saveAndSendMethodsHits(footprintsPacket)
            .then(() => callback(null))
            .catch((err) => callback(err));
    }
    saveAndSendMethodsHits(packetToSend) {
        return __awaiter(this, void 0, void 0, function* () {
            const hitFiles = this.getHitFiles(packetToSend);
            this.logger.debug(`Submitting production data, files: ${hitFiles}, toServer: ${this.sendToServer}, toFile: ${this.saveToFile} (${this.filename})`);
            if (this.sendToServer) {
                yield this.convertAndSubmitToServer(packetToSend);
            }
            if (this.saveToFile) {
                this.methodIdToHits = {};
                this.addHitsFromFootprints(packetToSend.apps[0].files);
                yield this.addHitsFromFile();
                yield this.writeDataToFile();
            }
        });
    }
    getHitFiles(packetToSend) {
        if (!this.logger.isDebugEnabled()) {
            return;
        }
        const formatter = new messages_formatter_1.MessagesFormatter();
        if (packetToSend && packetToSend.apps && packetToSend.apps[0] && packetToSend.apps[0].files) {
            packetToSend.apps[0].files.forEach((file) => {
                formatter.addContent(file.path);
            });
        }
        return formatter.content;
    }
    convertFootprintsToProductionData(footprintsPacket) {
        const now = (0, system_date_1.getSystemDateValueOf)();
        const productionDataPacket = {
            meta: {
                appName: this.agentConfig.appName.value,
                branchName: this.agentConfig.branch.value,
                buildName: this.agentConfig.build.value,
                bsid: this.agentConfig.buildSessionId.value,
                createdAt: this.collectionStartDate,
                lastModified: now,
                customerId: this.agentConfig.customerId.value,
                hostName: os.hostname(),
                pid: process.pid,
                labId: this.agentConfig.labId.value || 'production'
            },
            methodsHits: {}
        };
        if (footprintsPacket && footprintsPacket.apps && footprintsPacket.apps[0] && footprintsPacket.apps[0].files) {
            footprintsPacket.apps[0].files.forEach((file) => {
                if (!file.methods)
                    return;
                file.methods.forEach(method => {
                    let totalHits = 0;
                    if (!method.hits)
                        return;
                    method.hits.forEach(testIdxAndHits => {
                        totalHits += testIdxAndHits[1];
                    });
                    productionDataPacket.methodsHits[method.uniqueId] = totalHits;
                });
            });
        }
        this.collectionStartDate = now;
        return productionDataPacket;
    }
    convertAndSubmitToServer(footprintsPacket) {
        const productionDataPacket = this.convertFootprintsToProductionData(footprintsPacket);
        return new Promise((resolve, reject) => {
            const url = sl_routes_1.SLRoutes.productionV1(this.agentConfig.buildSessionId.value);
            this.httpClient.post(productionDataPacket, url, (err) => {
                err ? reject(err) : resolve();
            });
        });
    }
    /*
        In production listener we are in anonymous mode, and all hits will refer to single anonymous test.
        So we can there will be single array in "hits" array.
        In this inner array firs element will be always '0'(the index of test in array which contains only one - the anonymous),
        and the second element is the hits number.
     */
    addHitsFromFootprints(files) {
        files.forEach((file) => {
            file.methods.forEach((method) => {
                this.methodIdToHits[method.uniqueId] = method.hits[0][1];
            });
        });
    }
    tryParseFileContent(fileContent) {
        try {
            const hitsData = JSON.parse(fileContent).methodsHits;
            this.logger.debug(`Previous hit data parsed successfully, '${Object.keys(hitsData).length} items loaded`);
            return hitsData;
        }
        catch (err) {
            this.logger.error(`Error while parsing hits file content. ${err}`);
            return null;
        }
    }
    validateConfig(config) {
        if (!config) {
            throw new Error('cfg cannot be null or undefined');
        }
        if (!config.labId.hasValue) {
            throw new Error('Configuration must contains labId');
        }
        if (!config.buildSessionId.hasValue) {
            throw new Error('Configuration must contains buildSessionId');
        }
    }
    addHitsFromFile() {
        return new Promise((resolve, reject) => {
            fs.readFile(this.filename, (err, data) => {
                if (err && err.code != FILE_NOT_FOUND_CODE) {
                    this.logger.error(`Error while trying to read previous hits data. ${err}`);
                }
                if (data != null) {
                    const hits = this.tryParseFileContent(data.toString());
                    if (hits != null) {
                        this.updateHits(hits);
                    }
                    else {
                        this.logger.error('Could not load previous hits from file');
                    }
                }
                resolve();
            });
        });
    }
    writeDataToFile() {
        return new Promise((resolve, reject) => {
            const data = JSON.stringify(this.toJSonObject());
            fs.writeFile(this.filename, data, (err) => {
                if (err) {
                    this.logger.error(`Error while trying to write methods hits into file. ${err}`);
                    reject(err);
                }
                resolve();
            });
        });
    }
    createFilePath(config) {
        const filename = this.combineArgsWithDash(config.buildSessionId.value, config.labId.value, process.pid) + '.json';
        const fileStorage = sl_env_vars_1.SlEnvVars.getFileStorage();
        if (fileStorage) {
            return path.join(fileStorage, filename);
        }
        return filename;
    }
    combineArgsWithDash(...args) {
        return args.join('-');
    }
    updateHits(methodsHitFromFile) {
        Object.keys(methodsHitFromFile).forEach(methodId => {
            if (this.methodIdToHits[methodId]) {
                this.methodIdToHits[methodId] += parseInt(methodsHitFromFile[methodId]);
            }
            else {
                this.methodIdToHits[methodId] = parseInt(methodsHitFromFile[methodId]);
            }
        });
    }
    toJSonObject() {
        return {
            meta: this.metaData.toJsonObject(),
            methodsHits: this.methodIdToHits
        };
    }
}
exports.ProductionFootprintsHandler = ProductionFootprintsHandler;
class MetaData {
    constructor(buildSessionId, labId) {
        this.buildSessionId = buildSessionId;
        this.labId = labId;
        this.createdAt = (0, system_date_1.getSystemDate)().toLocaleString();
        this.pid = process.pid;
    }
    toJsonObject() {
        this.lastModifiedAt = (0, system_date_1.getSystemDate)().toLocaleString();
        const json = {};
        Object.keys(this).forEach(key => {
            json[key] = this[key];
        });
        return json;
    }
}
//# sourceMappingURL=production-footprints-handler.js.map