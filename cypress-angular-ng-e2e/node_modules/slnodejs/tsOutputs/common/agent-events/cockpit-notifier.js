"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CockpitNotifier = void 0;
const agent_events_controller_1 = require("./agent-events-controller");
const dry_run_agent_events_controller_1 = require("./dry-run-agent-events-controller");
const no_op_agent_events_controller_1 = require("./no-op-agent-events-controller");
/**
 * A class with static methods for sending notification to cockpit.
 * Using this class enables to avoid passing instance of AgentEventsController for each class
 */
class CockpitNotifier {
    static notifyStart(agentConfig, agentInstanceData, logger, getSystemOffset, packageJsonFile, backendProxy, tool, tags, colorContextManager) {
        return __awaiter(this, void 0, void 0, function* () {
            CockpitNotifier.controller = new agent_events_controller_1.AgentEventsController(agentConfig, agentInstanceData, logger, getSystemOffset, backendProxy, tool, tags, colorContextManager);
            yield CockpitNotifier.controller.submitAgentStartedEvent(packageJsonFile);
        });
    }
    static notifyStartNoOp(agentConfig, agentInstanceData, logger, getSystemOffset, packageJsonFile, backendProxy, tool, tags) {
        return __awaiter(this, void 0, void 0, function* () {
            CockpitNotifier.controller = new no_op_agent_events_controller_1.NoOpAgentEventsController(agentConfig, agentInstanceData, logger, getSystemOffset, backendProxy, tool, tags);
        });
    }
    static notifyShutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            CockpitNotifier.verifyControllerInitialized();
            yield CockpitNotifier.controller.submitAgentShutdownEvent();
        });
    }
    static sendGenericMessage(message) {
        CockpitNotifier.verifyControllerInitialized();
        CockpitNotifier.controller.submitGenericMessage(message);
    }
    static sendWarning(message) {
        CockpitNotifier.verifyControllerInitialized();
        CockpitNotifier.controller.submitWarning(message);
    }
    static sendError(message) {
        CockpitNotifier.verifyControllerInitialized();
        CockpitNotifier.controller.submitError(message);
    }
    static sendErrorsBatch(messages) {
        CockpitNotifier.verifyControllerInitialized();
        CockpitNotifier.controller.submitErrorsBatch(messages);
    }
    static sendEvent(code, data) {
        CockpitNotifier.verifyControllerInitialized();
        CockpitNotifier.controller.submitEvent(code, data);
    }
    static sendEventOnce(code) {
        CockpitNotifier.verifyControllerInitialized();
        CockpitNotifier.controller.submitEventOnce(code);
    }
    static verifyControllerInitialized() {
        if (!CockpitNotifier.controller && !CockpitNotifier.isDryRunMode) {
            throw new Error('\'Agent started\' event was not sent. Disabling!');
        }
    }
    // Added for tests
    static reset() {
        CockpitNotifier.controller = undefined;
        CockpitNotifier.controllerNullLogged = false;
        CockpitNotifier.isDryRunMode = false;
    }
    static setDryRunMode(logger, proxy) {
        CockpitNotifier.isDryRunMode = true;
        CockpitNotifier.controller = new dry_run_agent_events_controller_1.DryRunAgentEventsController(logger, proxy);
    }
}
exports.CockpitNotifier = CockpitNotifier;
CockpitNotifier.controllerNullLogged = false;
//# sourceMappingURL=cockpit-notifier.js.map