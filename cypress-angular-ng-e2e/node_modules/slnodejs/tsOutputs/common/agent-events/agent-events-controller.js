"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentEventsController = void 0;
const agent_events_contracts_1 = require("./agent-events-contracts");
const agent_instance_info_builder_1 = require("./agent-instance-info-builder");
const machine_info_builder_1 = require("./machine-info-builder");
const nodejs_env_info_builder_1 = require("./nodejs-env-info-builder");
const agent_start_info_builder_1 = require("./agent-start-info-builder");
const ci_info_builder_1 = require("./ci-info-builder");
const backend_proxy_1 = require("../http/backend-proxy");
const validation_utils_1 = require("../utils/validation-utils");
const watchdog_1 = require("../watchdog");
const system_date_1 = require("../system-date");
const browser_info_builder_1 = require("./browser-info-builder");
const data_cleansing_utils_1 = require("../utils/data-cleansing-utils");
class AgentEventsController {
    constructor(agentConfig, agentInstanceData, logger, getSystemOffset, backendProxy, tool, tags, colorContextManager) {
        this.getSystemOffset = getSystemOffset;
        this.colorContextManager = colorContextManager;
        this.active = false;
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(agentConfig, 'agentConfig');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(agentInstanceData, 'agentInstanceData');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(logger, 'logger');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(getSystemOffset, 'getSystemOffset');
        this._agentConfig = agentConfig;
        this._logger = logger;
        this._agentInstanceData = agentInstanceData;
        this.shutDownRetries = 0;
        this.backendProxy = backendProxy || this.createBackendProxy();
        this.addTags(tags);
        this.addTool(tool);
        this.initWatchdog();
        this.submittedEventsMap = new Map();
    }
    submitAgentStartedEvent(packageJsonFile) {
        return __awaiter(this, void 0, void 0, function* () {
            this.active = true;
            this.startRequestStatus = StartRequestStatus.PENDING;
            const event = this.buildAgentStartEvent(packageJsonFile || {});
            const result = yield this.submitAgentEventRequest(event);
            this.startRequestStatus = result ? StartRequestStatus.SUCCEED : StartRequestStatus.FAILED;
            if (this.startRequestStatus !== StartRequestStatus.SUCCEED) {
                this._logger.info('Agent start event failed to submit - ping events will not be sent');
            }
            else {
                this._pingWatchdog.start();
            }
        });
    }
    addColorToEvent(event) {
        var _a;
        const colorName = (_a = this.colorContextManager) === null || _a === void 0 ? void 0 : _a.getTestName();
        return Array.isArray(event) ? event.forEach(eventObject => eventObject.colorName = colorName) : event.colorName = colorName;
    }
    submitAgentEventRequest(event) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.active) {
                this._logger.debug('Agent not active - not submitting event');
                return false;
            }
            const request = {
                agentId: this._agentInstanceData.agentId,
                events: Array.isArray(event) ? event : [event],
                appName: this._agentConfig.appName.value,
                buildSessionId: this._agentConfig.buildSessionId.value
            };
            try {
                yield this.backendProxy.submitAgentEvent(request);
                this._logger.info(`Submitted '${request.events.length}' events successfully`);
                return true;
            }
            catch (e) {
                this._logger.warn(`Failed to submit '${request.events.length}' events. Error ${e}`);
                return false;
            }
        });
    }
    buildAgentStartEvent(packageJsonFile) {
        const agentInstanceInfoBuilder = new agent_instance_info_builder_1.AgentInstanceInfoBuilder(this);
        const machineInfoBuilder = new machine_info_builder_1.MachineInfoBuilder();
        const dependencies = Object.assign(Object.assign({}, packageJsonFile.dependencies), packageJsonFile.devDependencies);
        const nodejsEnvInfoBuilder = this.agentInstanceData.technology === agent_events_contracts_1.AgentTechnologies.BROWSER ? new browser_info_builder_1.BrowserInfoBuilder() : new nodejs_env_info_builder_1.NodejsEnvInfoBuilder(this.agentInstanceData, dependencies);
        const ciInfoBuilder = new ci_info_builder_1.CiInfoBuilder();
        const agentStartInfoBuilder = new agent_start_info_builder_1.AgentStartInfoBuilder(agentInstanceInfoBuilder, machineInfoBuilder, nodejsEnvInfoBuilder, ciInfoBuilder, this._agentConfig);
        const agentStartInfo = agentStartInfoBuilder.build();
        return this.buildEvent(agent_events_contracts_1.AgentEventCode.AGENT_STARTED, agentStartInfo);
    }
    buildAgentShutdownEvent() {
        return this.buildEvent(agent_events_contracts_1.AgentEventCode.AGENT_SHUTDOWN);
    }
    submitAgentShutdownEvent() {
        return __awaiter(this, void 0, void 0, function* () {
            this.shutDownRetries++;
            if (this.startRequestStatus == StartRequestStatus.FAILED) {
                this._logger.debug('Agent start not submitted - not sending shut down events');
                return;
            }
            if (this.shutDownRetries > AgentEventsController.MAX_SHUTDOWN_RETRIES) {
                this._logger.debug('Stop trying to send shutdown event after 60 seconds ');
                return;
            }
            this._pingWatchdog.stop();
            const event = this.buildAgentShutdownEvent();
            if (this.startRequestStatus == StartRequestStatus.PENDING) {
                setTimeout(() => this.submitAgentShutdownEvent.call(this), 1000);
            }
            else {
                const result = yield this.submitAgentEventRequest(event);
                this.active = false;
                return result;
            }
        });
    }
    // Not happens if start event failed to submit
    submitPingEvent() {
        return this.submitEvent(agent_events_contracts_1.AgentEventCode.AGENT_PING, { agentInfo: { labId: this.agentConfig.labId.value } });
    }
    submitEvent(code, data) {
        this.submittedEventsMap.set(code, true);
        this._logger.debug(`About to send event with code '${code}', current time: ${(0, system_date_1.getSystemDateValueOf)()}`);
        const event = this.buildEvent(code, data);
        this.submitAgentEventRequest(event).then(() => this._logger.debug(`Event with code '${code}' submitted successfully`));
    }
    submitEventOnce(code) {
        if (!this.submittedEventsMap.get(code)) {
            this.submitEvent(code);
        }
    }
    // Not happens if start event failed to submit
    submitGenericMessage(message) {
        this.sendMessage(message, agent_events_contracts_1.AgentEventCode.GENERIC_MESSAGE);
    }
    submitWarning(message) {
        this.sendMessage(message, agent_events_contracts_1.AgentEventCode.WARN);
    }
    submitError(message) {
        this.sendMessage(message, agent_events_contracts_1.AgentEventCode.GENERIC_ERROR);
    }
    submitErrorsBatch(messages) {
        if (!messages || !messages.length) {
            return;
        }
        const events = messages.map(msg => this.buildEvent(agent_events_contracts_1.AgentEventCode.GENERIC_ERROR, msg));
        this.submitAgentEventRequest(events).then(() => this.logger.debug(`'${events.length}' events were submitted successfully`));
    }
    sendMessage(message, code) {
        this.logger.debug(`About to send message '${message}' with code '${code}', current time: ${(0, system_date_1.getSystemDateValueOf)()}`);
        const messageEvent = this.buildEvent(code, message);
        this.submitAgentEventRequest(messageEvent).then(() => this.logger.debug('Message submitted successfully'));
    }
    submitConfigChanged() {
        const messageEvent = this.buildEvent(agent_events_contracts_1.AgentEventCode.AGENT_CONFIG_CHANGED, this._agentConfig.toJsonObject());
        this.submitAgentEventRequest(messageEvent).then(() => this.logger.debug('Config changed event submitted successfully'));
    }
    get watchdog() {
        return this._pingWatchdog;
    }
    get agentConfig() {
        return this._agentConfig;
    }
    get logger() {
        return this._logger;
    }
    get tools() {
        return this._tools;
    }
    resolveTags() {
        return this._tags || [];
    }
    addTags(tags) {
        if (!tags)
            return;
        this._tags = [...(this._tags || []), ...(tags || [])];
    }
    addTool(tollInfo) {
        if (!tollInfo)
            return;
        this._tools = this._tools || [];
        this._tools.push(tollInfo);
    }
    createBackendProxy() {
        const httpConfig = {
            token: this._agentConfig.token.value,
            proxy: this._agentConfig.proxy.value,
            server: this._agentConfig.server.value,
            compressRequests: this._agentConfig.gzip.value,
            buildSessionId: this._agentConfig.buildSessionId.value,
            labId: this._agentConfig.labId.value,
            appName: this._agentConfig.appName.value,
            buildName: this._agentConfig.build.value,
            branchName: this._agentConfig.branch.value
        };
        return new backend_proxy_1.BackendProxy(this._agentInstanceData, httpConfig, this._logger);
    }
    initWatchdog() {
        const watchdogOptions = { interval: AgentEventsController.PING_INTERVAL, name: 'AgentEventsWatchdog', autoReset: true, unref: true };
        const timers = this.getTimers();
        this._pingWatchdog = new watchdog_1.Watchdog(watchdogOptions, timers);
        this._pingWatchdog.on('alarm', this.submitPingEvent.bind(this));
    }
    getTimers() {
        if (this._agentInstanceData.technology === agent_events_contracts_1.AgentTechnologies.BROWSER) {
            return { setTimeout: setTimeout.bind(window), clearTimeout: clearTimeout.bind(window) };
        }
        else {
            return { setTimeout: setTimeout, clearTimeout: clearTimeout };
        }
    }
    buildEvent(type, data) {
        var _a;
        const cleanData = (this._agentConfig.removeSensitiveData.value ? data_cleansing_utils_1.DataCleansingUtils.removeSensitiveData(data) : data);
        return {
            type: type,
            utcTimestamp_ms: (0, system_date_1.getSystemDateValueOf)(),
            difftime: this.getSystemOffset(),
            data: cleanData,
            colorName: (_a = this.colorContextManager) === null || _a === void 0 ? void 0 : _a.getTestName()
        };
    }
    get agentInstanceData() {
        return this._agentInstanceData;
    }
}
exports.AgentEventsController = AgentEventsController;
AgentEventsController.PING_INTERVAL = 2 * 60 * 1000; // 2 Minutes.
AgentEventsController.MAX_SHUTDOWN_RETRIES = 60;
var StartRequestStatus;
(function (StartRequestStatus) {
    StartRequestStatus["FAILED"] = "failed";
    StartRequestStatus["SUCCEED"] = "succeed";
    StartRequestStatus["PENDING"] = "pending";
})(StartRequestStatus || (StartRequestStatus = {}));
//# sourceMappingURL=agent-events-controller.js.map