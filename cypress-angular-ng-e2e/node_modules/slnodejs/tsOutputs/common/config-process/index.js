"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigProcess = void 0;
const events = require("events");
const config_system_1 = require("./config-system");
const assign = require("object-assign");
const jwtDecode = require("jwt-decode");
class ConfigProcess extends events.EventEmitter {
    constructor(cfg, watchdog, backendProxy, logger) {
        super();
        this.cfg = cfg;
        this.watchdog = watchdog;
        this.backendProxy = backendProxy;
        this.logger = logger;
        this.isRunning = false;
        if (!cfg)
            throw new Error('cfg is required');
        this.initialCfg = assign({}, cfg.toJsonObject());
        if (!watchdog)
            throw new Error('watchdog is required');
        if (!backendProxy)
            throw new Error('backendProxy is required');
        if (!logger) {
            throw new Error('logger is required');
        }
        watchdog.on('alarm', () => {
            watchdog.stop();
            this.reloadConfigFromServer();
        });
        this.initCfg();
    }
    reloadConfigFromServer(callback) {
        this.backendProxy.getRemoteConfig({
            appName: this.cfg.appName.value,
            branch: this.cfg.branch.value,
            build: this.cfg.build.value,
            labId: this.cfg.labId.value,
            testStage: this.cfg.testStage.value
        }, (err, updatedCfg) => {
            if (!err && updatedCfg) {
                this.mergeConfigFromServerAndFireEvent(updatedCfg);
            }
            this.watchdog.start();
            if (callback) {
                callback(err);
            }
        });
    }
    mergeConfigFromServerAndFireEvent(updatedCfgObject) {
        let configChanged = false;
        //Load values before any server overrides
        this.cfg.loadConfiguration(new config_system_1.JsonObjectConfigurationProvider(this.initialCfg));
        for (const key in updatedCfgObject) {
            if (this.cfg[key] && this.cfg[key].isConfigKey && this.cfg[key].value != updatedCfgObject[key]) {
                configChanged = true;
                break;
            }
        }
        if (configChanged) {
            //Then override with server sent config
            this.cfg.loadConfiguration(new config_system_1.JsonObjectConfigurationProvider(updatedCfgObject));
            this.emit('configuration_changed', this.cfg);
        }
    }
    getConfiguration() {
        return this.cfg;
    }
    initCfg() {
        if (this.cfg.token.hasValue) {
            try {
                const tokenData = jwtDecode(this.cfg.token.value);
                if (!tokenData['x-sl-server']) {
                    throw new Error('Token Is Invalid. Doesn\'t Contain Server');
                }
                if (!this.cfg.server.hasValue)
                    this.cfg.server.value = tokenData['x-sl-server'];
                if (!tokenData['subject']) {
                    throw new Error('Token Is Invalid. Doesn\'t Contain Subject');
                }
                let customerId = tokenData['subject'];
                const subjectParts = tokenData['subject'].split('@');
                customerId = subjectParts[0];
                this.cfg.customerId.value = this.cfg.customerId.value || customerId;
            }
            catch (err) {
                this.cfg.enabled.value = false;
                this.logger.error(`Error loading configuration. Agent will be disabled. ${err}`);
            }
        }
    }
    start(callback) {
        if (this.isRunning)
            return; //Already started
        if (!this.cfg.enabled.value)
            return; //Don't do anything if agent is completely disabled
        if (!this.cfg.server.value || !this.cfg.token.hasValue)
            return; //Can't start without server or token
        this.reloadConfigFromServer(callback);
        //this.watchdog.start(); //Will be called on the first reload, which is called from agent.start()
        this.isRunning = true;
    }
    stop(callback) {
        this.watchdog.stop();
        this.isRunning = false;
        return callback();
    }
}
exports.ConfigProcess = ConfigProcess;
//# sourceMappingURL=index.js.map