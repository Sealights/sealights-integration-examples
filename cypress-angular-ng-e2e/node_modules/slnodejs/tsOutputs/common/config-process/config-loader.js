"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigLoader = void 0;
const config_system_1 = require("./config-system");
const config_1 = require("./config");
const sl_env_vars_1 = require("../constants/sl-env-vars");
const fs = require("fs");
const jwtDecode = require("jwt-decode");
const contracts_1 = require("../../cli-parse/contracts");
class ConfigLoader {
    constructor(logger) {
        this.logger = logger;
    }
    loadAgentConfiguration(initialJsonConfig) {
        //1. Defaults
        const agentCfg = new config_1.AgentConfig();
        /**
         * 2. This is how the cli program, executed on the parent process, communicates with this process.
         * This configuration takes precedence over other environment variables
         */
        if (process.env.SL_CONFIGURATION) {
            try {
                const jsonCfg = JSON.parse(process.env.SL_CONFIGURATION);
                agentCfg.loadConfiguration(new config_system_1.JsonObjectConfigurationProvider(jsonCfg));
            }
            catch (e) {
                console.error(`Error parsing agent configuration ${e}`);
                //TODO: Log
            }
        }
        //3. Env variables
        agentCfg.loadConfiguration(new config_system_1.EnvVariableConfigurationProvider('SL_'));
        //4. Overwrite file config with runtimeCfg provided by the user
        if (initialJsonConfig) {
            agentCfg.loadConfiguration(new config_system_1.JsonObjectConfigurationProvider(initialJsonConfig));
        }
        if (!agentCfg.token.hasValue && agentCfg.tokenFile.hasValue) {
            try {
                agentCfg.token.value = fs.readFileSync(agentCfg.tokenFile.value).toString();
            }
            catch (err) {
                //TODO: LOG
            }
        }
        //6. Load from token
        if (agentCfg.token.hasValue) {
            this.loadConfigFromToken(agentCfg, agentCfg.token.value);
        }
        this.resolveUsingOtel(agentCfg, initialJsonConfig);
        this.printConfiguration(agentCfg);
        //Rest of configuration will be overridden by server cfg (after agent is loaded)
        return agentCfg;
    }
    printConfiguration(agentCfg) {
        if (!this.logger)
            return;
        this.logger.info('****************************************************');
        this.logger.info('Current config');
        this.logger.info('****************************************************');
        this.logger.info(agentCfg.toJsonObject());
    }
    resolveUsingOtel(agentCfg, initialJsonConfig) {
        agentCfg.useOtel.value = sl_env_vars_1.SlEnvVars.shouldUseOtel() || (initialJsonConfig === null || initialJsonConfig === void 0 ? void 0 : initialJsonConfig[contracts_1.COMMAND_ARGS.ENABLE_OPEN_TELEMETRY]);
    }
    loadConfigFromToken(agentCfg, token) {
        if (!token)
            return null;
        try {
            const tokenData = jwtDecode(token);
            if (!tokenData['x-sl-server']) {
                throw new Error('Token Is Invalid. Doesn\'t Contain Server');
            }
            if (!tokenData['subject']) {
                throw new Error('Token Is Invalid. Doesn\'t Contain Subject');
            }
            let customerId = tokenData['subject'];
            const subjectParts = tokenData['subject'].split('@');
            if (subjectParts.length >= 1) {
                customerId = subjectParts[0];
            }
            if (!agentCfg.server.hasValue) {
                agentCfg.server.value = tokenData['x-sl-server'];
            }
            if (!agentCfg.origin.hasValue) {
                const { origin } = new URL(agentCfg.server.value);
                agentCfg.origin.value = origin;
            }
            agentCfg.customerId.value = customerId;
        }
        catch (err) {
            //TODO: LOG
        }
    }
}
exports.ConfigLoader = ConfigLoader;
//# sourceMappingURL=config-loader.js.map