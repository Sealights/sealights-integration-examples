"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseConfiguration = exports.BooleanConfigKey = exports.NumberConfigKey = exports.StringConfigKey = exports.AgentConfigKey = exports.JsonConfigFileConfigurationProvider = exports.ConfigProviderAggregator = exports.EnvVariableConfigurationProvider = exports.JsonObjectConfigurationProvider = void 0;
const fs = require("fs");
class JsonObjectConfigurationProvider {
    constructor(configObject) {
        this.configObject = configObject;
        this.configObject = configObject || {};
    }
    getAllKeyValues(callback) {
        return callback(null, this.configObject);
    }
    getName() {
        return 'JSON Object';
    }
}
exports.JsonObjectConfigurationProvider = JsonObjectConfigurationProvider;
class EnvVariableConfigurationProvider {
    constructor(prefix) {
        this.prefix = prefix;
    }
    getAllKeyValues(callback) {
        if (this.prefix) {
            const ret = {};
            // for backward compatibility
            ret['httpMaxAttempts'] = process.env['SL_HttpMaxAttempts'];
            ret['httpAttemptInterval'] = process.env['SL_HttpAttemptInterval'];
            // end of for backward compatibility
            for (const key in process.env) {
                if (key.indexOf(this.prefix) == 0) {
                    ret[key.substring(this.prefix.length)] = process.env[key];
                }
            }
            return callback(null, ret);
        }
        else {
            return callback(null, process.env);
        }
    }
    getName() {
        return 'Environment Variables';
    }
}
exports.EnvVariableConfigurationProvider = EnvVariableConfigurationProvider;
class ConfigProviderAggregator {
    constructor(providers) {
        this.providers = providers;
        if (!providers)
            throw new Error('no provider was specified');
    }
    getAllKeyValues(callback) {
        const flattenedConfiguration = {};
        const remainingProviders = [].concat(this.providers);
        const attemptNext = () => {
            if (remainingProviders.length == 0) {
                return callback(null, flattenedConfiguration);
            }
            const nextProvider = remainingProviders.shift();
            nextProvider.getAllKeyValues((err, keysAndValues) => {
                if (err)
                    return attemptNext();
                Object.keys(keysAndValues).forEach(k => {
                    if (!flattenedConfiguration.hasOwnProperty(k))
                        flattenedConfiguration[k] = keysAndValues[k];
                });
                return attemptNext();
            });
        };
        attemptNext();
    }
    getName() {
        return 'Aggregated config from multiple providers: ' + this.providers.map(t => t.getName());
    }
}
exports.ConfigProviderAggregator = ConfigProviderAggregator;
class JsonConfigFileConfigurationProvider {
    constructor(filename) {
        this.filename = filename;
        if (!filename)
            throw new Error('filename is required');
    }
    getAllKeyValues(callback) {
        try {
            const cfg = JSON.parse(fs.readFileSync(this.filename).toString().trim());
            return callback(null, cfg);
        }
        catch (e) {
            return callback(e, null);
        }
    }
    getName() {
        return 'Config filename: ' + this.filename;
    }
}
exports.JsonConfigFileConfigurationProvider = JsonConfigFileConfigurationProvider;
class AgentConfigKey {
}
exports.AgentConfigKey = AgentConfigKey;
class StringConfigKey {
    constructor(required, defaultValue) {
        this.required = required;
        this.isConfigKey = true;
        this.metadata = { required: required, type: 'string' };
        if (defaultValue !== undefined) {
            this.value = defaultValue;
        }
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.hasValue = true;
    }
    loadFromRawData(s) {
        this.value = s;
        this.hasValue = true;
    }
}
exports.StringConfigKey = StringConfigKey;
class NumberConfigKey {
    constructor(required, defaultValue) {
        this.required = required;
        this.isConfigKey = true;
        this.metadata = { required: required, type: 'number' };
        if (defaultValue !== undefined) {
            this.value = defaultValue;
        }
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.hasValue = true;
    }
    loadFromRawData(s) {
        const parsed = parseInt(s);
        if (isNaN(parsed))
            throw new Error(s + ' is not a valid number');
        this.value = parsed;
        this.hasValue = true;
    }
}
exports.NumberConfigKey = NumberConfigKey;
class BooleanConfigKey {
    constructor(required, defaultValue) {
        this.required = required;
        this.isConfigKey = true;
        this.metadata = { required: required, type: 'boolean' };
        if (defaultValue !== undefined) {
            this.value = defaultValue;
        }
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.hasValue = true;
    }
    loadFromRawData(s) {
        if (s == null)
            s = '';
        if (typeof s === 'boolean')
            s = String(s);
        s = s.toLowerCase();
        switch (s) {
            case 'true':
                this.value = true;
                this.hasValue = true;
                return;
            case 'false':
                this.value = false;
                this.hasValue = true;
                return;
            case 'undefined':
                this.value = false;
                this.hasValue = false;
                return;
            default:
                throw new Error('Invalid boolean value: ' + s);
        }
    }
}
exports.BooleanConfigKey = BooleanConfigKey;
class BaseConfiguration {
    loadConfigurationFromMultipleProviders(configProviders, callback) {
        const provider = new ConfigProviderAggregator(configProviders);
        this.loadConfiguration(provider, callback);
    }
    loadConfiguration(configProvider, callback, dbg) {
        try {
            configProvider.getAllKeyValues((err, keysAndValues) => {
                if (err) {
                    if (callback) {
                        callback(err);
                    }
                    return;
                }
                keysAndValues = keysAndValues || {};
                const knownKeys = Object.keys(this);
                let hadError = false;
                let keyWithError = '';
                knownKeys.forEach((keyName) => {
                    if (hadError) {
                        console.log('[Sealights Test Listener] - Failed to load configuration due to invalid value in \'' + keyWithError + '\' field\'.');
                        return;
                    }
                    const cfgKey = this[keyName];
                    if (!cfgKey.isConfigKey)
                        return;
                    const rawValue = keysAndValues[keyName];
                    if (cfgKey.metadata.required && rawValue == undefined) {
                        const msg = 'Required configuration is missing: ' + keyName + ', provider:' + configProvider.getName();
                        hadError = true;
                        if (callback) {
                            callback(new Error(msg));
                        }
                    }
                    if (rawValue == undefined)
                        return; //no value specified and cfg is not required
                    try {
                        cfgKey.loadFromRawData(rawValue);
                    }
                    catch (e) {
                        const msg = 'Invalid configuration for key=' + keyName + ', value=' + rawValue + +', provider=' + configProvider.getName() + ': ' + e.toString();
                        console.log('[Sealights Test Listener] - ' + msg);
                        hadError = true;
                        keyWithError = keyName;
                        if (callback) {
                            callback(new Error(msg));
                        }
                    }
                });
                if (!hadError) {
                    if (callback) {
                        callback(null);
                    }
                    return;
                }
            });
        }
        catch (e) {
            if (callback) {
                callback(e);
            }
            return;
        }
    }
    toJsonObject() {
        const ret = {};
        const knownKeys = Object.keys(this);
        knownKeys.forEach((keyName) => {
            const cfgKey = this[keyName];
            if (cfgKey.isConfigKey && cfgKey.hasValue) {
                ret[keyName] = cfgKey.value;
            }
        });
        return ret;
    }
    getLowerCaseToKeyMap() {
        const lowerCaseMap = {};
        Object.keys(this).forEach(key => {
            lowerCaseMap[key.toLowerCase()] = key;
        });
        return lowerCaseMap;
    }
}
exports.BaseConfiguration = BaseConfiguration;
//# sourceMappingURL=config-system.js.map