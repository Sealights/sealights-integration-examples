"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IpcTransport = exports.BufferingLogger = exports.LoggerFactory = exports.LogLevels = void 0;
const winston = require("winston");
const Transport = require("winston-transport");
const stream_1 = require("stream");
const os_1 = require("os");
const system_date_1 = require("./system-date");
const contracts_1 = require("../build-scanner/instrumentation/process-pool/contracts");
const isLogsOff = () => { var _a; return ((_a = process.env) === null || _a === void 0 ? void 0 : _a.SL_LOG_LEVEL) == LogLevels.OFF; };
const EMPTY_LOGGERS_LIST = [''];
var LogLevels;
(function (LogLevels) {
    LogLevels["LIFECYCLE"] = "lifecycle";
    LogLevels["ERROR"] = "error";
    LogLevels["WARN"] = "warn";
    LogLevels["INFO"] = "info";
    LogLevels["HTTP"] = "http";
    LogLevels["VERBOSE"] = "verbose";
    LogLevels["DEBUG"] = "debug";
    LogLevels["SILLY"] = "silly";
    LogLevels["OFF"] = "off";
})(LogLevels = exports.LogLevels || (exports.LogLevels = {}));
function getLevels() {
    const levels = {};
    levels[LogLevels.LIFECYCLE] = 0;
    levels[LogLevels.ERROR] = 1;
    levels[LogLevels.WARN] = 2;
    levels[LogLevels.INFO] = 3;
    levels[LogLevels.HTTP] = 4;
    levels[LogLevels.VERBOSE] = 5;
    levels[LogLevels.DEBUG] = 6;
    levels[LogLevels.SILLY] = 7;
    return levels;
}
class LoggerFactory {
    constructor() {
    }
    static getCreateBufferingLogger() {
        if (this.bufferingLogger == null) {
            this.bufferingLogger = new BufferingLogger({});
        }
        return this.bufferingLogger;
    }
    static getCreateApplicationLogger(cfg) {
        if (!this.logger) {
            this.logger = this.createLogger(cfg);
        }
        return this.logger;
    }
    static getCreateDebugFileLogger(filename) {
        const fileTransport = new winston.transports.File({ level: LogLevels.DEBUG, filename, format: getJsonFormat() });
        if (!this.logger) {
            const levels = getLevels();
            const transports = [];
            transports.push(fileTransport);
            this.logger = winston.createLogger({ transports, levels });
        }
        else {
            this.logger.add(fileTransport);
        }
        return this.logger;
    }
    static getCreateSubprocessLogger(subprocess) {
        const ipcTransport = new IpcTransport(subprocess, {
            format: getSubprocessFormat(subprocess.pid),
            level: getLogLevel(),
        });
        if (!this.subprocessLogger) {
            const logger = this.createLogger();
            this.subprocessLogger = logger
                .clear()
                .add(ipcTransport);
        }
        return this.subprocessLogger;
    }
    // Added for tests
    static reset() {
        this.logger = null;
        this.bufferingLogger = null;
    }
    static createLogger(cfg) {
        const silent = isLogsOff();
        const levels = getLevels();
        const transports = [];
        let loggers = EMPTY_LOGGERS_LIST;
        if (cfg && cfg.loggers && cfg.loggers.value) {
            loggers = cfg.loggers.value.split(',');
        }
        if (logToFile(loggers)) {
            transports.push(new winston.transports.File({ level: getLogLevel(), filename: 'sl.node.log' }));
        }
        else {
            transports.push(new winston.transports.Console({
                level: getConsoleLogLevel(loggers),
                format: getConsoleFormat(),
                silent
            }));
        }
        const remoteStream = this.getCreateBufferingLogger();
        transports.push(new winston.transports.Stream({
            stream: remoteStream,
            format: getJsonFormat(),
            level: getLogLevel(),
            silent: false
        }));
        return winston.createLogger({ transports, levels });
    }
}
exports.LoggerFactory = LoggerFactory;
class BufferingLogger extends stream_1.Writable {
    constructor(config) {
        super();
        this.config = config;
        this.acceptLogs = true;
        this.buffer = [];
        this.bufferLength = config.bufferLength || 50;
    }
    write(data) {
        if (!this.acceptLogs) {
            return true;
        }
        // Parse the data to json (it receives as string)
        this.buffer.push(JSON.parse(data));
        this.checkBuffer(false);
    }
    processBuffer() {
        if (this.buffer.length == 0)
            return false;
        const entries = this.buffer.splice(0, this.buffer.length);
        if (entries.length > 0) {
            this.emit('log_buffer_full', entries);
        }
        return true;
    }
    stop() {
        this.acceptLogs = false;
    }
    checkBuffer(inShutdown) {
        if (!this.buffer.length) {
            return false; //Nothing more to send
        }
        if (inShutdown || this.buffer.length >= this.bufferLength) {
            return this.processBuffer();
        }
    }
}
exports.BufferingLogger = BufferingLogger;
class IpcTransport extends Transport {
    constructor(subprocess, options) {
        super(options);
        this.subprocess = subprocess;
    }
    log(info, callback) {
        var _a, _b;
        (_b = (_a = this.subprocess).send) === null || _b === void 0 ? void 0 : _b.call(_a, {
            type: contracts_1.PROCESS_MESSAGE_TYPE.LOG,
            payload: {
                level: info.level,
                message: info.message,
                label: info.label,
            }
        });
        callback();
    }
}
exports.IpcTransport = IpcTransport;
function getJsonFormat() {
    return winston.format.combine(winston.format.splat(), winston.format.simple(), winston.format.label({ label: `NodeJS-Agent[${process.pid}]` }), winston.format.timestamp({ format: () => (0, system_date_1.getSystemDate)().toISOString().substr(11) }), winston.format.printf((info) => {
        return JSON.stringify({
            name: info.label,
            hostname: (0, os_1.hostname)(),
            pid: process.pid,
            component: info.component || 'main',
            level: info.level.toUpperCase(),
            msg: info.message
        });
    }));
}
function getConsoleFormat() {
    const colorizer = winston.format.colorize();
    colorizer.addColors({ lifecycle: 'white' });
    return winston.format.combine(winston.format.splat(), winston.format.simple(), winston.format.label({ label: 'NodeJS-Agent' }), winston.format.timestamp({ format: () => (0, system_date_1.getSystemDate)().toISOString().substr(11) }), winston.format.printf((info) => {
        return colorizer.colorize(info.level, `${info.timestamp} ${info.level.toUpperCase()} ${info.label}: ${info.message}`);
    }));
}
function getSubprocessFormat(pid) {
    return winston.format.combine(winston.format.splat(), winston.format.label({ label: `Subprocess [${pid}]` }));
}
function getLogLevel() {
    return process.env.SL_LOG_LEVEL && !isLogsOff() ? process.env.SL_LOG_LEVEL.toLowerCase() : LogLevels.INFO;
}
function getConsoleLogLevel(loggers) {
    if (!logToConsole(loggers)) {
        return LogLevels.LIFECYCLE;
    }
    return getLogLevel();
}
function getNodeDebugLowercase() {
    var _a;
    return (_a = process.env.NODE_DEBUG) === null || _a === void 0 ? void 0 : _a.toLowerCase();
}
function logToConsole(loggers) {
    return getNodeDebugLowercase() == 'sl' || getNodeDebugLowercase() == 'sl-console' || loggers.indexOf('console') >= 0;
}
function logToFile(loggers) {
    return getNodeDebugLowercase() == 'sl-file' || loggers.indexOf('file') >= 0;
}
//# sourceMappingURL=logger.js.map