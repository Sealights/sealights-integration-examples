import { AgentTypes } from '../agent-events/agent-events-contracts';
import { FootprintsMapping } from '../contracts';
export declare class IExtendedIstanbulMetrics {
    footprints: IIstanbulProcessMetrics;
    testName: string;
    executionId: string;
    localTime: number;
    collectionInterval?: ICollectionInterval;
}
export interface ICollectionInterval {
    start: number;
    end: number;
}
/**
 * Stores hit counters for all loaded modules (physical files)
 *
 * @export
 * @interface IIstanbulProcessMetrics
 */
export interface IIstanbulProcessMetrics {
    [moduleName: string]: IIstanbulModule;
}
export interface IIstanbulLocation {
    start: {
        line: number;
        column: number;
    };
    end: {
        line: number;
        column: number;
    };
    st?: {
        l: number;
        c: number;
    };
    e?: {
        l: number;
        c: number;
    };
}
export interface IMethodData {
    name: string;
    line: number;
    loc: IIstanbulLocation;
    decl?: IIstanbulLocation;
    l?: number;
    lc?: IIstanbulLocation;
    d?: IIstanbulLocation;
}
export interface IBranchData {
    line: number;
    type: string;
    locations: IIstanbulLocation[];
    loc?: IIstanbulLocation;
    l?: number;
    t?: string;
    lcs?: IIstanbulLocation[];
    lc?: IIstanbulLocation;
}
/**
 * Stores hit counters per module (physical file)
 * Includes statement, function and branch coverage
 *
 * @export
 * @interface IIstanbulModule
 */
export interface IIstanbulModule {
    /**
     * Statement coverage
     * Key = statement number (as string; 1-based)
     * Value = number of hits per statement
     * Note that this is not an array, but a hash (lookup)
     *
     * @memberOf IIstanbulModule
     */
    s: {
        [statementId: string]: number;
    };
    /**
     * Function coverage
     * Key = method number (as string; 1-based)
     * Value = number of hits per function
     * Note that this is not an array, but a hash (lookup)
     * @memberOf IIstanbulModule
     */
    f: IFunctionIdToHit;
    /**
     * Branch coverage
     * Key = branch number (as string; 1-based)
     * Value = array of number of hits per branch. (e.g. if will have 2 items in the array, one for the IF and another for the ELSE)
     * Note that this is not an array, but a hash (lookup)
     *
     * @memberOf IIstanbulModule
     */
    b: IBranchIdToHit;
    fnMap?: {
        [functionId: string]: IMethodData;
    };
    statementMap?: {
        [functionId: string]: IIstanbulLocation;
    };
    branchMap?: {
        [functionId: string]: IBranchData;
    };
    path?: string;
    uniqueIdsMap?: {
        [old: string]: string;
    };
    /**
     * Data property which Istanbul adds when handling files such as HTML Files
     */
    data?: IIstanbulModule;
}
export interface IFootprintsV6File {
    formatVersion: string;
    moduleName?: string;
    meta: IFootprintsV6Meta;
    methods: string[];
    branches: string[];
    executions: IFootprintsV6TestExecution[];
}
export interface ICollectorFootprintsFile extends IFootprintsV6File {
    meta: ICollectorFootprintsMeta;
}
export interface IFootprintsV6Meta {
    agentId: string;
    labId: string;
    intervals: {
        timedFootprintsCollectionIntervalSeconds: number;
    };
}
export interface ICollectorFootprintsMeta extends IFootprintsV6Meta {
    agentConfig: {
        appName: string;
        agentId: string;
        buildSessionId: string;
        labId: string;
        agentVersion: string;
        agentType: AgentTypes;
        build: string;
        branch: string;
    };
    footprintsMapping: FootprintsMapping;
}
export interface IFootprintsV6TestExecution {
    executionId: string;
    hits: IFootprintsV6Hit[];
}
export interface IFootprintsV6Hit {
    methods?: number[];
    branches?: number[];
    lines?: number[];
    testName?: string;
    start: number;
    end: number;
    isInitFootprints?: boolean;
    isFinalFootprints?: boolean;
}
export interface IHitElements {
    methods: string[];
    branches: string[];
}
export interface IFunctionIdToHit {
    [functionId: string]: number;
}
export interface IBranchIdToHit {
    [branchId: string]: number[];
}
export interface IBranchHit {
    branchData: IBranchData;
    hitLeaves: number[];
}
export interface IHitFileData {
    hitMethods: IMethodData[];
    hitBranches: IBranchHit[];
    filename: string;
    shouldResolveRelativePath: boolean;
}
export type IPosition = IPositionShort | IPositionFull;
export interface IPositionShort {
    l: number;
    c: number;
}
export interface IPositionFull {
    line: number;
    column: number;
}
export interface IHitData {
    hitFilesData: IHitFileData[];
}
export interface IUniqueIdParts {
    relativePath: string;
    start: IPosition;
    absolutePath?: string;
}
export interface IConvertedFootprints {
    branches: string[];
    methods: string[];
}
