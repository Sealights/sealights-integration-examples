"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HitsCollector = void 0;
const sl_env_vars_1 = require("../constants/sl-env-vars");
const original_module_loader_1 = require("../coverage-elements/original-module-loader");
const cockpit_notifier_1 = require("../agent-events/cockpit-notifier");
/**
 * Compare the current element hits to the previous snapshot and returns the diff
 */
const GLOBAL_ISTANBUL_CONTAINER_NAMES = ['__coverage__'];
class HitsCollector {
    constructor(logger, globalCoverageObject) {
        this.errors = [];
        this.logger = logger;
        this._globalCoverageObject = globalCoverageObject;
        this.latestCoverageSnapshot = {};
    }
    getHitElements() {
        return __awaiter(this, void 0, void 0, function* () {
            const hitFilesData = [];
            const globalCoverage = this.getGlobalCoverageObject();
            if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
                new original_module_loader_1.OriginalModuleLoader(globalCoverage, this.logger).load();
            }
            for (const filename in globalCoverage) {
                const { fileCoverageSnapshot, currentFileCoverage, shouldResolveRelativePath } = this.getFileCoverageObjects(filename);
                const hitMethods = this.getHitMethods(currentFileCoverage, fileCoverageSnapshot);
                const hitBranches = this.getHitBranches(currentFileCoverage, fileCoverageSnapshot);
                if (hitMethods.length || hitBranches.length) {
                    hitFilesData.push({ filename, hitMethods, hitBranches, shouldResolveRelativePath });
                }
            }
            this.updateCoverageSnapshot(globalCoverage);
            return hitFilesData;
        });
    }
    get latestCoverageSnapshot() {
        return this._latestCoverageSnapshot;
    }
    set latestCoverageSnapshot(value) {
        this._latestCoverageSnapshot = value;
    }
    get globalCoverageObject() {
        return this._globalCoverageObject;
    }
    set globalCoverageObject(value) {
        this._globalCoverageObject = value;
    }
    getHitMethods(currentHits, snapshotHits) {
        const hitMethodsIndices = Object.keys(currentHits.f).filter(id => {
            snapshotHits.f[id] = snapshotHits.f[id] || 0;
            return currentHits.f[id] > snapshotHits.f[id];
        });
        return hitMethodsIndices.map(id => currentHits.fnMap[id]);
    }
    dropHits() {
        this.updateCoverageSnapshot(this.getGlobalCoverageObject());
    }
    getHitLeaves(currentLeaveHits, snapshotLeaveHits) {
        const hitLeavesIndices = [];
        snapshotLeaveHits = snapshotLeaveHits || Array(currentLeaveHits.length).fill(0);
        currentLeaveHits.forEach((leaveHit, leaveIdx) => {
            if (currentLeaveHits[leaveIdx] > snapshotLeaveHits[leaveIdx]) {
                hitLeavesIndices.push(leaveIdx);
            }
        });
        return hitLeavesIndices;
    }
    getHitBranches(currentHits, fileHitSnapshot) {
        const hitBranches = [];
        for (const branchIdx in currentHits.b) {
            const hitLeaves = this.getHitLeaves(currentHits.b[branchIdx], fileHitSnapshot.b[branchIdx]);
            if (hitLeaves.length > 0) {
                const branchData = currentHits.branchMap[branchIdx];
                hitBranches.push({ branchData, hitLeaves });
            }
        }
        return hitBranches;
    }
    createEmptyIstanbulModule(path, useDataKey = false) {
        const emptyModule = {
            f: {},
            fnMap: {},
            b: {},
            branchMap: {},
            path,
            s: {}
        };
        if (useDataKey) {
            return { data: emptyModule };
        }
        return emptyModule;
    }
    getFileCoverageObjects(filename) {
        let fileCoverageSnapshot = this._latestCoverageSnapshot[filename] || this.createEmptyIstanbulModule(filename);
        let currentFileCoverage = this._globalCoverageObject[filename];
        let shouldResolveRelativePath = true;
        // Istanbul may holds the coverage data under 'data' key see (https://sealights.atlassian.net/browse/SLDEV-4421)
        if (!fileCoverageSnapshot.f && fileCoverageSnapshot.data) {
            fileCoverageSnapshot = fileCoverageSnapshot.data;
            shouldResolveRelativePath = false;
        }
        if (!currentFileCoverage.f && currentFileCoverage.data) {
            currentFileCoverage = currentFileCoverage.data;
        }
        return { fileCoverageSnapshot, currentFileCoverage, shouldResolveRelativePath };
    }
    getGlobalCoverageObject() {
        if (this._globalCoverageObject)
            return this._globalCoverageObject;
        this._globalCoverageObject = HitsCollector.resolveGlobalCoverageObject();
        if (!this._globalCoverageObject) {
            this.logger.warn('Coverage object not found');
        }
        return this._globalCoverageObject;
    }
    static resolveGlobalCoverageObject() {
        const re = /^\$\$cov_[0-9]+\$\$$/;
        const keys = Object.keys(global);
        for (let i = 0; i < keys.length; i++) {
            const k = keys[i];
            if ((re.exec(k)) !== null || GLOBAL_ISTANBUL_CONTAINER_NAMES.indexOf(k) >= 0) {
                return global[k];
            }
        }
    }
    updateCoverageSnapshot(currentCounters) {
        for (const istanbulModule in currentCounters) {
            const useDataKey = currentCounters[istanbulModule].data !== undefined;
            this._latestCoverageSnapshot[istanbulModule] = this._latestCoverageSnapshot[istanbulModule] || this.createEmptyIstanbulModule(istanbulModule, useDataKey);
            const f = currentCounters[istanbulModule].f || currentCounters[istanbulModule].data.f;
            const b = currentCounters[istanbulModule].b || currentCounters[istanbulModule].data.b;
            for (const funcId in f) {
                this.setFunctionHit(istanbulModule, funcId, f, useDataKey);
            }
            for (const branchId in b) {
                this.setBranchHit(b, branchId, istanbulModule, useDataKey);
            }
        }
    }
    setBranchHit(b, branchId, istanbulModule, useDataKey) {
        const currentBranchesHits = b[branchId];
        this._latestCoverageSnapshot[istanbulModule].b[branchId] = this._latestCoverageSnapshot[istanbulModule].b[branchId] || [];
        for (let i = 0; i < currentBranchesHits.length; i++) {
            if (useDataKey) {
                this._latestCoverageSnapshot[istanbulModule].data.b[branchId][i] = currentBranchesHits[i];
            }
            else {
                this._latestCoverageSnapshot[istanbulModule].b[branchId][i] = currentBranchesHits[i];
            }
        }
    }
    setFunctionHit(istanbulModule, funcId, f, useDataKey) {
        if (useDataKey) {
            this._latestCoverageSnapshot[istanbulModule].data.f[funcId] = f[funcId];
        }
        else {
            this._latestCoverageSnapshot[istanbulModule].f[funcId] = f[funcId];
        }
    }
    sendErrors() {
        if (this.errors.length > 0) {
            const data = JSON.stringify(this.errors);
            cockpit_notifier_1.CockpitNotifier.sendGenericMessage(`Errors during hit collection: ${data}`);
            this.errors = [];
        }
    }
}
exports.HitsCollector = HitsCollector;
//# sourceMappingURL=hits-collector.js.map