"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FootprintsProcess = void 0;
const footprints_buffer_1 = require("./footprints-buffer");
const collection_interval_1 = require("../footprints-process/collection-interval");
const state_tracker_1 = require("../state-tracker");
const cockpit_notifier_1 = require("../agent-events/cockpit-notifier");
const agent_events_contracts_1 = require("../agent-events/agent-events-contracts");
const sl_env_vars_1 = require("../constants/sl-env-vars");
const agent_events_guard_1 = require("../agent-events/agent-events-guard");
class FootprintsProcess {
    constructor(cfg, sendToServerWatchdog, keepaliveWatchdog, logger, hitsCollector, hitsConverter, footprintsBuffer, backendProxy, stateTracker) {
        this.isRunning = false;
        this._ongoingRequestsCounter = 0;
        this.footprintsEnqueueOnce = false;
        this.cfg = cfg;
        this.sendToServerWatchdog = sendToServerWatchdog;
        this.keepaliveWatchdog = keepaliveWatchdog;
        this.footprintsBuffer = footprintsBuffer;
        this.hitsConverter = hitsConverter;
        this.hitsCollector = hitsCollector;
        this.backendProxy = backendProxy;
        this.collectionInterval = new collection_interval_1.CollectionInterval(cfg.interval.value);
        this.stateTracker = stateTracker;
        this.logger = logger;
        this.delegateEvents();
    }
    enqueueCurrentFootprints(execution, testName, isFinalFootprints = false) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.currentExecutionBsid = execution.buildSessionId;
            this.collectionInterval.next();
            const hitFilesData = yield this.hitsCollector.getHitElements();
            if (hitFilesData.length) {
                this.logger.info(`Collecting hits for '${hitFilesData.length}' files`);
                const convertedHits = this.hitsConverter.convertHits(hitFilesData);
                this.logger.debug(`Converted total ${(_a = convertedHits === null || convertedHits === void 0 ? void 0 : convertedHits.branches) === null || _a === void 0 ? void 0 : _a.length} branches and ${(_b = convertedHits === null || convertedHits === void 0 ? void 0 : convertedHits.methods) === null || _b === void 0 ? void 0 : _b.length} methods.`);
                this.footprintsBuffer.addHit(convertedHits, this.collectionInterval.toJson(), execution.executionId, testName, this.isInitFootprints(), isFinalFootprints);
                this.logger.debug(`Hits added successfully for execution ${execution.executionId} and test ${testName}.`);
            }
            else {
                this.logger.info('No files were hits, not collecting footprints');
            }
            if (this.isRunning && this.cfg.sendFootprints.value && this.cfg.enabled.value) {
                this.ensureKeepaliveThreadRunning();
                this.sendToServerWatchdog.startIfNotRunning();
            }
            this.footprintsEnqueueOnce = true;
        });
    }
    updateConfig(updatedCfg) {
        return __awaiter(this, void 0, void 0, function* () {
            this.cfg = updatedCfg;
            yield this.stopIfNeededAfterConfigChanged(updatedCfg);
            this.sendToServerWatchdog.setInterval(this.cfg.footprintsSendIntervalSecs.value);
            this.footprintsBuffer.agentConfig = updatedCfg;
        });
    }
    getBufferPacket() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.flushCurrentFootprints(true);
            return this.footprintsBuffer.toJson();
        });
    }
    stopIfNeededAfterConfigChanged(updatedCfg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (updatedCfg.sendFootprints.value === false || updatedCfg.enabled.value === false) {
                cockpit_notifier_1.CockpitNotifier.sendEvent(agent_events_contracts_1.AgentEventCode.AGENT_MUTED);
                this.footprintsBuffer.resetState();
                try {
                    yield this.stop();
                }
                catch (e) {
                    this.logger.error(`Error stopping footprints process ${e.message}`);
                    this.logger.debug(e.stackTrace);
                }
            }
        });
    }
    ensureKeepaliveThreadRunning() {
        this.keepaliveWatchdog.start();
    }
    submitQueuedFootprints(execution) {
        return __awaiter(this, void 0, void 0, function* () {
            this.hitsCollector.sendErrors();
            if (!this.shouldSubmitFootprints()) {
                return;
            }
            const packet = this.footprintsBuffer.createPacket();
            if (packet) {
                this.ongoingRequestsCounter++;
                try {
                    yield this.backendProxy.submitFootprintsV6(packet, execution.buildSessionId, execution.testStage, this.cfg.buildSessionId.value);
                    this.logger.info(`Footprints packet submitted successfully. packet contains ${packet.methods.length} methods, ${packet.branches.length} branches in ${packet.executions.length} executions`);
                }
                catch (e) {
                    this.logger.error(`Error while submitting footprints '${e}'`);
                    agent_events_guard_1.AgentEventsGuard.notifyIfNeeded(agent_events_contracts_1.AgentEventCode.FOOTPRINTS_SUBMISSION_ERROR, e);
                }
                finally {
                    this.ongoingRequestsCounter--;
                }
            }
            else {
                this.logger.info('No hits collected nothing to submit');
            }
        });
    }
    // In this method we allow to submit footprints on a custom execution ID provided by an outside source (ex. Cypress plugin -> remote-agent)
    submitComponentQueuedFootprints(componentBuildSessionId, testStage) {
        return __awaiter(this, void 0, void 0, function* () {
            this.hitsCollector.sendErrors();
            if (!this.shouldSubmitFootprints()) {
                return;
            }
            const packet = this.footprintsBuffer.createPacket();
            if (packet) {
                this.ongoingRequestsCounter++;
                try {
                    // this.cfg.buildSessionId.value represents the bsid of the build the remote-agent was started with (can be integration build), while componentConfig.buildSessionId is the bsid of the component
                    yield this.backendProxy.submitFootprintsV6(packet, this.currentExecutionBsid, testStage, componentBuildSessionId);
                    this.logger.info(`Footprints packet submitted successfully. packet contains ${packet.methods.length} methods, ${packet.branches.length} branches in ${packet.executions.length} executions`);
                }
                catch (e) {
                    this.logger.error(`Error while submitting footprints '${e}'`);
                    agent_events_guard_1.AgentEventsGuard.notifyIfNeeded(agent_events_contracts_1.AgentEventCode.FOOTPRINTS_SUBMISSION_ERROR, e);
                }
                finally {
                    this.ongoingRequestsCounter--;
                }
            }
            else {
                this.logger.info('No hits collected nothing to submit');
            }
        });
    }
    shouldSubmitFootprints() {
        if (!this.isRunning) {
            this.logger.info('Agent is not running, not sending footprints');
            return false;
        }
        if (this.cfg.sendFootprints.value === false) {
            this.logger.info('Not sending footprints since agent is configured to not send.');
            return false;
        }
        return true;
    }
    start() {
        if (this.isRunning)
            return;
        if (this.cfg.enabled.value == false)
            return;
        this.isRunning = true;
        this.sendToServerWatchdog.start();
        if (this.footprintsBuffer.hasHitsInBuffer()) {
            this.ensureKeepaliveThreadRunning();
        }
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            this.sendToServerWatchdog.stop();
            this.hitsCollector.sendErrors();
            if (!this.shouldSubmitFootprints()) {
                this.isRunning = false;
                return;
            }
            yield this.flushCurrentFootprints(true);
            const packet = this.footprintsBuffer.createPacket();
            this.isRunning = false;
            if (!packet) {
                this.logger.info('No hits collected, nothing to submit');
                return;
            }
            this.logger.info('Start submitting footprints, triggered by stop event.');
            try {
                yield this.backendProxy.submitFootprintsV6(packet, this.currentExecutionBsid, this.stateTracker.getTestStage(), this.cfg.buildSessionId.value);
                this.logger.info('Final footprints submitted successfully');
            }
            catch (e) {
                this.logger.error(`Failed to submit final footprints, error: ${e.message}`);
                this.logger.debug(e);
                return;
            }
        });
    }
    handleTestIdChanged(newTestIdentifier, previousTestIdentifier) {
        if (previousTestIdentifier == null) {
            this.logger.info('Test identifier changed, previous identifier wasn\'t set, meaning that we didn\'t have active test. Skip enqueuing footprints process.');
        }
        else {
            const { shouldCollectHits, message } = this.stateTracker.getCollectHitsState();
            if (!shouldCollectHits) {
                this.logger.info(`Test identifier changed. ${message}`);
                return;
            }
            this.logger.debug('Test identifier changed, start enqueuing footprints process.');
            const prevTestIdentifierParts = state_tracker_1.StateTracker.splitTestIdToExecutionAndTestName(previousTestIdentifier);
            this.enqueueCurrentFootprints(this.stateTracker.currentExecution, prevTestIdentifierParts.testName);
        }
    }
    delegateEvents() {
        this.sendToServerWatchdog.on(FootprintsProcess.ALARM_FIRED, () => {
            this.logger.debug('Start submitting footprints, triggered by send to server watchdog.');
            this.submitQueuedFootprints(this.stateTracker.currentExecution);
        });
        this.keepaliveWatchdog.on(FootprintsProcess.ALARM_FIRED, () => {
            if (!this.hasOngoingRequests() && !this.footprintsBuffer.hasHitsInBuffer()) {
                this.keepaliveWatchdog.stop();
            }
        });
        this.footprintsBuffer.on(footprints_buffer_1.FootprintsBuffer.BUFFER_FULL, () => {
            this.submitQueuedFootprints(this.stateTracker.currentExecution);
        });
        this.stateTracker.on(state_tracker_1.StateTracker.EXECUTION_BSID_CHANGED, (prevExecution, newBuildSession) => {
            this.logger.warn(`Execution points to different build session '${newBuildSession}'. Collecting and submitting previous footprints`);
            this.enqueueAndSubmit(prevExecution);
        });
        this.stateTracker.on(state_tracker_1.StateTracker.EXECUTION_ID_CHANGED, (prevExecution, newExecutionId) => {
            this.logger.warn(`Execution id changed to'${newExecutionId}'. Collecting previous footprints`);
            this.enqueueCurrentFootprints(prevExecution, null);
        });
        this.stateTracker.on(state_tracker_1.StateTracker.TEST_STAGE_CHANGED, (prevExecution, newTestStage) => {
            this.logger.warn(`Execution points to different test stage '${newTestStage}'. Collecting and submitting previous footprints`);
            this.enqueueAndSubmit(prevExecution);
        });
        this.stateTracker.on(state_tracker_1.StateTracker.EXECUTION_STATUS_PENDING_DELETE, (execution) => {
            this.enqueueAndSubmit(execution);
        });
    }
    enqueueAndSubmit(executionData, isFinalFootprints = false) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.enqueueCurrentFootprints(executionData, null, isFinalFootprints);
            yield this.submitQueuedFootprints(executionData);
        });
    }
    flushCurrentFootprints(isFinalFootprints = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTestIdentifier = this.stateTracker.getCurrentTestIdentifier();
            const { shouldCollectHits, message, reason } = this.stateTracker.getCollectHitsState();
            // No active execution or execution is pending delete
            if (!shouldCollectHits) {
                this.logger.info(`Enqueue footprints interval - ${message}`);
                this.checkShouldUpdateCoverageSnapshot(reason);
                return;
            }
            // Colored footprints with active execution
            if (currentTestIdentifier) {
                const testIdentifierParts = state_tracker_1.StateTracker.splitTestIdToExecutionAndTestName(currentTestIdentifier);
                this.logger.debug(`Enqueue footprints interval - start enqueuing process. currentTestIdentifier: '${currentTestIdentifier}'`);
                yield this.enqueueCurrentFootprints(this.stateTracker.currentExecution, testIdentifierParts.testName, isFinalFootprints);
            }
            // Anonymous footprints with active execution
            else {
                this.logger.debug('Enqueue footprints interval - start enqueuing process. anonymous footprints');
                yield this.enqueueCurrentFootprints(this.stateTracker.currentExecution, null, isFinalFootprints);
            }
        });
    }
    checkShouldUpdateCoverageSnapshot(reason) {
        if (this.stateTracker.openExecutionFoundOnce) {
            this.logger.debug(`Did not collect hits - reason: ${reason} and not in initFootprints mode, updating coverage snapshot`);
            this.hitsCollector.dropHits();
        }
    }
    isInitFootprints() {
        return this.stateTracker.openExecutionFoundOnce && !this.footprintsEnqueueOnce;
    }
    hasOngoingRequests() {
        return this.ongoingRequestsCounter > 0;
    }
    // TODO: use generic solution for browser and remote agents
    loadSlMapping() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!sl_env_vars_1.SlEnvVars.useSlMapping()) {
                return;
            }
            const mappingsArr = yield this.backendProxy.getBlobsAsJson(this.cfg.buildSessionId.value);
            let flatted = {};
            mappingsArr.forEach(mapping => {
                flatted = Object.assign(Object.assign({}, flatted), mapping);
            });
            this.hitsConverter.slMapping = flatted;
        });
    }
    set ongoingRequestsCounter(value) {
        this._ongoingRequestsCounter = value;
    }
    get backendProxy() {
        return this._backendProxy;
    }
    set backendProxy(value) {
        this._backendProxy = value;
    }
    get cfg() {
        return this._cfg;
    }
    set cfg(value) {
        this._cfg = value;
    }
    get sendToServerWatchdog() {
        return this._sendToServerWatchdog;
    }
    set sendToServerWatchdog(value) {
        this._sendToServerWatchdog = value;
    }
    get keepaliveWatchdog() {
        return this._keepaliveWatchdog;
    }
    set keepaliveWatchdog(value) {
        this._keepaliveWatchdog = value;
    }
}
exports.FootprintsProcess = FootprintsProcess;
FootprintsProcess.ALARM_FIRED = 'alarm';
//# sourceMappingURL=index.js.map