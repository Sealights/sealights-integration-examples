"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HitsConverter = void 0;
const sl_env_vars_1 = require("../constants/sl-env-vars");
const original_module_loader_1 = require("../coverage-elements/original-module-loader");
const hits_collector_1 = require("./hits-collector");
const new_id_resolver_1 = require("../coverage-elements/new-id-resolver");
const cockpit_notifier_1 = require("../agent-events/cockpit-notifier");
class HitsConverter {
    constructor(relativePathResolver, sourceMapData, projectRoot, logger) {
        this.conversionErrors = [];
        this._slMapping = {};
        this.relativePathResolver = relativePathResolver;
        this.sourceMapData = sourceMapData;
        this.projectRoot = projectRoot;
        this.logger = logger;
    }
    convertHits(hitFilesData) {
        let methodUniqueIds = [];
        let branchUniqueIds = [];
        if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
            new original_module_loader_1.OriginalModuleLoader(hits_collector_1.HitsCollector.resolveGlobalCoverageObject(), this.logger).load();
        }
        hitFilesData.forEach(fileHit => {
            let relativePath = fileHit.filename;
            if (fileHit.shouldResolveRelativePath) {
                relativePath = this.relativePathResolver.getRelativePath(fileHit.filename);
            }
            methodUniqueIds = methodUniqueIds.concat(this.createMethodIds(fileHit.hitMethods, relativePath, fileHit.filename));
            branchUniqueIds = branchUniqueIds.concat(this.createBranchIds(fileHit.hitBranches, relativePath, fileHit.filename));
        });
        this.sendConversionErrors();
        return {
            branches: branchUniqueIds,
            methods: methodUniqueIds
        };
    }
    get slMapping() {
        return this._slMapping;
    }
    set slMapping(value) {
        this._slMapping = value;
    }
    createMethodIds(hitFunctions, relativePath, absolutePath) {
        const methodIds = [];
        hitFunctions.forEach(hit => {
            methodIds.push(this.getMethodUniqueId(this.getStartLoc(hit), relativePath, absolutePath));
            if (this.getDecl(hit) && this.getDeclStart(hit)) {
                methodIds.push(this.getMethodUniqueId(this.getDeclStart(hit), relativePath, absolutePath));
            }
        });
        return methodIds;
    }
    getDeclStart(hit) {
        return hit.decl.start;
    }
    getDecl(hit) {
        return hit.decl;
    }
    getStartLoc(hit) {
        return hit.loc.start;
    }
    getLeaveStartLoc(hit, leaveIdx, absolutePath) {
        var _a;
        const position = hit.branchData.locations[leaveIdx].start;
        const parentPosition = (_a = hit.branchData.loc) === null || _a === void 0 ? void 0 : _a.start;
        if (!parentPosition) {
            if (!sl_env_vars_1.SlEnvVars.isUseIstanbul()) {
                const message = `\'SL_useIstanbul\' was set to \'false\' but could not find \'loc\' object. branch in file '${absolutePath}' at '${JSON.stringify(position)}'`;
                this.logger.error(message);
                this.conversionErrors.push(message);
            }
            else {
                this.logger.debug('Using branch position from \'locations\' object due to \'SL_useIstanbul\' set to \'true\'');
            }
            return position;
        }
        const newInstrumentation = (parentPosition.line != position.line) || (parentPosition.column != position.column);
        if (hit.branchData.type === 'if') {
            const message = newInstrumentation ? 'Instrumented done by istanbul-lib-instrumenter greater or equal than 5.1.0 enforcing parent positions for the else leave' :
                'Instrumented done by istanbul-lib-instrumenter lower than 5.1.0 using parent positions for the else leave';
            this.logger.debug(message);
            return parentPosition;
        }
        return position;
    }
    createBranchIds(hitFunctions, relativePath, absolutePath) {
        const branchIds = [];
        hitFunctions.forEach(hit => {
            hit.hitLeaves.forEach(leaveIdx => {
                branchIds.push(this.getBranchUniqueId(this.getLeaveStartLoc(hit, leaveIdx, absolutePath), relativePath, absolutePath, leaveIdx));
            });
        });
        return branchIds;
    }
    getMethodUniqueId(startLoc, relativePath, absolutePath) {
        const idParts = this.resolveIdParts(startLoc, relativePath, absolutePath);
        if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
            const uniqueIdKey = idParts.relativePath + '@' + this.formatLoc(idParts.start);
            const uniqueId = (0, new_id_resolver_1.resolveNewId)(uniqueIdKey, idParts.absolutePath, idParts.relativePath, hits_collector_1.HitsCollector.resolveGlobalCoverageObject(), this.logger);
            if (uniqueId) {
                return uniqueId;
            }
        }
        return this.buildMethodUniqueId(idParts);
    }
    getBranchUniqueId(startLoc, relativePath, absolutePath, leaveIndex) {
        let uniqueId;
        const parts = this.resolveIdParts(startLoc, relativePath, absolutePath);
        if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
            const uniqueIdKey = parts.relativePath + '|' + this.formatLoc(parts.start) + '|' + leaveIndex;
            uniqueId = (0, new_id_resolver_1.resolveNewId)(uniqueIdKey, parts.absolutePath, parts.relativePath, hits_collector_1.HitsCollector.resolveGlobalCoverageObject(), this.logger);
        }
        if (!uniqueId) {
            uniqueId = parts.relativePath + HitsConverter.BRANCH_ID_DEL + this.formatLoc(parts.start) + HitsConverter.BRANCH_ID_DEL + leaveIndex;
        }
        return uniqueId;
    }
    resolveIdParts(startLoc, relativePath, absolutePath) {
        const sourcePosition = this.sourceMapData.getSourcePosition(relativePath, absolutePath, startLoc, this.projectRoot, this.slMapping);
        return sourcePosition ? sourcePosition : { relativePath: relativePath, start: startLoc, absolutePath: absolutePath };
    }
    buildMethodUniqueId(parts) {
        return parts.relativePath + HitsConverter.METHOD_ID_DEL + this.formatLoc(parts.start);
    }
    sendConversionErrors() {
        if (this.conversionErrors.length > 0) {
            cockpit_notifier_1.CockpitNotifier.sendErrorsBatch(this.conversionErrors);
            this.conversionErrors = [];
        }
    }
    formatLoc(loc) {
        return loc.line + ',' + loc.column;
    }
}
exports.HitsConverter = HitsConverter;
HitsConverter.METHOD_ID_DEL = '@';
HitsConverter.BRANCH_ID_DEL = '|';
//# sourceMappingURL=hits-converter.js.map